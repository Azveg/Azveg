[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Best Practices IT",
    "section": "",
    "text": "Примеры практик, статьи и описание технологий IT\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDplyr cheat sheet\n\n\n\n\n\n\n\nR\n\n\ndplyr\n\n\ntidyverse\n\n\n\n\nОбзор основного функционала пакета dplyr\n\n\n\n\n\n\nNov 16, 2022\n\n\n15 min\n\n\n\n\n\n\n\n\nQuarto cheat sheet\n\n\n\n\n\n\n\nR\n\n\nQuarto\n\n\ncheatsheet\n\n\n\n\nОписание возможностей Quarto для создания web сайтов и их наполнения\n\n\n\n\n\n\nOct 11, 2022\n\n\n5 min\n\n\n\n\n\n\n\n\nR language\n\n\n\n\n\n\n\n\n\n\n\n\n0 min\n\n\n\n\n\n\n\n\nUpSet диаграммы - введение\n\n\n\n\n\n\n\nR\n\n\nUpSet\n\n\nHeatmap\n\n\nvisualization\n\n\n\n\nПостроение диаграмм пересечения множеств с помощью UpSet графиков развитие диаграмм Вена на большом количестве анализируемых атрибутов\n\n\n\n\n\n\nOct 18, 2022\n\n\n4 min\n\n\n\n\n\n\n\n\nVisualization\n\n\n\n\n\n\n\n\n\n\n\n\n0 min\n\n\n\n\n\n\n\n\nСоздание графиков в пакете UpSetR\n\n\n\n\n\n\n\nR\n\n\nUpSet\n\n\nvisualization\n\n\n\n\nРассмотрим пакет UpSetR, разберем примеры построения качественных и красивых графиков\n\n\n\n\n\n\nNov 24, 2022\n\n\n23 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html",
    "title": "Dplyr cheat sheet",
    "section": "",
    "text": "Выполним установку пакета dplyr и загрузим набор данных starwars"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#выборка-данных",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#выборка-данных",
    "title": "Dplyr cheat sheet",
    "section": "Выборка данных",
    "text": "Выборка данных\nВ R возможно делать выборку столбцов разными стособами. Просто перечислить названия столбцов или их номера, перечислить какие столбцы не нужно выводить или выводить столбцы с именем соответствующим определенному условию.Выбор с использованием tidyselect рассмотрели выше, теперь рассмотрим ещё пару стандартных способов отбора столбцов.\nВернуть вектор\nЕсли нужно вернуть столбец не как таблицу, а вектор, то делаем это через pull\n\nstarwars %>% \n  pull('name')\n\n [1] \"Luke Skywalker\"        \"C-3PO\"                 \"R2-D2\"                \n [4] \"Darth Vader\"           \"Leia Organa\"           \"Owen Lars\"            \n [7] \"Beru Whitesun lars\"    \"R5-D4\"                 \"Biggs Darklighter\"    \n[10] \"Obi-Wan Kenobi\"        \"Anakin Skywalker\"      \"Wilhuff Tarkin\"       \n[13] \"Chewbacca\"             \"Han Solo\"              \"Greedo\"               \n[16] \"Jabba Desilijic Tiure\" \"Wedge Antilles\"        \"Jek Tono Porkins\"     \n[19] \"Yoda\"                  \"Palpatine\"             \"Boba Fett\"            \n[22] \"IG-88\"                 \"Bossk\"                 \"Lando Calrissian\"     \n[25] \"Lobot\"                 \"Ackbar\"                \"Mon Mothma\"           \n[28] \"Arvel Crynyd\"          \"Wicket Systri Warrick\" \"Nien Nunb\"            \n[31] \"Qui-Gon Jinn\"          \"Nute Gunray\"           \"Finis Valorum\"        \n[34] \"Jar Jar Binks\"         \"Roos Tarpals\"          \"Rugor Nass\"           \n[37] \"Ric Olié\"              \"Watto\"                 \"Sebulba\"              \n[40] \"Quarsh Panaka\"         \"Shmi Skywalker\"        \"Darth Maul\"           \n[43] \"Bib Fortuna\"           \"Ayla Secura\"           \"Dud Bolt\"             \n[46] \"Gasgano\"               \"Ben Quadinaros\"        \"Mace Windu\"           \n[49] \"Ki-Adi-Mundi\"          \"Kit Fisto\"             \"Eeth Koth\"            \n[52] \"Adi Gallia\"            \"Saesee Tiin\"           \"Yarael Poof\"          \n[55] \"Plo Koon\"              \"Mas Amedda\"            \"Gregar Typho\"         \n[58] \"Cordé\"                 \"Cliegg Lars\"           \"Poggle the Lesser\"    \n[61] \"Luminara Unduli\"       \"Barriss Offee\"         \"Dormé\"                \n[64] \"Dooku\"                 \"Bail Prestor Organa\"   \"Jango Fett\"           \n[67] \"Zam Wesell\"            \"Dexter Jettster\"       \"Lama Su\"              \n[70] \"Taun We\"               \"Jocasta Nu\"            \"Ratts Tyerell\"        \n[73] \"R4-P17\"                \"Wat Tambor\"            \"San Hill\"             \n[76] \"Shaak Ti\"              \"Grievous\"              \"Tarfful\"              \n[79] \"Raymus Antilles\"       \"Sly Moore\"             \"Tion Medon\"           \n[82] \"Finn\"                  \"Rey\"                   \"Poe Dameron\"          \n[85] \"BB8\"                   \"Captain Phasma\"        \"Padmé Amidala\"        \n\n\nСтолбцы\nПеречисление\n\nstarwars %>% \n  select(name)\n\n\n\n  \n\n\n\nОтрицательное перечисление\nЕсли нужно указать какой столбец не включать в выборку то ставится знак минус:\n\nstarwars %>% \n  select(-c(name, mass))\n\n\n\n  \n\n\n\nПо номерам\nИли можно указать номера столбцов\n\nstarwars %>% \n  select(1, 2)\n\n\n\n  \n\n\n\nУпорядочивание столбцов\nrelocate(.data, …, .before = NULL, .after = NULL) - смена позиции столбца, использует иснтаксис select(включая tidy-select) чтобы легко перемещать один или несколько столбоц за один раз\n\n\n.data - указываем, что переместить\n\n.before - перемещение до и указваем столбец или выражение tidy-select\n\n.after - перемещение после и указваем столбец или выражение tidy-select\n\n\n\n\ndf <- tibble(a = 1, d = \"a\", b = 1, f = \"a\")\ndf\n\n\n\n  \n\n\n\n\n# ставим стоблец f в начало\ndf %>% relocate(f)\n\n\n\n  \n\n\n\n\n# ставим стоблец a после d\ndf %>% relocate(a, .after = d)\n\n\n\n  \n\n\n\n\n# ставим стоблец f перед b\ndf %>% relocate(f, .before = b)\n\n\n\n  \n\n\n\n\n\nИ ещё несколько вариантов используя tidy-select\n\n\n\n# числовые столбцы в конец\ndf %>% \n  relocate(where(is.numeric), \n           .after = last_col())\n\n\n\n  \n\n\n\n\n# если есть столбцы с такими названиями\n# то их ставим вначало\ndf %>% \n  relocate(any_of(c(\"a\", \"e\", \"i\", \"o\", \"u\")))\n\n\n\n  \n\n\n\n\n# числовые столбцы после символьных\ndf %>% \n  relocate(where(is.numeric), \n           .after = where(is.character))\n\n\n\n  \n\n\n\n\n\nСтроки\nУникальные значения\n\nstarwars %>% \n  distinct(sex)\n\n\n\n  \n\n\n\nСлучайные строки\nВозвращаем n - случайных строк\n\nstarwars %>% \n  sample_n(5)\n\n\n\n  \n\n\n\nЕсли нужно указать долю строк из общего числа, которые должны быть в итоговой таблице, то используем sample_frac. Например, при параметре 0.5 вернется половина строк из таблицы, выбранные случайным образом.\n\nstarwars %>% \n  sample_frac(0.1)\n\n\n\n  \n\n\n\nСрезы\nФункции slice позволяют сделать срез из выборки данных по условию, рассмотрим аргументы функций:\n\n\nn, prop - задает количество (n) или пропорцию (prop) выбираемых строк, по умолчанию n = 1. Если указано отрицательное значение n или prop, указанное количество или пропорция строк будут удалены. Если n больше, чем количество строк в группе (или prop > 1), результат будет автоматически усечен до размера группы. Если доля размера группы не дает целого числа строк, абсолютное значение prop * nrow(.data) округляется в меньшую сторону.\n\nwith_ties - указывает нужно ли включать в выборку дубликаты по выбранному столбцу\n\nweight_by - задает взвешенную случайную выборку фрейма данных т.е. задает вероятность включения каждой строки в результирующее подмножество, которая будет пропорциональна значениям в указанном столбце. Указав вес столбца, можно гарантировать, что более важные строки с большей вероятностью попадут в выборку. Используется когда нужно сделать репрезентативную выборку для исследования.\n\nreplace - указывает нужно ли переписывать текущий фрейм, если значение TRUE, то текущий фрейм сразу заменяется результатом выборки, если FALSE, то выборка возвращается как новый фрейм данных, без изменения исходного фрейма.\n\nСоздадим набор данных для описания возможностей работы со срезами\n\ndf <- tribble(\n  ~key, ~val_y, ~val_x,\n     1, \"y1\",   6,\n     2, \"y2\",   1,\n     3, \"y3\",   3,\n     4, \"y4\",   9,\n     5, \"y5\",   2,\n     6, \"y6\",   7,\n     7, \"y7\",   4,\n     8, \"y8\",   10,\n     9, \"y9\",   5,\n     9, \"y10\",  8 \n)\ndf\n\n\n\n  \n\n\n\n\nslice\nslice(.data, ..., .preserve = FALSE)\nФункция slice() позволяет выбирать строки из фрейма данных на основе их положения. Функция принимает два аргумента, первый из которых является фреймом данных, а второй - диапазоном строк для выбора. Диапазон задается с помощью оператора : и может быть одним значением или диапазоном значений.\n\n\n\ndf %>% \n  slice(1:n()) \n\n\n\n  \n\n\n\n\ndf %>% \n  slice(1:4) \n\n\n\n  \n\n\n\n\ndf %>% \n  slice(1L)\n\n\n\n  \n\n\n\n\n\n\nslice_head\nslice_head(.data, ..., n, prop)\nФункция slice_head() аналогична функции slice(), но выбирает первые n строк фрейма данных. Функция принимает два аргумента, первый из которых является фреймом данных, а второй - количеством строк для выбора.\n\n\n\ndf %>% \n  slice_head(n = 5) \n\n\n\n  \n\n\n\n\ndf %>% \n  slice_head(prop = 0.2) \n\n\n\n  \n\n\n\n\n\n\nslice_tail\nslice_tail(.data, ..., n, prop)\nФункция slice_tail() аналогична функции slice(), но выбирает последние n строк фрейма данных. Функция принимает два аргумента, первый из которых является фреймом данных, а второй - количеством строк для выбора.\n\n\n\ndf %>% \n  slice_tail(n = 5) \n\n\n\n  \n\n\n\n\ndf %>% \n  slice_tail(prop = 0.1) \n\n\n\n  \n\n\n\n\n\n\nslice_min\nslice_min(.data, order_by, ..., n, prop, with_ties = TRUE)\nФункция slice_min() используется для выбора строк с минимальными значениями указанного столбца.\n\ndf %>% \n  slice_min(key, n = 2) \n\n\n\n  \n\n\n\n\nslice_max\nslice_max(.data, order_by, ..., n, prop, with_ties = TRUE)\nФункция slice_max() используется для выбора строк с максимальными значениями указанного столбца. Функция принимает аргументы, первый из которых является фреймом данных, а второй - столбцом для выбора.\n\n\n\ndf %>% \n  slice_max(key, n = 3) \n\n\n\n  \n\n\n\n\ndf %>% \n  slice_max(key, n = 1, with_ties = T) \n\n\n\n  \n\n\n\n\ndf %>% \n  slice_max(key, n = 1, with_ties = F) \n\n\n\n  \n\n\n\n\n\n\nslice_sample\nslice_sample(.data, ..., n, prop, weight_by = NULL, replace = FALSE)\nФункция slice_sample() используется для выбора случайной выборки строк из фрейма данных. Функция принимает аргументы, первый из которых является фреймом данных, а второй - количеством строк для выбора.\n\n\n\ndf %>% \n  slice_sample(n = 4) \n\n\n\n  \n\n\n\n\ndf %>% \n  slice_sample(n = 4, weight_by = val_x)"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#фильтрация-строк",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#фильтрация-строк",
    "title": "Dplyr cheat sheet",
    "section": "Фильтрация строк",
    "text": "Фильтрация строк\nПо логическому условию\n\nstarwars %>% \n  filter(mass > 50)\n\n\n\n  \n\n\n#комбинировать несколько условий можно с помощью & и |:\nstarwars %>% \n  filter(mass > 50 & height > 170)\n\n\n\n  \n\n\n\nКонструировать логические условия можно и другими операторами\n\n>=\n<=\nis.na\n!is.na\n%in%\n!\nbetween\nnear\nxor\n\n\nstarwars %>% \n  filter(skin_color %in% c('fair', 'green'))"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#сортировка-строк",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#сортировка-строк",
    "title": "Dplyr cheat sheet",
    "section": "Сортировка строк",
    "text": "Сортировка строк\nДля сортировки в языке есть достаточно широкие возможности. Вот самые основные виды сортировки:\nПо возрастанию\n\nstarwars %>% \n  arrange(mass)\n\n\n\n  \n\n\n\nПо убыванию\n\n# сортировка по убыванию\nstarwars %>% \n  arrange(desc(mass))\n\n\n\n  \n\n\n\nПо нескольким столбцам\n\n# сортировка по нескольким столбцам\nstarwars %>% \n  arrange(height, desc(mass))\n\n\n\n  \n\n\n\nРасширенная сортировка\nПри сортировке можно использовать вспомогательные функции для select, только внутри функции across\n\nstarwars %>% \n  arrange(across(ends_with('_color'), desc))"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#группировка-и-агрегатные-функции",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#группировка-и-агрегатные-функции",
    "title": "Dplyr cheat sheet",
    "section": "Группировка и агрегатные функции",
    "text": "Группировка и агрегатные функции\n\n# сама по себе группировка не несет смысла, только в сочетании с агрегирующими функциями\nstarwars %>% \n  group_by(eye_color)\n\n\n\n  \n\n\n\n\nstarwars %>% \n  group_by(eye_color) %>% # группируем по полю\n  summarise(\n    'mean mass' = mean(mass), # задаем имя столбцу и применяем функцию\n    'max mass' = max(mass),\n    'min mass' = min(mass),\n    'first mass' = first(mass),\n    'median mass' = median(mass),\n    'quantity' = n()\n  )\n\n\n\n  \n\n\n# про другие функции summarise в ?summarise\n\nРассчитать показатели только для нескольких столбцов сразу\n\nstarwars %>% \n  group_by(eye_color) %>% \n  summarise(\n    across(\n      .cols = c(mass, height), # столбцы к котторым применятся функции\n      .fns = list(mean = mean, max = max, min = min, first = first, median = median), # набор функций\n      .names = \"{.col}.fn_{.fn}\"  # шаблон имени столбца\n    )\n  )"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#вычисляемые-столбцы",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#вычисляемые-столбцы",
    "title": "Dplyr cheat sheet",
    "section": "Вычисляемые столбцы",
    "text": "Вычисляемые столбцы\nНовый столбец\nmutate\n\nstarwars %>% \n  select(name, height, mass) %>% \n  mutate('coef' = mass/height)"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#оконные-функции",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#оконные-функции",
    "title": "Dplyr cheat sheet",
    "section": "Оконные функции",
    "text": "Оконные функции\nОконные функции применяются с mutate или transmutate\n\nstarwars %>% \n  select(name, height, mass) %>% \n  mutate('rnk' = dense_rank(mass)) %>% \n  mutate('r_num' = row_number(mass)) \n\n\n\n  \n\n\n\nWindowed rank functions\nrow_number(): equivalent to rank(ties.method = “first”)\nmin_rank(): equivalent to rank(ties.method = “min”)\ndense_rank(): like min_rank(), but with no gaps between ranks\npercent_rank(): a number between 0 and 1 computed by rescaling min_rank to ⁠[0, 1]⁠\ncume_dist(): a cumulative distribution function. Proportion of all values less than or equal to the current rank.\nntile(): a rough rank, which breaks the input vector into n buckets. The size of the buckets may differ by up to one, larger buckets have lower rank.\nCompute lagged or leading values\nlag(x, n = 1L, default = NA, order_by = NULL, …)\nlead(x, n = 1L, default = NA, order_by = NULL, …)\nCumulativate\ncumall(x): all cases until the first FALSE.\ncumall(!x): all cases until the first TRUE.\ncumany(x): all cases after the first TRUE.\ncumany(!x): all cases after the first FALSE.\ncummean(x)"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#обработка-null",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#обработка-null",
    "title": "Dplyr cheat sheet",
    "section": "Обработка null",
    "text": "Обработка null\ncoaleasce\nna_if"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#объединение-таблиц",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#объединение-таблиц",
    "title": "Dplyr cheat sheet",
    "section": "Объединение таблиц",
    "text": "Объединение таблиц\nВ процессе объединения таблиц можно выделить операции трех видов:\n\nMutating joins, которые добавляют новые переменные в один фрейм данных из совпадающих наблюдений в другом.\nFiltering joins, которые фильтруют наблюдения из одного фрейма данных на основе того, соответствуют ли они наблюдению в другой таблице.\nSet operations, эти операции работают с пересечениями двух фреймов\n\nДля разбора операций соединения, загрузим набор данных nycflights13\n```{r}\nlibrary(nycflights13)\n```\nКлючи соединения\nСопоставление ключей\nПри соединении фреймов данных нужно указать ключи соединения иногда это может быть один ключ или набор ключей, они могут совпадать по наименованию или различаться. Давайте рассмотрим разные варианты.\nСоединить по всем совпадающим полям\nЧтобы соединить по всем совпадающим по названию полям, нужно оставить by = NULL\n\nflights2 %>% \n  left_join(weather)\n\nJoining, by = c(\"year\", \"month\", \"day\", \"origin\", \"hour\", \"time_hour\")\n\n\n\n\n  \n\n\n\n\nСоединить по одному ключу\nСоединение по одному ключу с общим для обоих фреймов названием:\n\nflights2 %>% \n  left_join(planes, by = \"tailnum\")\n\n\n\n  \n\n\n\n\nСоединить по нескольким ключам\n\nby = c(“a” = “b”) -> x$a == y$b - соединить с помощью разных переменных на x и y, используется именованный вектор.\nby = c(“a”, “b”) -> x$a == y$a and x$b == y$b - соединить по нескольким переменным\nby = c(“a” = “b”, “c” = “d” -> x$a == y$b and x$c  == y$d - соединить сопоставив раличные переменные из двух фреймов\n\n\nflights2 %>% \n  left_join(airports, c(\"dest\" = \"faa\"))\n\n\n\n  \n\n\n\nПроблемы с ключами\nНе всегда бывает так, что значения в ключевом столбце уникальные. Когда соединяются дублированные ключи, получаются все возможные комбинации, декартово произведение. В функции Join нет никакой обработки таких случаев, поэтому нужно быть внимательным к своим данным и проверять результирующий набор данных. А также при необходимости удалять дублирующие строки.\nУбедитесь, что ваши внешние ключи совпадают с первичными ключами в другой таблице. Лучший способ сделать это - с помощью anti_join(). Часто ключи не совпадают из-за ошибок ввода данных. Их устранение часто требует большой работы.\nMutating joins\nВ принципе это самые обычные и привычные Join-ы, которые мы используем каждый день. Рассмотрим аргументы этих функций:\n\nx, y - пара фреймов данных, которые нужно соединить\nby - вектор переменных в котором задаются ключи\nsuffix - добавляет суффиксы для одноименных не ключевых полей\nkeep - указывает, нужно ли сохранять ключевые поля в результирующем фрейме данных\nna_matches - задает считать или нет равными значения NA и NaN, по умолчанию “na” считаются равными, “never” - исчтать не равными\n\nЧтобы понять суть разных типов соединений, создадим два тестовых фрейма данных и проиллюстрируем на их примере каждый тип:\n\nx <- tribble(\n  ~key, ~val_x,\n     1, \"x1\",\n     2, \"x2\",\n     3, \"x3\"\n)\ny <- tribble(\n  ~key, ~val_y,\n     1, \"y1\",\n     2, \"y2\",\n     4, \"y3\"\n)\n\nx\ny\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n\n\n\n\nInner join\nВнутреннее соединение сопоставляет пары наблюдений всякий раз, когда их ключи равны.Наиболее важным свойством внутреннего соединения является то, что несогласованные строки не включаются в результат. Это означает, что, как правило, внутренние соединения обычно не подходят для использования в анализе, потому что слишком легко потерять наблюдения.\n```{r}\ninner_join(\n  x,\n  y,\n  by = NULL,\n  copy = FALSE,\n  suffix = c(\".x\", \".y\"),\n  ...,\n  keep = FALSE,\n  na_matches = c(\"na\", \"never\")\n)\n```\n\n\n\nx\n\n\n\n  \n\n\n\n\ny\n\n\n\n  \n\n\n\n\n\n\ninner_join\n\n\n\n\ninner_join(x, y, by = \"key\")\n\n\n\n  \n\n\n\n\n\nOuter joins\nВнешнее соединение сохраняет наблюдения, которые отображаются по крайней мере в одной из таблиц.\nLeft Join\nleft_join - сохраняет все строки из первой таблицы и соединяет все совпавшие по ключу строки из второй таблицы.\nНаиболее часто используемым соединением является левое соединение: его используют всякий раз, когда просматривают дополнительные данные из другой таблицы, потому что оно сохраняет исходные наблюдения, даже если совпадения нет. Левое соединение должно быть соединением по умолчанию: используйте его, если у нет веских причин предпочесть одно из других.\n```{r}\nleft_join(\n  x,\n  y,\n  by = NULL,\n  copy = FALSE,\n  suffix = c(\".x\", \".y\"),\n  ...,\n  keep = FALSE,\n  na_matches = c(\"na\", \"never\")\n)\n```\nРазберем подробнее левое соединение:\n\n\n\nx\n\n\n\n  \n\n\n\n\ny\n\n\n\n  \n\n\n\n\n\n\nleft_join\n\n\n\n\nleft_join(x, y, by = \"key\")\n\n\n\n  \n\n\n\n\n\nRight Join\nright_join - сохраняет все строки из второй таблицы и соединяет все совпавшие по ключу строки из первой таблицы\n```{r}\nright_join(\n  x,\n  y,\n  by = NULL,\n  copy = FALSE,\n  suffix = c(\".x\", \".y\"),\n  ...,\n  keep = FALSE,\n  na_matches = c(\"na\", \"never\")\n)\n```\n\n\n\nx\n\n\n\n  \n\n\n\n\ny\n\n\n\n  \n\n\n\n\n\n\nright_join\n\n\n\n\nright_join(x, y, by = \"key\")\n\n\n\n  \n\n\n\n\n\nFull Join\nfull_join - сохраняет все строки из обоих таблиц\n```{r}\nfull_join(\n  x,\n  y,\n  by = NULL,\n  copy = FALSE,\n  suffix = c(\".x\", \".y\"),\n  ...,\n  keep = FALSE,\n  na_matches = c(\"na\", \"never\")\n)\n```\n\n\n\nx\n\n\n\n  \n\n\n\n\ny\n\n\n\n  \n\n\n\n\n\n\nfull_join\n\n\n\n\nfull_join(x, y, by = \"key\")\n\n\n\n  \n\n\n\n\n\nFiltering joins\nФильтрующие соединения используются для фильтрации первого фрейма на основе данных из второго фрейма данных.\nsemi_join\nsemi_join соединяет две таблицы подобно мутирующему соединению, но вместо добавления новых столбцов сохраняет только те строки в x, которые совпадают в y.\n\n\n\nx\n\n\n\n  \n\n\n\n\ny\n\n\n\n  \n\n\n\n\n\n\nsemi_join\n\n\n\n\nsemi_join(x, y, by = \"key\")\n\n\n\n  \n\n\n\n\n\nВажно только наличие совпадения; не имеет значения, какому наблюдению соответствует. Это означает, что фильтрующие соединения никогда не дублируют строки, как это делают мутирующие соединения.\nanti_join\nАнтисоединения полезны для диагностики несоответствий соединений. Например, так можно делать проверку полноты данных по эталонным справочникам:\n\n\n\nx\n\n\n\n  \n\n\n\n\ny\n\n\n\n  \n\n\n\n\n\n\nanti_join\n\n\n\n\nanti_join(x, y, by = \"key\")\n\n\n\n  \n\n\n\n\n\nnest_join\nnest_join() возвращает все строки и столбцы в x с новым столбцом в каждой строке которого вложен фрейм, содержащий все совпадения из y. Если совпадений нет, то фрейм будет пустой.\n\n\n\nx\n\n\n\n  \n\n\n\n\ny\n\n\n\n  \n\n\n\n\nnest_join(x, y, by = \"key\")\n\n\n\n  \n\n\n\n\nnest_join(x, y, by = \"key\") %>% \n  unnest(cols = c(y))\n\n\n\n  \n\n\n\n\n\nSet operations\nОперации с наборами требуют чтобы соединяемые фреймы данных имели одинаковое количество столбцов, эти функции объединяют два фрейма данных как бы складывая их друг под друга.\nСоздадим два фрейма, чтобы показать работу этих функций:\n\ndf1 <- tribble(\n  ~x, ~y,\n   1,  1,\n   2,  1\n)\ndf2 <- tribble(\n  ~x, ~y,\n   1,  1,\n   1,  2\n)\n\nunion\n\nunion - оставляет только уникальные строки из обоих наборов\nunion_all - оставляет все строки из обоих наборов\n\n\n\n\ndf1\n\n\n\n  \n\n\n\n\ndf2\n\n\n\n  \n\n\n\n\nunion(df1, df2)\n\n\n\n  \n\n\n\n\nunion_all(df1, df2)\n\n\n\n  \n\n\n\n\n\nintersect\nоставляет только совпавшие строки из обоих наборов:\n\n\n\ndf1\n\n\n\n  \n\n\n\n\ndf2\n\n\n\n  \n\n\n\n\n\n\nintersect\n\n\n\n\nintersect(df1, df2)\n\n\n\n  \n\n\n\n\n\nsetdiff\nоставляет строки из первого фрейма только не совпавшие со строками из второго фрейма\n\n\n\ndf1\n\n\n\n  \n\n\n\n\ndf2\n\n\n\n  \n\n\n\n\n\n\nintersect\n\n\n\n\nsetdiff(df1, df2)\n\n\n\n  \n\n\n\n\nsetdiff(df2, df1)"
  },
  {
    "objectID": "r_language/Tutorial/Quarto_cheatsheet.html",
    "href": "r_language/Tutorial/Quarto_cheatsheet.html",
    "title": "Quarto cheat sheet",
    "section": "",
    "text": "Отображение контента\n\nСодержание страницы\n\ntoc: true|false - включение/отключение отображения содержания страницы\ntoc-depth: 2 - глубина отображаемых заголовков в содержании\ntoc-title: Contents - заголовок содержания\ntoc-location: left - положение содержания\n\n\n\nБлок кода\nВ блоке кода опции можно задавать через комментарий вида: #|, вот некоторые опции:\n\necho: true|false - показать\\скрыть код\ninclude: false - показать\\скрыть результат работы кода\nwarning: true|false - показать\\скрыть предупреждения\nerror: true|false - показать\\скрыть ошибки при выполнении\ncode-fold: true - добавить опцию свернуть\\развернуть код\ncode-summary: \"Show the code\" - заголовок свернутого блока кода\ncode-overflow: wrap|scroll - добавляет скролл или перенос по словам для длинных строк кода\n\n\n\nИзображения и графики\nОписание вариантов размещения изображений и графиков приведено в статье1.\n\n\n\nНастройка темы\n\nТема блока кода\nДля блока кода можно задать тему, что примечательно если на сайте заданы светлая и темная темы, то для каждой из них можно установить свою тему блока кода.\nhighlight-style: github - установить тему github для блока кода\nУстановить для светлой и темной темы, темы блоков кода\nhighlight-style:\n  light: custom-light.theme\n  dark: custom-dark.theme\nСписок тем: [a11y, arrow, atom-one, ayu, breeze, github, gruvbox, pygments, tango, espresso, zenburn, kate, monochrome, breezedark, haddock, dracula, mokokai, nord, oblivion, printing, radical, solarized, vim-dark]\n\n\n\nУравнения\nВывести математические уравнения можно внутри строки с тестом или отдельным блоком\nВывод формулы $E = mc^{2}$ \\(E = mc^{2}\\) в строке текста.\nВывод формулы $$E = mc^{2}$$ отдельным блоком \\[E = mc^{2}\\]\n\n\nДиаграммы\nВ Quarto можно выводить настраиваемые диаграммы Mermaid and Graphviz\nРассмотрим примеры диаграмм выполненых в Mermaid\n\nFlowchart\nПодробная инструкция по составлению диаграммы Flowchart.\n\ngraph TD;\n    A-->B;\n    A-->C;\n    B-->D;\n    C-->D;\n\n\n\ngraph TD;\n    A-->B;\n    A-->C;\n    B-->D;\n    C-->D;\n\n\n\n\n\n\n\n\n\n\nSequence diagram\nПодробная инструкция по составлению диаграммы Sequence diagram.\n\nsequenceDiagram\n    Alice->>John: Hello John, how are you?\n    John-->>Alice: Great!\n    Alice-)John: See you later!\n\n\n\nsequenceDiagram\n    Alice->>John: Hello John, how are you?\n    John-->>Alice: Great!\n    Alice-)John: See you later!\n\n\n\n\n\n\n\n\n\n\nGantt diagram\nПодробная инструкция по составлению диаграммы Gantt diagram.\n\ngantt\n    title A Gantt Diagram\n    dateFormat  YYYY-MM-DD\n    section Section\n    A task           :a1, 2014-01-01, 30d\n    Another task     :after a1  , 20d\n    section Another\n    Task in sec      :2014-01-12  , 12d\n    another task      : 24d\n\n\n\ngantt\n    title A Gantt Diagram\n    dateFormat  YYYY-MM-DD\n    section Section\n    A task           :a1, 2014-01-01, 30d\n    Another task     :after a1  , 20d\n    section Another\n    Task in sec      :2014-01-12  , 12d\n    another task      : 24d\n\n\n\n\n\n\n\n\n\n\nClass diagram\nПодробная инструкция по составлению диаграммы Class diagram.\n\nclassDiagram\n    Animal <|-- Duck\n    Animal <|-- Fish\n    Animal <|-- Zebra\n    Animal : +int age\n    Animal : +String gender\n    Animal: +isMammal()\n    Animal: +mate()\n    class Duck{\n        +String beakColor\n        +swim()\n        +quack()\n    }\n    class Fish{\n        -int sizeInFeet\n        -canEat()\n    }\n    class Zebra{\n        +bool is_wild\n        +run()\n    }\n\n\n\nclassDiagram\n    Animal <|-- Duck\n    Animal <|-- Fish\n    Animal <|-- Zebra\n    Animal : +int age\n    Animal : +String gender\n    Animal: +isMammal()\n    Animal: +mate()\n    class Duck{\n        +String beakColor\n        +swim()\n        +quack()\n    }\n    class Fish{\n        -int sizeInFeet\n        -canEat()\n    }\n    class Zebra{\n        +bool is_wild\n        +run()\n    }\n\n\n\n\n\n\n\n\n\n\nGit graph\nПодробная инструкция по составлению диаграммы Git graph.\n\ngitGraph\n       commit\n       commit\n       branch develop\n       commit\n       commit\n       commit\n       checkout main\n       commit\n       commit\n\n\n\n    gitGraph\n       commit\n       commit\n       branch develop\n       commit\n       commit\n       commit\n       checkout main\n       commit\n       commit\n\n\n\n\n\n\n\n\n\n\nEntity Relationship Diagrams\nПодробная инструкция по составлению диаграммы Entity Relationship Diagrams.\n\nerDiagram\n    CUSTOMER ||--o{ ORDER : places\n    ORDER ||--|{ LINE-ITEM : contains\n    CUSTOMER }|..|{ DELIVERY-ADDRESS : uses\n\n\n\nerDiagram\n    CUSTOMER ||--o{ ORDER : places\n    ORDER ||--|{ LINE-ITEM : contains\n    CUSTOMER }|..|{ DELIVERY-ADDRESS : uses\n\n\n\n\n\n\n\n\n\n\nUser Journey Diagram\nПодробная инструкция по составлению диаграммы User Journey Diagram.\n\njourney\n    title My working day\n    section Go to work\n      Make tea: 5: Me\n      Go upstairs: 3: Me\n      Do work: 1: Me, Cat\n    section Go home\n      Go downstairs: 5: Me\n      Sit down: 5: Me\n\n\n\njourney\n    title My working day\n    section Go to work\n      Make tea: 5: Me\n      Go upstairs: 3: Me\n      Do work: 1: Me, Cat\n    section Go home\n      Go downstairs: 5: Me\n      Sit down: 5: Me\n\n\n\n\n\n\n\n\n\n\n\nВидео\nВ документ можно вставлять фрейм с видео роликом, например\n\n\n\nВыноски\nВыноски нужны чтобы подсветить какую-либо информацию, может быть несколько таких типов:\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, warning, important, tip, and caution.\n::: {.callout-note}\nNote that there are five types of callouts, including:\n`note`, `warning`, `important`, `tip`, and `caution`.\n:::\n\n\n\n\n\n\n\n\nTip With important\n\n\n\nThis is an example of a callout with a caption.\n::: {.callout-important}\n## Tip With Caption\n\nThis is an example of a callout with a caption.\n:::\n\n\n\n\n\n\n\n\nTip With tip\n\n\n\nThis is an example of a callout with a tip.\n::: {.callout-tip}\n## Tip With Caption\n\nThis is an example of a callout with a caption.\n:::\n\n\n\n\n\n\n\n\nExpand To Learn About Collapse\n\n\n\n\n\nThis is an example of a ‘folded’ caution callout that can be expanded by the user. You can use collapse=\"true\" to collapse it by default or collapse=\"false\" to make a collapsible callout that is expanded by default.\n::: {.callout-caution collapse=\"true\"}\n## Expand To Learn About Collapse\n\nThis is an example of a 'folded' caution callout that can be expanded by the user. You can use `collapse=\"true\"` to collapse it by default or `collapse=\"false\"` to make a collapsible callout that is expanded by default.\n:::\n\n\n\n\n\n\n\n\n\n\nTip With warning\n\n\n\nThis is an example of a callout with a warning.\n::: {.callout-warning}\n## Tip With Caption\n\nThis is an example of a callout with a caption.\n:::\n\n\n\n\nОтступления\nЧтобы делать отступления и комментарии по ходу текста, можно вставить тег .aside в фигурных скобках. This is a span that has the class aside which places it in the margin without a footnote number.\n[This is a span that has the class aside which places it in the margin without a footnote number.]{.aside}\n\n\nСноски\nСноски можно добавить в текст использовав 2 ‘[^ + цифра или слово]’\n\n\n\n\n\nFootnotes\n\n\nFigures↩︎\nа чтобы описать сноску ставим ‘[^ + цифра или слово]:’ и далее пишем текст описания↩︎\n\nCitationBibTeX citation:@online{practicesit2022,\n  author = {Best Practices IT},\n  title = {Quarto Cheat Sheet},\n  date = {2022-10-11},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nBest Practices IT. 2022. “Quarto Cheat Sheet.” October 11,\n2022."
  },
  {
    "objectID": "visualization/Diagramms/Upset/diagramm_upsetr.html",
    "href": "visualization/Diagramms/Upset/diagramm_upsetr.html",
    "title": "UpSet диаграммы - введение",
    "section": "",
    "text": "Понимание взаимосвязей между атрибутами изучаемого набора данных является важной задачей анализа. Основной проблемой в этом контексте является комбинаторный взрыв числа пересечений множеств, если количество множеств превышает тривиальный порог. Наиболее распространенный подход к визуализации наборов – Диаграммы Венна - не масштабируется дальше трех или четырех наборов.\nГрафики UpSet дают возможность проводить анализ взаимосвязей гораздо большего числа атрибутов.\n\n\nUpSet лучше всего работает для наборов данных, содержащих более трех и менее 30 наборов. Для менее чем 4 наборов лучшим выбором может быть пропорциональная площади диаграмма Венна, поскольку они более привычны пользователям.\nUpSet хорошо подходит для анализа распределений и свойств многих элементов. Элементы абстрагируются как “count”, хотя атрибуты элементов могут быть визуализированы в виде интегрированных или смежных графиков.\nкогда вы хотите посмотреть на все комбинации пересечений множеств. Если вы хотите посмотреть на попарные пересечения между наборами, лучшим выбором может быть какая-то матрица комбинаций.\n\nUpSet отображает пересечения множества в виде матрицы, как показано на следующем рисунке. Каждый столбец соответствует набору, а столбчатые диаграммы сверху показывают размер набора. Каждая строка соответствует возможному пересечению: заполненные ячейки показывают, какой набор является частью пересечения. Также обратите внимание на линии, соединяющие заполненные ячейки: они показывают, в каком направлении вы должны читать график:\n\n\nFigure 1: Чтение графика\n\n\nРассмотрим как эти пересечения соответствуют сегментам на диаграмме Венна.\n\nПервая строка на рисунке полностью пуста – соответствует всем элементам, которые не входят ни в один из наборов.\nЗеленая (третья) строка соответствует элементам, которые находятся только в наборе B (не в A или C).\nОранжевая (пятая) строка представляет элементы, которые являются общими для наборов A и B, но не для C.\nНаконец, последняя (фиолетовая) строка представляет элементы, общие для всех наборов.\n\n\n\nFigure 2: Сопоставление с диаграммой Венна\n\n\nЭтот график хорош тем, что мы можем отобразить размер пересечений (“мощность”) в виде гистограмм прямо рядом с матрицей, как вы можете видеть в следующем примере:\n\n\nFigure 3: Гистограмма мощности на графике UpSet\n\n\nТакое представление мощнойстей делает более понятным сравнение размеров пересечений.\nМатрица также очень полезна, потому что ее можно сортировать различными способами. Обычным способом является сортировка по мощности (размеру), как показано на следующем рисунке, но также возможны и другие виды сортировки.\n\n\nFigure 4: Пример сортировки по мощности\n\n\nНаконец, UpSet одинаково хорошо работает как по горизонтали, так и по вертикали. Вертикальные графики лучше подходят для интерактивных графиков, которые можно прокручивать, в то время как горизонтальные графики лучше всего подходят для статичного представления.\n\n\nFigure 5: Горизонтальный график UpSet\n\n\nМы уже частично коснулись матрицы в которая содержит комбинации атрибутов, теперь рассмотрим её подробнее."
  },
  {
    "objectID": "visualization/Diagramms/Upset/diagramm_upsetr.html#комбинационная-матрица",
    "href": "visualization/Diagramms/Upset/diagramm_upsetr.html#комбинационная-матрица",
    "title": "UpSet диаграммы - введение",
    "section": "Комбинационная матрица",
    "text": "Комбинационная матрица\nГрафик UpSet строится на комбинациях пересечений атрибутов набора данных. Атрибуты должны иметь значения (0, 1) или (TRUE, FALSE). Совокупность таких атрибутов называется комбинационной матрицей или матрицей комбинаций, рассмотрим её создание на примере пакета ComplexHeatmap.\nМатрицу комбинаций можно составить из:\n\nсписка, содержащего несколько векторов\nдвоичной матрицы или фрейма данных, где строки являются элементами, а столбцы - наборами\nесли переменная является фреймом данных, сохраняются только двоичные столбцы (содержащие только 0 и 1) и логические столбцы.\n\nДля простоты создадим список содержащий два вектора разных размеров и преобразуем его к матрице, чтобы посмотреть полученные комбинации\n\nls <- list(set1 = c(\"a\", \"b\", \"c\"), set2 = c(\"b\", \"c\", \"d\", \"e\"))\nlist_to_matrix(ls)\n\n  set1 set2\na    1    0\nb    1    1\nc    1    1\nd    0    1\ne    0    1\n\n\nВ полученной матрице наборы set1 (размер вектора 3 элемента) и set2 (размер вектора 4 элемента) образуют 5 комбинаций, давайте их перечислим\n\n\na - есть только в наборе set1\n\nb - есть в обоих наборах\n\nc - есть в обоих наборах\n\nd - есть только в наборе set2\n\ne - есть только в наборе set2\n\nИтого:\n\nкомбинаций, которые есть только в наборе set1 - 1 шт\nкомбинаций, которые есть в наборе set1 и set2 - 2 шт\nкомбинаций, которые есть только в наборе set2 - 2 шт\n\nНа графике это количество комбинаций или пересечений отображается как Intersection size, а длины векторов или наборы в матрице как Set size.\n\n\n\n\nFigure 6: Сопоставление комбинационной матрицы с графиком\n\n\n\n\nТеперь создадим матрицу комбинаций функцией make_comb_mat.\nУ функции make_comb_mat есть три режима работы:\n\n\ndistinct (по умолчанию)\nintersect\nunion mode\n\nКак режимы влияют на пересечение наборов показано на рисунке ниже, а влияние на графиках разберем ниже.\n\n\nFigure 7: Режимы комбинационной матрицы\n\n\nСоздадим матрицу комбинаций\n\n# задание режимов расчета размеров набора\nmx <- make_comb_mat(ls)\n\nm2 = make_comb_mat(ls, mode = \"intersect\")\nm3 = make_comb_mat(ls, mode = \"union\")\n\n# Когда наборов слишком много, наборы могут быть предварительно отфильтрованы по заданным размерам.\n# Фильтрация по размеру наборов\n# min_set_size - Минимальный размер набора, который используется для генерации комбинированной матрицы\nm1 = make_comb_mat(ls, min_set_size = 4)\n# top_n_sets - Количество наборов с наибольшими размерами, которые используется для генерации комбинированной матрицы\nm2 = make_comb_mat(ls, top_n_sets = 1) \n\nДальше с этой матрицей будем работать черех пакет ComplexHeatmap."
  },
  {
    "objectID": "visualization/Diagramms/Upset/diagramm_upsetr.html#реализация-графиков-upset",
    "href": "visualization/Diagramms/Upset/diagramm_upsetr.html#реализация-графиков-upset",
    "title": "UpSet диаграммы - введение",
    "section": "Реализация графиков UpSet",
    "text": "Реализация графиков UpSet\nСоздать графики можно на различных языках программирования, мы рассмотрим R и Python в дальнейших статьях.\nЭти графики в языке R реализованы в трех пакетах:\n\nUpSetR\nComplexHeatmap\nComplexUpset\n\nНе нужно совместно инициализировать пакеты UpSetR и ComplexUpset, их методы пересекаются и привызове функции upset пакета UpSetR возникает ошибка: unused argument\nА в Python в двух библиотеках:\n\nUpSetPlot\npyUpSet\n\nПримеры графиков UpSet\n\n\n\n\n\n\nГоризонтальный график с метками данных\n\n\n\n\n\n\nГоризонтальный график с дополнительными диаграммами\n\n\n\n\n\n\n\n\nГоризонтальный график с несколькими дополнительными вертикальными диаграммами\n\n\n\n\nFigure 8: Примеры UpSet графиков\n\n\n\nReferences"
  },
  {
    "objectID": "visualization/Diagramms/Upset/diagramm_upsetr.html#используемые-источники",
    "href": "visualization/Diagramms/Upset/diagramm_upsetr.html#используемые-источники",
    "title": "UpSet диаграммы - введение",
    "section": "Используемые источники:",
    "text": "Используемые источники:\n\nhttps://upset.app/\nhttps://jokergoo.github.io/ComplexHeatmap-reference/book/upset-plot.html"
  },
  {
    "objectID": "visualization/Diagramms/Upset/packege_upsetr.html",
    "href": "visualization/Diagramms/Upset/packege_upsetr.html",
    "title": "Создание графиков в пакете UpSetR",
    "section": "",
    "text": "Создание графиков UpSet в пакете UpSetR процесс достаточно простой и интуитивно понятный, пакет поможет создавать качественные и красивые визуализации для полного и глубокого анализа данных. \n\nЗагрузим набор данных предоставляемый этим пакетом. Для построения графика будем использовать функцию upset, подробнее об этой функции в ?upset\n\nmovies <- read.csv(system.file(\"extdata\", \"movies.csv\", package = \"UpSetR\"), \n    header = T, sep = \";\")\n\nВыберем 6 наибольших наборов.\n\nupset(movies, nsets = 6, number.angles = 0, point.size = 3.5, line.size = 2, \n    mainbar.y.label = \"Genre Intersections\", sets.x.label = \"Movies Per Genre\", \n    text.scale = c(1.3, 1.3, 1, 1, 2, 0.75))\n\n\n\nFigure 1: На оси Movies Per Genre показано количество фильмов каждого жанра. На оси Genre Intersections количество фильмов в разрезе пересечений с другими жанрами. Видно, что наибольшее количество набирается когда пересечений с другими жанрами нет либо оно минимальное, а самые популярные жанры: Драма, Комедия и Ужасы\n\n\n\n\n\n\nmb.ratio = c(0.75, 0.25) - через этот параметр задаем соотношение между столбчатой диаграммой и диаграммой пересечений. Сумма коэффициентов должна равняться единице.\n\n```{r}\nupset(movies, sets = c(\"Action\", \"Adventure\", \"Comedy\", \"Drama\", \"Mystery\", \n    \"Thriller\", \"Romance\", \"War\", \"Western\"), mb.ratio = c(0.75, 0.25), order.by = \"degree\")\n\nupset(movies, sets = c(\"Action\", \"Adventure\", \"Comedy\", \"Drama\", \"Mystery\", \n    \"Thriller\", \"Romance\", \"War\", \"Western\"), mb.ratio = c(0.55, 0.45), order.by = c(\"degree\", \"freq\"))\n```\n\n\n\n\n\n(a) First\n\n\n\n\n\n\n(b) Second\n\n\n\n\nFigure 2: В обоих графиках задаем список наборов, соотношения между столбчатой диаграммой и диаграммой пересечений поставили разные. В первом графике сортировка задана по возрастанию наборов, а во втором графике по частоте\n\n\n\n\nkeep.order - при значении TRUE упорядочивает наборы в том порядке в котором они записаны в sets при значении FALSE по их размеру\n\n\nupset(movies, sets = c(\"Action\", \"Adventure\", \"Comedy\", \"Drama\", \"Mystery\", \n    \"Thriller\", \"Romance\", \"War\", \"Western\"), mb.ratio = c(0.55, 0.45), order.by = \"freq\", \n    keep.order = TRUE)\n\n\n\nFigure 3: Наборы на графике отсортированны согласно заданному нами списку, а размеры пересечений по убыванию.\n\n\n\n\n\n\nnintersects - количество пересечений выведенных на график, по умолчанию выводятся все пересечения group.by - способ группировки по наборам или по количеству пересечений наборов cutoff - Количество пересечений из каждого набора (для отсечения) при агрегировании по наборам\n\n\nupset(movies, nintersects = 70, group.by = \"sets\", cutoff = 7)\n\n\n\nFigure 4: На графике видим размер пересечений сгруппированые по жанрам, в каждой группе не более 7 значений. Так пересекающихся жанров несколько , то значения в нескольких пересекающихся друг с другом жанрах будут повторяться.\n\n\n\n\n\n\nempty.intersections = “on” - свойство позволяет дополнительно отображать пустые пересечения\n\n\nupset(movies, empty.intersections = \"on\", order.by = \"freq\")\n\n\n\nFigure 5: Видно, что на графике появились пустые пересечения т.е. размер которых равен нулю.\n\n\n\n\n\n\n\n\nС помощью атрибутов можно выводить дополнительные диаграммы на график.\nПараметр attribute.plots содержит три поля: gridrows, plots, and ncols\n\n\ngridrows указывает на сколько нужно увеличить высоту окна графика чтобы добавить место под диаграммы атрибутов. График UpSetR отрисовывается на сетка размером 100 х 100. Например если установить парамерт gridrows = 50, то размер новой сетки окна будет 150 х 100.\n\nplots также содержит список параметров, в нем задаются plot, x, y и queries.\n\nplot функция возвращающая ggplot\n\nx задает параметр к оси X\n\ny задает параметр к оси Y\n\nqueries: указывает необходимо ли применять к графиком атрибутов результаты параметра queries функции upset. Если значение True, то к графику будет применен параметр queries, если False, то нет. Сам же параметр queries имеет атрибут query который определяет какая функция будет применена к графику, например intersects или самописная функция.\n\nncols указывает, как должны быть расположены графики в пространстве строк сетки. Если введены два графика атрибутов и значение ncols равно 1, то графики будут отображаться один над другим. В качестве альтернативы, если введены два графика атрибутов и значение ncols равно 2, графики атрибутов будут отображаться рядом. \n\n\n\nupset(movies, main.bar.color = \"black\", queries = list(list(query = intersects, \n    params = list(\"Drama\"), active = T)), \n    attribute.plots = list(gridrows = 50, \n                           plots = list(\n                             list(plot = histogram, x = \"ReleaseDate\", queries = F), \n                             list(plot = histogram, x = \"AvgRating\", queries = T)), \n                           ncols = 2)\n    )\n\n\n\nFigure 6: На графике выделенно синим цветом пересечение по жанру драма. В дополнительной диаграмме среднего рейтинга фильмов выделена доля фильмов жанра драма. И на левом дополнительном графике показана частота выхода фильмов в зависимости от года\n\n\n\n\n\nВ этом коде задаем форматирование для пересечений нужным цветом. Потом в дополнительных диаграммах атрибутов определяем использовать это форматирование или нет.\n\nupset(movies, main.bar.color = \"black\", \n      queries = list(\n        list(query = intersects, params = list(\"Drama\"), color = \"red\", active = F), \n        list(query = intersects, params = list(\"Action\", \"Drama\"), active = T), \n        list(query = intersects, params = list(\"Drama\", \"Comedy\", \"Action\"), color = \"orange\", active = T)\n        ),\n      attribute.plots = list(gridrows = 45, \n                             plots = list(list(plot = scatter_plot, x = \"ReleaseDate\", y = \"AvgRating\", queries = T),\n                                          list(plot = scatter_plot, x = \"AvgRating\", y = \"Watches\", queries = F)\n                                          ), \n                             ncols = 2), query.legend = \"bottom\")\n\n\n\nFigure 7: На графике выделили три типа пересечений и спроецировали их на одну дополнительную диаграмму. На первой доп диаграмме показана зависимость среднего рейтинга от даты выхода фильма, а также какую часть в нем занимают интересующие нас пересечения. На второй доп диаграмме зависимость просмотров от среднего рейтинга, логично, что чем выше рейтинг тем выше количество просмотров\n\n\n\n\n\nЗдесь вместо одной из точечных диаграмм, добавляем диаграмму постороенную по пользовательской функцие.\n\nmyplot <- function(mydata, x, y) {\n    plot <- (ggplot(data = mydata, aes_string(x = x, y = y, colour = \"color\")) + \n        geom_point() + scale_color_identity() + theme(plot.margin = unit(c(0, 0, 0, 0), \"cm\")))\n}\n\nanother.plot <- function(data, x, y) {\n    data$decades <- round_any(as.integer(unlist(data[y])), 10, ceiling)\n    data <- data[which(data$decades >= 1970), ]\n    myplot <- (ggplot(data, aes_string(x = x)) + geom_density(aes(fill = factor(decades)), \n        alpha = 0.4) + theme(plot.margin = unit(c(0, 0, 0, 0), \"cm\"), legend.key.size = unit(0.4, \n        \"cm\")))\n}\n\nupset(movies, main.bar.color = \"black\", \n      queries = list(list(query = intersects, params = list(\"Drama\"), color = \"red\", active = F), \n                     list(query = intersects, params = list(\"Action\", \"Drama\"), active = T), \n                     list(query = intersects, params = list(\"Drama\", \"Comedy\", \"Action\"), color = \"orange\", active = T)), \n                attribute.plots = list(gridrows = 45, \n                                       plots = list(\n                                         list(plot = myplot, x = \"ReleaseDate\", y = \"AvgRating\", queries = T), \n                                         list(plot = another.plot, x = \"AvgRating\", y = \"ReleaseDate\", queries = F)), \n                                       ncols = 2))\n\n\n\nFigure 8: На график добавили диаграмму постороенную по своей функции. Она отображает средний рейтинг фильмов в зависимости от даты выхода в разрезе десятилетий\n\n\n\n\nОбъединение встроенного точечного графика и графика гистограммы с пользовательским графиком myplot, определенным в приведенном выше примере.\n\nupset(movies, main.bar.color = \"black\", mb.ratio = c(0.5, 0.5), \n      queries = list(list(query = intersects, params = list(\"Drama\"), color = \"red\", active = F), \n                     list(query = intersects, params = list(\"Action\", \"Drama\"), active = T), \n                     list(query = intersects, params = list(\"Drama\", \"Comedy\", \"Action\"), color = \"orange\", active = T)), \n    attribute.plots = list(gridrows = 50, \n                           plots = list(\n                             list(plot = histogram,x = \"ReleaseDate\", queries = F), \n                             list(plot = scatter_plot, x = \"ReleaseDate\", y = \"AvgRating\", queries = T), \n                             list(plot = myplot, x = \"AvgRating\", y = \"Watches\", queries = F)), \n                           ncols = 3))\n\n\n\nFigure 9: На этом графике добавлены дополнительные диаграммы. Теперь можно анализировать данные с нескольких сторон: частоты выхода фильмов и среднего рейтинга в зависимости от даты выхода, а также количество просмотров от серднего рейтинга фильмов\n\n\n\n\n\nboxplot, показывает распределение атрибута по всем пересечениям. Может отображать одновременно не более двух сводок графиков. Параметр boxplot.summary принимает вектор из одного или двух имен атрибутов.\n\nupset(movies, boxplot.summary = c(\"AvgRating\", \"ReleaseDate\"))\n\n\n\nFigure 10: Под каждым столбцом с пересечениями находится свой элемент диаграммы ящик с усами, он показывает распределение значений по диапозону. Например для фильмо с жанров драма видим, что медиана среднего рейтинга находится между 3 и 4, а медиана даты выхода ближе к 2000 году\n\n\n\n\n\nРазберем параметр query, он часто использовался на предыдущих диаграммах, пора его подробно описать.\n\n\nquery указывает, какой запрос будет выполняться\n\nparams это список параметров, с которыми будет работать запрос\n\ncolor это цвет, который будет представлять запрос на графике. Если цвет не указан, будет выбран цвет из палитры цветов по умолчанию.\n\nactive определяет, как запрос будет представлен на графике. Если значение active равно TRUE, строка размера пересечения будет перекрыта строкой, представляющей запрос. Если значение active равно FALSE, на панели размера пересечения будет размещена точка дрожания.\n\nВ этом примере показано, как использовать встроенный запрос пересечений intersects для поиска или отображения элементов в определенных пересечениях. В этом примере цвет, выбранный для активного запроса, выбран из цветовой палитры по умолчанию.\n\nupset(movies, \n      queries = list(list(query = intersects, params = list(\"Drama\",\"Comedy\", \"Action\"), color = \"orange\", active = T), \n                     list(query = intersects, params = list(\"Drama\"), color = \"red\", active = F), \n                     list(query = intersects, params = list(\"Action\", \"Drama\"), active = T)))\n\n\n\nFigure 11: с помощью запросов подсветили интересующие нас пересечения, где они активированы там цветом выделены столбец гистограммы и столбец на графике пересечений наборов, а где запрос не активирован, то там галочкой показана величина пересечения.\n\n\n\n\n\nЕсли необходимо визуализировать как конкретные значения атрибутов распределяются между пересечениями, то тогда можно использовать запрос элемента elements.\n\nupset(movies, \n      queries = list(list(query = elements, params = list(\"AvgRating\", 3.5, 4.1), color = \"blue\", active = T), \n                     list(query = elements, params = list(\"ReleaseDate\", 1980, 1990, 2000), color = \"red\", active = F)))\n\n\n\nFigure 12: в гистограме пересечений подсветили интересующие нас конкретные значения среднего рейтинга синим цветом и даты выхода фильмов красным цветом\n\n\n\n\n\nВ этом примере показано, как использовать параметр expression для фильтрации подмножества результатов запросов элементов и пересечений.\n\nupset(movies, \n      queries = list(\n        list(query = intersects, params = list(\"Action\", \"Drama\"), active = T), \n        list(query = elements, params = list(\"ReleaseDate\", 1980, 1990, 2000), color = \"red\", active = F)\n        ), \n      expression = \"AvgRating > 3 & Watches > 100\")\n\n\n\nFigure 13: Отфильтровали график по условиям средний рейтинг > 3 и количество просмотров > 100. Далее выделили пересечение жанров экшен и драмы. А также красным цветом показали содержащееся в пересечениях количество фильмов с датами выхода 1980, 1990 и 2000\n\n\n\n\n\n\nMyfunc <- function(row, release, rating) {\n    data <- (row[\"ReleaseDate\"] %in% release) & (row[\"AvgRating\"] > rating)\n}\n\nupset(movies, \n      queries = list(list(query = Myfunc, params = list(c(1970, 1980, 1990, 1999, 2000), 2.5), \n                          color = \"blue\", active = T))\n      )\n\n\n\nFigure 14: На графике подсвечиваем с помощью написанной функции количество фильмов с заданой датой выхода и выше нужного нам рейтинга\n\n\n\n\n\nЧтобы добавить условные обозначения для примененных запросов, можно использовать параметр query.legend. Параметр query.legend задает положение, в котором должна отображаться легенда, либо сверху, либо снизу. Чтобы применить определенное имя к каждому запросу, параметр query.name может использоваться при определении запроса в параметре запросов. Если query.name не задан, то будет использоваться общее название. В приведенном ниже примере показано, как это сделать.\n\nupset(movies, \n      query.legend = \"top\", \n      queries = list(\n        list(query = intersects, params = list(\"Drama\", \"Comedy\", \"Action\"), color = \"orange\", active = T,\n             query.name = \"Funny action\"), \n        list(query = intersects, params = list(\"Drama\"), color = \"red\", active = F), \n        list(query = intersects, params = list(\"Action\", \"Drama\"), active = T, \n             query.name = \"Emotional action\"))\n      )\n\n\n\nFigure 15: График с легендой\n\n\n\n\nОбъединим примененные выше методы\n\nupset(movies, \n      query.legend = \"bottom\", \n      queries = list(\n        list(query = Myfunc, params = list(c(1970, 1980, 1990, 1999, 2000), 2.5), color = \"orange\", active = T), \n        list(query = intersects, params = list(\"Action\", \"Drama\"), active = F), \n        list(query = elements, params = list(\"ReleaseDate\", 1980, 1990, 2000), color = \"red\", active = F,\n             query.name = \"Decades\")), \n      expression = \"AvgRating > 3 & Watches > 100\")\n\n\n\nFigure 16: График с пользовательскими наборами\n\n\n\n\n\nДобавление метаданных задается параметром: set.metadata\nРазберем атрибуты этого параметра:\n\ndata: принимает фрейм данных, где первый столбец - это имена наборов, а следующие столбцы - атрибуты наборов.\nplots: это список, который принимает список параметров, используемых для создания графиков. Эти параметры включают столбец, тип, назначение и цвета.\ncolumn: столбец используемого набора данныхЮ по которому будет строиться график\ntype: это то, какой тип графика следует использовать для отображения данных из указанного столбца. Если данные в столбце числовые, то тип графика может быть либо гистограммой (“hist”), либо тепловой картой (“heat”). Если данные в столбце являются логическими, то типом графика может быть тепловая карта “bool”. Если данные в столбце являются категориальными (символьными), то тип графика может быть либо тепловой картой (“тепло”), либо текстом (“текст”). Кроме того, если данные в столбце порядковые (коэффициентные), то тип графика может быть либо тепловой картой, либо текстом. Существует также тип под названием “matrix_rows”, который позволяет нам использовать применение цветов к фону матрицы с использованием категориальных данных. Этот тип полезен для определения характеристик наборов с использованием матрицы.\nassign: это количество столбцов, которые должны быть назначены конкретному графику. Например, если вы строите 2 набора графиков метаданных, то вы можете выбрать один график, который будет занимать 20 столбцов, а другой - 10 столбцов. Поскольку график смещения обычно наносится на сетку размером 100 на 100, сетка теперь будет иметь размер 100 на 130, где примерно 1/4 участка отводится графикам метаданных.\n\ncolors: используется для указания цветов, используемых в графиках метаданных. Если тип графика - линейчатый график, то параметр принимает только один цвет для всего графика. Если тип графика “heat” или “bool”, то может быть предоставлен вектор цветов, в котором для каждой уникальной категории (символа) есть один цвет. Однако, если тип данных порядковый (фактор), ввод цветов отсутствует, и тепловая карта работает с цветовым градиентом, а не применяет разные цвета к каждому уровню. Наконец, если тип графика - “текст”, то может быть предоставлен вектор цветов, где для каждой уникальной строки есть один цвет. Если цвета не указаны, вам будет предоставлена цветовая палитра.\nВ этом примере в качестве метаданных набора будут использоваться средние рейтинги фильмов Rotten Tomatoes для каждого набора. Это может помочь нам сделать больше выводов из визуализации, зная, как профессиональные рецензенты обычно оценивают фильмы в этих категориях.\n\n\n\nsets <- names(movies[3:19])\navgRottenTomatoesScore <- round(runif(17, min = 0, max = 90))\nmetadata <- as.data.frame(cbind(sets, avgRottenTomatoesScore))\nnames(metadata) <- c(\"sets\", \"avgRottenTomatoesScore\")\n\n# При создании гистограммы с использованием информации метаданных набора важно убедиться, что указанный столбец является числовым.\n# is.numeric(metadata$avgRottenTomatoesScore)\n\n# Столбец не является числовым! На самом деле это фактор, поэтому мы должны преобразовать его в символы, а затем в целые числа.\nmetadata$avgRottenTomatoesScore <- as.numeric(as.character(metadata$avgRottenTomatoesScore))\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"hist\", column = \"avgRottenTomatoesScore\", assign = 20)))\n      )\n\n\n\nFigure 17: График с добавлением метаданных\n\n\n\n\n\nВ этом примере мы составим наши собственные данные о том, в каких крупных городах эти жанры были наиболее популярны. Поскольку это категориальный, а не порядковый номер, мы должны не забыть изменить столбец на символы (это снова фактор). Чтобы убедиться, что мы назначаем определенные цвета каждой категории, вы можете указать название каждой категории в цветовом векторе, как показано ниже. Если вам все равно, какой цвет присвоен каждой категории, то вам не нужно указывать названия категорий в цветовом векторе. R просто применит цвета к каждой категории в том порядке, в котором они встречаются. Кроме того, если вы ничего не укажете для параметра colors, вам будет предоставлена цветовая палитра по умолчанию.\n\nCities <- sample(c(\"Boston\", \"NYC\", \"LA\"), 17, replace = T)\nmetadata <- cbind(metadata, Cities)\nmetadata$Cities <- as.character(metadata$Cities)\n# metadata[which(metadata$sets %in% c(\"Drama\", \"Comedy\", \"Action\", \"Thriller\", \"Romance\")), ]\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"heat\", column = \"Cities\", assign = 10, \n             colors = c(Boston = \"green\", NYC = \"navy\", LA = \"purple\"))))\n      )\n\n\n\nFigure 18: График с добавлением тепловой карты\n\n\n\n\nТеперь давайте также использовать наши числовые значения критики!\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"heat\", column = \"Cities\", assign = 10, \n             colors = c(Boston = \"green\", NYC = \"navy\", LA = \"purple\")), \n        list(type = \"heat\", column = \"avgRottenTomatoesScore\", assign = 10)))\n      )\n\n\n\nFigure 19: График с несколькими тепловыми картами\n\n\n\n\n\nТеперь предположим, что у нас есть метаданные, которые сообщают нам, хорошо ли эти жанры приняты за рубежом. Это может быть использовано в качестве категориального столбца, где есть только две категории, но для этого примера мы предположим, что ваши данные закодированы в 1 и 0. Важно иметь в виду, что если вы запустите “heat” с 0 и 1 вместо “bool”, двоичные данные будут обрабатываться как числовые значения, а цветовой градиент будет использоваться для отображения относительных различий.\n\naccepted <- round(runif(17, min = 0, max = 1))\nmetadata <- cbind(metadata, accepted)\n# metadata[which(metadata$sets %in% c(\"Drama\", \"Comedy\", \"Action\", \"Thriller\", \"Romance\")), ]\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"bool\", column = \"accepted\", assign = 5, colors = c(\"#FF3333\", \"#006400\"))))\n      )\n\n\n\nFigure 20: График с логической тепловой картой\n\n\n\n\nДавайте посмотрим, что произойдет, когда мы выберем “heat” вместо “bool” для нашего столбца двоичных данных.\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"heat\", column = \"accepted\", assign = 5, colors = c(\"red\", \"green\"))))\n      )\n\n\n\nFigure 21: График с тепловой картой\n\n\n\n\nДопустим, мы предпочитаем показывать текст вместо тепловой карты для городов, в которых эти жанры были наиболее популярны.\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"text\", column = \"Cities\", assign = 10, \n             colors = c(Boston = \"green\", NYC = \"navy\", LA = \"purple\"))))\n      )\n\n\n\nFigure 22: График с тепловой картой в виде текста\n\n\n\n\n\nВ некоторых случаях мы можем просто захотеть включить метаданные категориального набора непосредственно в график расслоения, чтобы легко идентифицировать характеристики наборов с помощью матрицы. Для этого нам нужно указать тип как matrix_rows, какой столбец мы используем для категоризации наборов, и цвета, которые будут применяться к каждой категории. Существует также возможность изменить непрозрачность фона матрицы с помощью альфа-кода. Чтобы изменить непрозрачность фона матрицы без применения заданных метаданных, см. параметр shade.alpha в документации к функции disapport().\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"hist\", column = \"avgRottenTomatoesScore\", assign = 20), \n        list(type = \"matrix_rows\", column = \"Cities\", \n             colors = c(Boston = \"green\", NYC = \"navy\", LA = \"purple\"), \n    alpha = 0.5)))\n    )\n\n\n\nFigure 23: Окрашивание пересечений по значениям категорий\n\n\n\n\nОбъединим методы рассмотренные выше на одном графике\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"hist\", column = \"avgRottenTomatoesScore\", assign = 20), \n        list(type = \"bool\", column = \"accepted\", assign = 5, colors = c(\"#FF3333\", \"#006400\")), \n        list(type = \"text\", column = \"Cities\", assign = 5, \n             colors = c(Boston = \"green\", NYC = \"navy\", LA = \"purple\"))))\n      )\n\n\n\nFigure 24: График с совмещенными методами метаданных\n\n\n\n\nА теперь соединим методы добавления метаданных, атрибутов и запросов\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"hist\", column = \"avgRottenTomatoesScore\", assign = 20), \n        list(type = \"bool\", column = \"accepted\", assign = 5, colors = c(\"#FF3333\", \"#006400\")), \n        list(type = \"text\", column = \"Cities\",   assign = 5, colors = c(Boston = \"green\", NYC = \"navy\", LA = \"purple\")), \n        list(type = \"matrix_rows\", column = \"Cities\", colors = c(Boston = \"green\", NYC = \"navy\", LA = \"purple\"), \n             alpha = 0.5))), \n      queries = list(list(query = intersects, params = list(\"Drama\"), color = \"red\", active = F), \n                     list(query = intersects, params = list(\"Action\", \"Drama\"), active = T), \n                     list(query = intersects, params = list(\"Drama\", \"Comedy\", \"Action\"), \n                          color = \"orange\", active = T)), \n      attribute.plots = list(gridrows = 45, plots = list(\n        list(plot = scatter_plot, x = \"ReleaseDate\", y = \"AvgRating\", queries = T), \n        list(plot = scatter_plot, x = \"AvgRating\", y = \"Watches\", queries = F)), ncols = 2), \n      query.legend = \"bottom\")\n\n\n\nFigure 25: методы добавления метаданных, атрибутов и запросов на одном графике"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#tidy-select",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#tidy-select",
    "title": "Dplyr cheat sheet",
    "section": "tidy-select",
    "text": "tidy-select\nПакет tidyselect - это серверная часть таких функций, как dplyr::select() или dplyr::pull(), а также нескольких глаголов tidyr. Это позволяет создавать глаголы выбора, которые совместимы с другими пакетами tidyverse.\nКонечно логичнее было разместить раздел tidyselect в части выборки данных -> Столбцы, но tidyselect имеет гораздо большее значение и может применяться не только в select.\ntidyselect поддерживает базовые функции R по выборке:\n\n\n: для выбора диапазона последовательных переменных.\n\n! для получения дополнения к набору переменных.\n\n& и | для выбора пересечения или объединения двух наборов переменных.\n\nc() для объединения выделений.\n\nТакже можно использовать функции помощи в выборке, для конкретных столбцов\n\n\neverything() - выбирает все столбцы, обычно применяется с другими операторами tidyselect\n\nlast_col() - выбирает последнюю переменную\n\nДля выборки столбцов сопоставляя шаблоны в их именах:\n\n\nstarts_with: название столбца начинается с точного префикса\n\n\nends_with: название столбца заканчивается на точный суффикс\n\n\ncontains: название столбца содержит символ\n\n\nmatches: название столбца соответствует регулярному выражению\n\n\nnum_range: поиск занумерованных столбцов, например, «V1, V2, V3…»\n\n\nall_of() : точный поиск по значениям, проверяет наличие значений\n\n\nany_of() : поиск без проверки наличия значений, используется, чтобы убедиться, что столбец удален\n\n\none_of: название столбца соответствует одному из вариантов\n\n\nwhere() : условие функции должно быть True\n\n\nСделать строки с блоками кода на подобии тех, что использую в соединениях и наглядно показать как работают и чем отличаются функции помощи\nРассмотрим подробнее функции помощи\nФункции выбора\neverything\neverything(vars = NULL) - выбирает все столбцы, обычно применяется с другими операторами tidyselect\nvars - Символьный вектор имен переменных. Если не указано, переменные берутся из текущего контекста выбора (как установлено такими функциями, как select() или pivot_longer()).\n\nstarwars %>% \n  select(everything())\n\n\n\n  \n\n\n\nlast_col\nlast_col(offset = 0L, vars = NULL) - выбирает последнюю переменную\noffset - устанавливает какое количество столбцов с конца нужно пропустить\n\n\n\nstarwars %>% \n  select(1:last_col(9))\n\n\n\n  \n\n\n\n\nstarwars %>% \n  select(last_col(9))\n\n\n\n  \n\n\n\n\n\nФункции поиска по шаблону\nАргументы функций поиска по шаблону:\n\n\nmatch - Вектор символов. Если длина > 1, берется объединение совпадений. Для starts_with(), ends_with() и contains() это точное совпадение. Для matches() это регулярное выражение и может быть шаблоном stringr.\n\nignore.case - Если значение по умолчанию равно TRUE, регистр игнорируется при сопоставлении имен\n\nvars - Символьный вектор имен переменных. Если не указано, переменные берутся из текущего контекста выбора (как установлено такими функциями, как select() или pivot_longer()).\n\nprefix, suffix - Префикс/суффикс, добавленный до/после числового диапазона\n\nrange - Последовательность целых чисел, например 1:5\n\nwidth - Необязательный аргумент, “ширина” числового диапазона. Например, диапазон из 2 дает “01”, диапазон из трех “001” и т.д\n\nstarts_with\nstarts_with() - отбирает те столбцы название которых начинается с точного префикса\nstarts_with(match, ignore.case = TRUE, vars = NULL)\nВ функции starts_with() есть возможность задать мульти префикс, в этом случае порядок столбцов будет зависеть от порядка указания префиксов.\n\n\n\n# отберем столбцы, название которых начинается на символ «h».\nstarwars %>% \n  select(starts_with(\"h\"))\n\n\n\n  \n\n\n\n\n# отберем столбцы, название которых начинается на символы \"b\" и «h».\nstarwars %>% \n  select(starts_with(c(\"b\", \"h\")))\n\n\n\n  \n\n\n\n\n\nends_with\nends_with(match, ignore.case = TRUE, vars = NULL) - отбирает те столбцы название которых заканчивается на точный суффикс\nВ функции ends_with() есть возможность задать мульти суффикс, в этом случае порядок столбцов будет зависеть от порядка указания суффиксов.\n\n\n\n# отберем столбцы, название которых заканчивается на слово «color».\nstarwars %>% \n  select(ends_with(\"color\"))\n\n\n\n  \n\n\n\n\n# отберем столбцы, название которых заканчивается на слова \"year\" и «color».\nstarwars %>% \n  select(ends_with(c(\"year\", \"color\")))\n\n\n\n  \n\n\n\n\n\ncontains\ncontains(match, ignore.case = TRUE, vars = NULL) - отбирает те столбцы название которых содержит в названии символ/ы\nВ функции contains() есть возможность задать несколько символьных шаблонов, в этом случае порядок столбцов будет зависеть от порядка указания символов.\n\n\n\n# отберем столбцы, название которых содержит букву «а».\nstarwars %>% \n  select(contains('a'))\n\n\n\n  \n\n\n\n\n# отберем столбцы, название которых содержит буквы «m» и \"f\".\nstarwars %>% \n  select(contains(c('m', 'f')))\n\n\n\n  \n\n\n\n\n\nmatches\nФункции starts_with(), ends_with() и contains() не используют регулярные выражения. Для выбора с помощью регулярного выражения нужно использовать matches()\nmatches(match, ignore.case = TRUE, perl = FALSE, vars = NULL) - отбирает те столбцы название которых соответствует регулярному выражению\n\n# отберем столбцы, название которых соответствует регулярному выражению\nstarwars %>% \n  select(matches('[rne]_color'))\n\n\n\n  \n\n\n\nnum_range\nnum_range(prefix, range, suffix = \"\", width = NULL, vars = NULL) - отбирает те столбцы название которых соответствует префиксу и числовому диапозону\nФункции starts_with() и num_range() похожи, только первая ищет по префиксу, то num_range() отбирает по числовому диапозону внутри этого префикса.\nСравним эти функции на фрейме данных billboard, который содержит столбцы одиннаковым префиксом + номер столбца\n\n\n\n# отбираем столбцы с префиксом \"wk\"\nbillboard %>% \n  select(starts_with(\"wk\"))\n\n\n\n  \n\n\n\n\n# отбираем столбцы с префиксом \"wk\" и числовым диапозоном от 2 до 5\nbillboard %>% \n  select(num_range(\"wk\", 2:5))\n\n\n\n  \n\n\n\n\n\nФункции выбора по символьному вектору\nall_of\nall_of(x) - предназначен для строгого отбора. Если какая-либо из переменных в символьном векторе отсутствует, выдается сообщение об ошибке\n\n\n\nvar <- c('name', 'mass')\nstarwars %>% \n  select(all_of(var))\n\n\n\n  \n\n\n\n\n```{r}\n# Если какая-либо переменная отсутствует во фрейме данных, это ошибка\nvar <- c('name', 'mass', 'class')\nstarwars %>% \n  select(all_of(var))\n\n\n# Error in `select()`:\n# ! Problem while evaluating `all_of(var)`.\n# Backtrace:\n#  1. starwars %>% select(all_of(var))\n#  3. dplyr:::select.data.frame(., all_of(var))\n# Error in select(., all_of(var)) :\n```\n\n\n\nany_of\nany_of(x, ..., vars = NULL) - не проверяет наличие отсутствующих переменных. Это особенно полезно при отрицательном выборе, когда вы хотите убедиться, что переменная удалена\n\n\n\n# Проверяем, что столбец отсутствует во фрейме\nvar <- c('class')\nstarwars %>% \n  select(any_of(var))\n\n\n\n  \n\n\n\n\n# Удаляем из фрейма столбцы\n# Даже вызвав одну функцию несколько раз ошибки не будет\nvar <- c('name', 'mass')\nstarwars %>% \n  select(-any_of(var)) %>% \n  select(-any_of(var))\n\n\n\n  \n\n\n\n\n\nВыбор через функцию\nwhere\nwhere(fn) - Применяет функцию ко всем переменным и выбирает те, для которых функция возвращает значение TRUE\nВнутри функции можно создавать анонимные функции подобно тем, что создаются в пакете purrr, рассмотрим разные варианты реализации одной и той же логики\n\n\n\n# отбираем только числовые столбцы\niris %>% \n  select(where(is.numeric))\n\n\n\n  \n\n\n\n\n# отбираем только числовые столбцы\niris %>% \n  select(where(function(x) is.numeric(x)))\n\n\n\n  \n\n\n\n\n\n\n# отбираем только числовые столбцы\niris %>% \n  select(where(~ is.numeric(.x)))\n\n\n\n  \n\n\n\n\n# отбираем только числовые столбцы # у которых стреднее больше 3.5\niris %>% \n  select(where(~ is.numeric(.x) &&  mean(.x) > 3.5))"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#фильтрация",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#фильтрация",
    "title": "Dplyr cheat sheet",
    "section": "Фильтрация",
    "text": "Фильтрация\nПо логическому условию\n\nstarwars %>% \n  filter(mass > 50)\n\n\n\n  \n\n\n#комбинировать несколько условий можно с помощью & и |:\nstarwars %>% \n  filter(mass > 50 & height > 170)\n\n\n\n  \n\n\n\nКонструировать логические условия можно и другими операторами\nКак пользоваться каждым из этих операторов???\n\n>=\n<=\nis.na\n!is.na\n%in%\n!\nbetween\nnear\nxor\n\n\nstarwars %>% \n  filter(skin_color %in% c('fair', 'green'))"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#сортировка",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#сортировка",
    "title": "Dplyr cheat sheet",
    "section": "Сортировка",
    "text": "Сортировка\nДля сортировки в языке есть достаточно широкие возможности. Вот самые основные виды сортировки:\nПо возрастанию\n\nstarwars %>% \n  arrange(mass)\n\n\n\n  \n\n\n\nПо убыванию\n\n# сортировка по убыванию\nstarwars %>% \n  arrange(desc(mass))\n\n\n\n  \n\n\n\nПо нескольким столбцам\n\n# сортировка по нескольким столбцам\nstarwars %>% \n  arrange(height, desc(mass))\n\n\n\n  \n\n\n\nРасширенная сортировка\nПри сортировке можно использовать вспомогательные функции для select, только внутри функции across\n\nstarwars %>% \n  arrange(across(ends_with('_color'), desc))"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#группировка-и-обработка-групп",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#группировка-и-обработка-групп",
    "title": "Dplyr cheat sheet",
    "section": "Группировка и обработка групп",
    "text": "Группировка и обработка групп\nГруппировка\ngroup_by\ngroup_map\ngroup_cols\ngroup_modify\ngroup_walk\ngroup_split\ngroup_trim\nrowwise\nungroup"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#манипуляция-отдельными-строками",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#манипуляция-отдельными-строками",
    "title": "Dplyr cheat sheet",
    "section": "Манипуляция отдельными строками",
    "text": "Манипуляция отдельными строками\nГруппа этих функций позволяет манипулировать отдельными строками на подобии SQL без создания копии фрейма данных.\nРассмотрим атрибуты функций:\n\n\nx, y -\n\nby -\n\nconflict -\n\ncopy -\n\nin_place -\n\nunmatched -\n\nСоздадим набор данных для описания возможностей работы с функциями:\n\ndata <- tibble(a = 1:3, b = letters[c(1:2, NA)], c = 0.5 + 0:2)\ndata\n\n\n\n  \n\n\n\nInsert\nrows_insert(x, y, by = NULL, ..., conflict = c(\"error\", \"ignore\"), copy = FALSE, in_place = FALSE)\nrows_insert() - добавляет новую стороку во фрейм данных, по умолчанию ключевые значения добавляемой строки не должны существовать во фрейме.\n\n\n\nrows_insert(data, tibble(a = 4, b = \"z\"))\n\nMatching, by = \"a\"\n\n\n\n\n  \n\n\n\n\nrows_insert(data, tibble(a = 3, b = \"z\"), conflict = \"ignore\")\n\nMatching, by = \"a\"\n\n\n\n\n  \n\n\n\n\n\nВоспроизведем ситуацию когда ключевые значения совпадают\n\ntry(rows_insert(data, tibble(a = 3, b = \"z\")))\n\nMatching, by = \"a\"\n\n\nError in rows_insert(data, tibble(a = 3, b = \"z\")) : \n  `y` can't contain keys that already exist in `x`.\nℹ The following rows in `y` have keys that already exist in `x`: `c(1)`.\nℹ Use `conflict = \"ignore\"` if you want to ignore these `y` rows.\n\n\nAppend\nrows_append(x, y, ..., copy = FALSE, in_place = FALSE)\nrows_append() работает как rows_insert(), т.е. добавляет новую строку во фрейм данных, но игнорирует ключевые значения\n\nrows_append(data, tibble(a = 3, b = \"z\"))\n\n\n\n  \n\n\n\nUpdate\nrows_update(x, y, by = NULL, ..., unmatched = c(\"error\", \"ignore\"), copy = FALSE, in_place = FALSE)\nrows_update() modifies existing rows (like UPDATE). Key values in y must be unique, and, by default, key values in y must exist in x.\n`by - будет задавать вектор ключевых столбцов, если форматы фреймов не совпадют, то указания ключевого столбца обязательно.\n\n\n\nrows_update(data, tibble(a = 2:3, b = \"z\"))\n\nMatching, by = \"a\"\n\n\n\n\n  \n\n\n\n\nrows_update(data, tibble(b = \"z\", a = 2:3), by = 'a')\n\n\n\n  \n\n\n\n\n\nРассмотрим ситуацию когда два фрейма не совпадают по ключам (во втором фрейме есть ключи отсутствующие в первом) между собой\n\n\n\ny <- tibble(a = 3:4, b = \"z\")\ntry(rows_update(data, y, by = \"a\"))\n\nError in rows_update(data, y, by = \"a\") : \n  `y` must contain keys that already exist in `x`.\nℹ The following rows in `y` have keys that don't exist in `x`: `c(2)`.\nℹ Use `unmatched = \"ignore\"` if you want to ignore these `y` rows.\n\n\n\nrows_update(data, y, by = \"a\", unmatched = \"ignore\")\n\n\n\n  \n\n\n\n\n\nPatch\nrows_patch(x, y, by = NULL, ..., unmatched = c(\"error\", \"ignore\"), copy = FALSE, in_place = FALSE)\nUpsert\nrows_upsert(x, y, by = NULL, ..., copy = FALSE, in_place = FALSE)\nDelete\nrows_delete(x, y, by = NULL, ..., unmatched = c(\"error\", \"ignore\"), copy = FALSE, in_place = FALSE)\nrows_delete() deletes rows (like DELETE). By default, key values in y must exist in x."
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#определить-куда-это-относится",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#определить-куда-это-относится",
    "title": "Dplyr cheat sheet",
    "section": "Определить куда это относится",
    "text": "Определить куда это относится\nn() gives the current group size.\ncur_data() gives the current data for the current group (excluding grouping variables).\ncur_data_all() gives the current data for the current group (including grouping variables)\ncur_group() gives the group keys, a tibble with one row and one column for each grouping variable.\ncur_group_id() gives a unique numeric identifier for the current group.\ncur_group_rows() gives the row indices for the current group.\ncur_column() gives the name of the current column (in across() only)."
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#и-это",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#и-это",
    "title": "Dplyr cheat sheet",
    "section": "И это",
    "text": "И это\nCompute results of a query\ncompute(): dbplyr (tbl_sql), dplyr (data.frame)\ncollect(): dbplyr (tbl_sql), dplyr (data.frame)\ncollapse(): dbplyr (tbl_sql), dplyr (data.frame)\n\n# сама по себе группировка не несет смысла, только в сочетании с агрегирующими функциями\nstarwars %>% \n  group_by(eye_color)\n\n\n\n  \n\n\n\n\nstarwars %>% \n  group_by(eye_color) %>% # группируем по полю\n  summarise(\n    'mean mass' = mean(mass), # задаем имя столбцу и применяем функцию\n    'max mass' = max(mass),\n    'min mass' = min(mass),\n    'first mass' = first(mass),\n    'median mass' = median(mass),\n    'quantity' = n()\n  )\n\n\n\n  \n\n\n# про другие функции summarise в ?summarise\n\nРассчитать показатели только для нескольких столбцов сразу\n\nstarwars %>% \n  group_by(eye_color) %>% \n  summarise(\n    across(\n      .cols = c(mass, height), # столбцы к котторым применятся функции\n      .fns = list(mean = mean, max = max, min = min, first = first, median = median), # набор функций\n      .names = \"{.col}.fn_{.fn}\"  # шаблон имени столбца\n    )\n  )"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#агрегатные-функции",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#агрегатные-функции",
    "title": "Dplyr cheat sheet",
    "section": "Агрегатные функции",
    "text": "Агрегатные функции\nSummarise\nCount: n(), n_distinct()\nPosition: first(), last(), nth(),\nCenter: mean(), median()\nSpread: sd(), IQR(), mad()\nRange: min(), max(), quantile()\nLogical: any(), all()"
  }
]