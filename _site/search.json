[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Best Practices IT",
    "section": "",
    "text": "Примеры практик, статьи и описание технологий IT\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDplyr cheat sheet\n\n\n\n\n\n\n\nR\n\n\ndplyr\n\n\ntidyverse\n\n\n\n\nОбзор основного функционала пакета dplyr\n\n\n\n\n\n\nNov 16, 2022\n\n\n4 min\n\n\n\n\n\n\n\n\nQuarto cheat sheet\n\n\n\n\n\n\n\nR\n\n\nQuarto\n\n\ncheatsheet\n\n\n\n\nОписание возможностей Quarto для создания web сайтов и их наполнения\n\n\n\n\n\n\nOct 11, 2022\n\n\n5 min\n\n\n\n\n\n\n\n\nR language\n\n\n\n\n\n\n\n\n\n\n\n\n0 min\n\n\n\n\n\n\n\n\nUpSet диаграммы - введение\n\n\n\n\n\n\n\nR\n\n\nUpSet\n\n\nHeatmap\n\n\nvisualization\n\n\n\n\nПостроение диаграмм пересечения множеств с помощью UpSet графиков развитие диаграмм Вена на большом количестве анализируемых атрибутов\n\n\n\n\n\n\nOct 18, 2022\n\n\n4 min\n\n\n\n\n\n\n\n\nVisualization\n\n\n\n\n\n\n\n\n\n\n\n\n0 min\n\n\n\n\n\n\n\n\nСоздание графиков в пакете UpSetR\n\n\n\n\n\n\n\nR\n\n\nUpSet\n\n\nvisualization\n\n\n\n\nРассмотрим пакет UpSetR, разберем примеры построения качественных и красивых графиков\n\n\n\n\n\n\nNov 24, 2022\n\n\n23 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html",
    "title": "Dplyr cheat sheet",
    "section": "",
    "text": "Выполним установку пакета dplyr и загрузим набор данных starwars"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#выборка-данных",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#выборка-данных",
    "title": "Dplyr cheat sheet",
    "section": "Выборка данных",
    "text": "Выборка данных\nВ R возможно делать выборку столбцов разными стособами. Просто перечислить названия столбцов или их номера, перечислить какие столбцы не нужно выводить или выводить столбцы с именем соответствующим определенному условию.\nПеречисление\n\nstarwars %>% \n  select(name)\n\n\n\n  \n\n\n\nОтрицательное перечисление\nЕсли нужно указать какой столбец не включать в выборку то ставится знак минус:\n\nstarwars %>% \n  select(-c(name, mass))\n\n\n\n  \n\n\n\nПо номерам\nИли можно указать номера столбцов\n\nstarwars %>% \n  select(1, 2)\n\n\n\n  \n\n\n\nПо условию\nподробнее в ?select\n\n\ncontains: название столбца содержит символ\n\n\nends_with: название столбца заканчивается на\n\n\nmatches: название столбца соответствует регулярному выражению\n\n\nnum_range: поиск занумерованных столбцов, например, «V1, V2, V3…»\n\n\none_of: название столбца соответствует одному из вариантов\n\n\nstarts_with: название столбца начинается с\n\n\ncontains\n\n# отберем столбцы, название которых содержит букву «а».\nstarwars %>% \n  select(contains('a'))\n\n\n\n  \n\n\n\none_of\n\n# отберем столбцы, название которых является одним из указанных\nstarwars %>% \n  select(one_of('mass', 'height'))\n\n\n\n  \n\n\n\nmatches\n\n# поиск по регулярному выражению\nstarwars %>% \n  select(matches('.*t+.+'))\n\n\n\n  \n\n\n\nВернуть вектор\nЕсли нужно вернуть столбец не как таблицу, а вектор, то делаем это через pull\n\nstarwars %>% \n  pull('name')\n\n [1] \"Luke Skywalker\"        \"C-3PO\"                 \"R2-D2\"                \n [4] \"Darth Vader\"           \"Leia Organa\"           \"Owen Lars\"            \n [7] \"Beru Whitesun lars\"    \"R5-D4\"                 \"Biggs Darklighter\"    \n[10] \"Obi-Wan Kenobi\"        \"Anakin Skywalker\"      \"Wilhuff Tarkin\"       \n[13] \"Chewbacca\"             \"Han Solo\"              \"Greedo\"               \n[16] \"Jabba Desilijic Tiure\" \"Wedge Antilles\"        \"Jek Tono Porkins\"     \n[19] \"Yoda\"                  \"Palpatine\"             \"Boba Fett\"            \n[22] \"IG-88\"                 \"Bossk\"                 \"Lando Calrissian\"     \n[25] \"Lobot\"                 \"Ackbar\"                \"Mon Mothma\"           \n[28] \"Arvel Crynyd\"          \"Wicket Systri Warrick\" \"Nien Nunb\"            \n[31] \"Qui-Gon Jinn\"          \"Nute Gunray\"           \"Finis Valorum\"        \n[34] \"Jar Jar Binks\"         \"Roos Tarpals\"          \"Rugor Nass\"           \n[37] \"Ric Olié\"              \"Watto\"                 \"Sebulba\"              \n[40] \"Quarsh Panaka\"         \"Shmi Skywalker\"        \"Darth Maul\"           \n[43] \"Bib Fortuna\"           \"Ayla Secura\"           \"Dud Bolt\"             \n[46] \"Gasgano\"               \"Ben Quadinaros\"        \"Mace Windu\"           \n[49] \"Ki-Adi-Mundi\"          \"Kit Fisto\"             \"Eeth Koth\"            \n[52] \"Adi Gallia\"            \"Saesee Tiin\"           \"Yarael Poof\"          \n[55] \"Plo Koon\"              \"Mas Amedda\"            \"Gregar Typho\"         \n[58] \"Cordé\"                 \"Cliegg Lars\"           \"Poggle the Lesser\"    \n[61] \"Luminara Unduli\"       \"Barriss Offee\"         \"Dormé\"                \n[64] \"Dooku\"                 \"Bail Prestor Organa\"   \"Jango Fett\"           \n[67] \"Zam Wesell\"            \"Dexter Jettster\"       \"Lama Su\"              \n[70] \"Taun We\"               \"Jocasta Nu\"            \"Ratts Tyerell\"        \n[73] \"R4-P17\"                \"Wat Tambor\"            \"San Hill\"             \n[76] \"Shaak Ti\"              \"Grievous\"              \"Tarfful\"              \n[79] \"Raymus Antilles\"       \"Sly Moore\"             \"Tion Medon\"           \n[82] \"Finn\"                  \"Rey\"                   \"Poe Dameron\"          \n[85] \"BB8\"                   \"Captain Phasma\"        \"Padmé Amidala\"        \n\n\nУникальные значения\n\nstarwars %>% \n  distinct(sex)\n\n\n\n  \n\n\n\nПо индексу\n\nstarwars %>% \n  slice(5:15)\n\n\n\n  \n\n\n\nСлучайные строки\nВозвращаем n - случайных строк\n\nstarwars %>% \n  sample_n(5)\n\n\n\n  \n\n\n\nЕсли нужно указать долю строк из общего числа, которые должны быть в итоговой таблице, то используем sample_frac. Например, при параметре 0.5 вернется половина строк из таблицы, выбранные случайным образом.\n\nstarwars %>% \n  sample_frac(0.1)"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#фильтрация-строк",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#фильтрация-строк",
    "title": "Dplyr cheat sheet",
    "section": "Фильтрация строк",
    "text": "Фильтрация строк\nПо логическому условию\n\nstarwars %>% \n  filter(mass > 50)\n\n\n\n  \n\n\n#комбинировать несколько условий можно с помощью & и |:\nstarwars %>% \n  filter(mass > 50 & height > 170)\n\n\n\n  \n\n\n\nКонструировать логические условия можно и другими операторами\n\n>=\n<=\nis.na\n!is.na\n%in%\n!\nbetween\nnear\nxor\n\n\nstarwars %>% \n  filter(skin_color %in% c('fair', 'green'))"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#сортировка-строк",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#сортировка-строк",
    "title": "Dplyr cheat sheet",
    "section": "Сортировка строк",
    "text": "Сортировка строк\nДля сортировки в языке есть достаточно широкие возможности. Вот самые основные виды сортировки:\nПо возрастанию\n\nstarwars %>% \n  arrange(mass)\n\n\n\n  \n\n\n\nПо убыванию\n\n# сортировка по убыванию\nstarwars %>% \n  arrange(desc(mass))\n\n\n\n  \n\n\n\nПо нескольким столбцам\n\n# сортировка по нескольким столбцам\nstarwars %>% \n  arrange(height, desc(mass))\n\n\n\n  \n\n\n\nРасширенная сортировка\nПри сортировке можно использовать вспомогательные функции для select, только внутри функции across\n\nstarwars %>% \n  arrange(across(ends_with('_color'), desc))"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#группировка-и-агрегатные-функции",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#группировка-и-агрегатные-функции",
    "title": "Dplyr cheat sheet",
    "section": "Группировка и агрегатные функции",
    "text": "Группировка и агрегатные функции\n\n# сама по себе группировка не несет смысла, только в сочетании с агрегирующими функциями\nstarwars %>% \n  group_by(eye_color)\n\n\n\n  \n\n\n\n\nstarwars %>% \n  group_by(eye_color) %>% # группируем по полю\n  summarise(\n    'mean mass' = mean(mass), # задаем имя столбцу и применяем функцию\n    'max mass' = max(mass),\n    'min mass' = min(mass),\n    'first mass' = first(mass),\n    'median mass' = median(mass),\n    'quantity' = n()\n  )\n\n\n\n  \n\n\n# про другие функции summarise в ?summarise\n\nРассчитать показатели только для нескольких столбцов сразу\n\nstarwars %>% \n  group_by(eye_color) %>% \n  summarise(\n    across(\n      .cols = c(mass, height), # столбцы к котторым применятся функции\n      .fns = list(mean = mean, max = max, min = min, first = first, median = median), # набор функций\n      .names = \"{.col}.fn_{.fn}\"  # шаблон имени столбца\n    )\n  )"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#вычисляемые-столбцы",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#вычисляемые-столбцы",
    "title": "Dplyr cheat sheet",
    "section": "Вычисляемые столбцы",
    "text": "Вычисляемые столбцы\nНовый столбец\n\nstarwars %>% \n  select(name, height, mass) %>% \n  mutate('coef' = mass/height)\n\n\n\n  \n\n\n\nИзменить несколько столбцов\nПрименить функцию ко всем столбцам по условию\n\nstarwars %>% \n  mutate(\n    across(\n      .cols = where(is.numeric), # применить функцию ко всем числовым столбцам\n      .fns = function(x) x*10 # x в function это стоблцы по условию в cols\n    )\n  )\n\n\n\n  \n\n\n\nВычисление с условием\n\nstarwars %>% \n  select(name, height, mass) %>% \n  # логические условия в вычислении\n  mutate('case_col' = case_when(\n    name == 'Luke Skywalker' | name == 'Leia Organa'  ~ 'Главный герой',\n    name == 'Darth Vader' ~ 'Главный злодей',\n    TRUE ~ 'Другой персонаж'\n    ))"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#оконные-функции",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#оконные-функции",
    "title": "Dplyr cheat sheet",
    "section": "Оконные функции",
    "text": "Оконные функции\n\nstarwars %>% \n  select(name, height, mass) %>% \n  mutate('rnk' = dense_rank(mass)) %>% \n  mutate('r_num' = row_number(mass))"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#обработка-null",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#обработка-null",
    "title": "Dplyr cheat sheet",
    "section": "Обработка null",
    "text": "Обработка null\n\nstarwars %>% \n  select(name, height, mass) %>% \n  # логические условия в вычислении\n  mutate('case_col' = case_when(\n    name == 'Luke Skywalker' | name == 'Leia Organa'  ~ 'Главный герой',\n    name == 'Darth Vader' ~ 'Главный злодей'\n    )) %>% \n  mutate('coalesce_col' = coalesce(case_col, 'другой персонаж'))"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#объединение-таблиц",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#объединение-таблиц",
    "title": "Dplyr cheat sheet",
    "section": "Объединение таблиц",
    "text": "Объединение таблиц\nПодготовим датафрейм by аналог ON в SQL\n\ndf <- starwars %>% \n  filter(species == 'Human') %>% \n  rename('new_name' = 'name')\nstarwars %>% \n  inner_join(df, by = c('name' = 'new_name')) \n\n\n\n  \n\n\n\nЧтобы не было суффиксов в именах столбцов можно соединять по всем столбцам у которых совпадают имена\n\nstarwars %>% \n  inner_join(df)\n\nJoining, by = c(\"height\", \"mass\", \"hair_color\", \"skin_color\", \"eye_color\",\n\"birth_year\", \"sex\", \"gender\", \"homeworld\", \"species\", \"films\", \"vehicles\",\n\"starships\")\n\n\n\n\n  \n\n\n\nДля соединения брать не всю таблицу, а только нужные столбцы\n\nstarwars %>% \n  inner_join(\n    select(df, c('new_name', 'mass')),\n    by = c('name' = 'new_name')\n    )"
  },
  {
    "objectID": "r_language/Tutorial/Quarto_cheatsheet.html",
    "href": "r_language/Tutorial/Quarto_cheatsheet.html",
    "title": "Quarto cheat sheet",
    "section": "",
    "text": "Отображение контента\n\nСодержание страницы\n\ntoc: true|false - включение/отключение отображения содержания страницы\ntoc-depth: 2 - глубина отображаемых заголовков в содержании\ntoc-title: Contents - заголовок содержания\ntoc-location: left - положение содержания\n\n\n\nБлок кода\nВ блоке кода опции можно задавать через комментарий вида: #|, вот некоторые опции:\n\necho: true|false - показать\\скрыть код\ninclude: false - показать\\скрыть результат работы кода\nwarning: true|false - показать\\скрыть предупреждения\nerror: true|false - показать\\скрыть ошибки при выполнении\ncode-fold: true - добавить опцию свернуть\\развернуть код\ncode-summary: \"Show the code\" - заголовок свернутого блока кода\ncode-overflow: wrap|scroll - добавляет скролл или перенос по словам для длинных строк кода\n\n\n\nИзображения и графики\nОписание вариантов размещения изображений и графиков приведено в статье1.\n\n\n\nНастройка темы\n\nТема блока кода\nДля блока кода можно задать тему, что примечательно если на сайте заданы светлая и темная темы, то для каждой из них можно установить свою тему блока кода.\nhighlight-style: github - установить тему github для блока кода\nУстановить для светлой и темной темы, темы блоков кода\nhighlight-style:\n  light: custom-light.theme\n  dark: custom-dark.theme\nСписок тем: [a11y, arrow, atom-one, ayu, breeze, github, gruvbox, pygments, tango, espresso, zenburn, kate, monochrome, breezedark, haddock, dracula, mokokai, nord, oblivion, printing, radical, solarized, vim-dark]\n\n\n\nУравнения\nВывести математические уравнения можно внутри строки с тестом или отдельным блоком\nВывод формулы $E = mc^{2}$ \\(E = mc^{2}\\) в строке текста.\nВывод формулы $$E = mc^{2}$$ отдельным блоком \\[E = mc^{2}\\]\n\n\nДиаграммы\nВ Quarto можно выводить настраиваемые диаграммы Mermaid and Graphviz\nРассмотрим примеры диаграмм выполненых в Mermaid\n\nFlowchart\nПодробная инструкция по составлению диаграммы Flowchart.\n\ngraph TD;\n    A-->B;\n    A-->C;\n    B-->D;\n    C-->D;\n\n\n\ngraph TD;\n    A-->B;\n    A-->C;\n    B-->D;\n    C-->D;\n\n\n\n\n\n\n\n\n\n\nSequence diagram\nПодробная инструкция по составлению диаграммы Sequence diagram.\n\nsequenceDiagram\n    Alice->>John: Hello John, how are you?\n    John-->>Alice: Great!\n    Alice-)John: See you later!\n\n\n\nsequenceDiagram\n    Alice->>John: Hello John, how are you?\n    John-->>Alice: Great!\n    Alice-)John: See you later!\n\n\n\n\n\n\n\n\n\n\nGantt diagram\nПодробная инструкция по составлению диаграммы Gantt diagram.\n\ngantt\n    title A Gantt Diagram\n    dateFormat  YYYY-MM-DD\n    section Section\n    A task           :a1, 2014-01-01, 30d\n    Another task     :after a1  , 20d\n    section Another\n    Task in sec      :2014-01-12  , 12d\n    another task      : 24d\n\n\n\ngantt\n    title A Gantt Diagram\n    dateFormat  YYYY-MM-DD\n    section Section\n    A task           :a1, 2014-01-01, 30d\n    Another task     :after a1  , 20d\n    section Another\n    Task in sec      :2014-01-12  , 12d\n    another task      : 24d\n\n\n\n\n\n\n\n\n\n\nClass diagram\nПодробная инструкция по составлению диаграммы Class diagram.\n\nclassDiagram\n    Animal <|-- Duck\n    Animal <|-- Fish\n    Animal <|-- Zebra\n    Animal : +int age\n    Animal : +String gender\n    Animal: +isMammal()\n    Animal: +mate()\n    class Duck{\n        +String beakColor\n        +swim()\n        +quack()\n    }\n    class Fish{\n        -int sizeInFeet\n        -canEat()\n    }\n    class Zebra{\n        +bool is_wild\n        +run()\n    }\n\n\n\nclassDiagram\n    Animal <|-- Duck\n    Animal <|-- Fish\n    Animal <|-- Zebra\n    Animal : +int age\n    Animal : +String gender\n    Animal: +isMammal()\n    Animal: +mate()\n    class Duck{\n        +String beakColor\n        +swim()\n        +quack()\n    }\n    class Fish{\n        -int sizeInFeet\n        -canEat()\n    }\n    class Zebra{\n        +bool is_wild\n        +run()\n    }\n\n\n\n\n\n\n\n\n\n\nGit graph\nПодробная инструкция по составлению диаграммы Git graph.\n\ngitGraph\n       commit\n       commit\n       branch develop\n       commit\n       commit\n       commit\n       checkout main\n       commit\n       commit\n\n\n\n    gitGraph\n       commit\n       commit\n       branch develop\n       commit\n       commit\n       commit\n       checkout main\n       commit\n       commit\n\n\n\n\n\n\n\n\n\n\nEntity Relationship Diagrams\nПодробная инструкция по составлению диаграммы Entity Relationship Diagrams.\n\nerDiagram\n    CUSTOMER ||--o{ ORDER : places\n    ORDER ||--|{ LINE-ITEM : contains\n    CUSTOMER }|..|{ DELIVERY-ADDRESS : uses\n\n\n\nerDiagram\n    CUSTOMER ||--o{ ORDER : places\n    ORDER ||--|{ LINE-ITEM : contains\n    CUSTOMER }|..|{ DELIVERY-ADDRESS : uses\n\n\n\n\n\n\n\n\n\n\nUser Journey Diagram\nПодробная инструкция по составлению диаграммы User Journey Diagram.\n\njourney\n    title My working day\n    section Go to work\n      Make tea: 5: Me\n      Go upstairs: 3: Me\n      Do work: 1: Me, Cat\n    section Go home\n      Go downstairs: 5: Me\n      Sit down: 5: Me\n\n\n\njourney\n    title My working day\n    section Go to work\n      Make tea: 5: Me\n      Go upstairs: 3: Me\n      Do work: 1: Me, Cat\n    section Go home\n      Go downstairs: 5: Me\n      Sit down: 5: Me\n\n\n\n\n\n\n\n\n\n\n\nВидео\nВ документ можно вставлять фрейм с видео роликом, например\n\n\n\nВыноски\nВыноски нужны чтобы подсветить какую-либо информацию, может быть несколько таких типов:\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, warning, important, tip, and caution.\n::: {.callout-note}\nNote that there are five types of callouts, including:\n`note`, `warning`, `important`, `tip`, and `caution`.\n:::\n\n\n\n\n\n\n\n\nTip With important\n\n\n\nThis is an example of a callout with a caption.\n::: {.callout-important}\n## Tip With Caption\n\nThis is an example of a callout with a caption.\n:::\n\n\n\n\n\n\n\n\nTip With tip\n\n\n\nThis is an example of a callout with a tip.\n::: {.callout-tip}\n## Tip With Caption\n\nThis is an example of a callout with a caption.\n:::\n\n\n\n\n\n\n\n\nExpand To Learn About Collapse\n\n\n\n\n\nThis is an example of a ‘folded’ caution callout that can be expanded by the user. You can use collapse=\"true\" to collapse it by default or collapse=\"false\" to make a collapsible callout that is expanded by default.\n::: {.callout-caution collapse=\"true\"}\n## Expand To Learn About Collapse\n\nThis is an example of a 'folded' caution callout that can be expanded by the user. You can use `collapse=\"true\"` to collapse it by default or `collapse=\"false\"` to make a collapsible callout that is expanded by default.\n:::\n\n\n\n\n\n\n\n\n\n\nTip With warning\n\n\n\nThis is an example of a callout with a warning.\n::: {.callout-warning}\n## Tip With Caption\n\nThis is an example of a callout with a caption.\n:::\n\n\n\n\nОтступления\nЧтобы делать отступления и комментарии по ходу текста, можно вставить тег .aside в фигурных скобках. This is a span that has the class aside which places it in the margin without a footnote number.\n[This is a span that has the class aside which places it in the margin without a footnote number.]{.aside}\n\n\nСноски\nСноски можно добавить в текст использовав 2 ‘[^ + цифра или слово]’\n\n\n\n\n\nFootnotes\n\n\nFigures↩︎\nа чтобы описать сноску ставим ‘[^ + цифра или слово]:’↩︎\n\nCitationBibTeX citation:@online{practicesit2022,\n  author = {Best Practices IT},\n  title = {Quarto Cheat Sheet},\n  date = {2022-10-11},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nBest Practices IT. 2022. “Quarto Cheat Sheet.” October 11,\n2022."
  },
  {
    "objectID": "visualization/Diagramms/Upset/diagramm_upsetr.html",
    "href": "visualization/Diagramms/Upset/diagramm_upsetr.html",
    "title": "UpSet диаграммы - введение",
    "section": "",
    "text": "Понимание взаимосвязей между атрибутами изучаемого набора данных является важной задачей анализа. Основной проблемой в этом контексте является комбинаторный взрыв числа пересечений множеств, если количество множеств превышает тривиальный порог. Наиболее распространенный подход к визуализации наборов – Диаграммы Венна - не масштабируется дальше трех или четырех наборов.\nГрафики UpSet дают возможность проводить анализ взаимосвязей гораздо большего числа атрибутов.\n\n\nUpSet лучше всего работает для наборов данных, содержащих более трех и менее 30 наборов. Для менее чем 4 наборов лучшим выбором может быть пропорциональная площади диаграмма Венна, поскольку они более привычны пользователям.\nUpSet хорошо подходит для анализа распределений и свойств многих элементов. Элементы абстрагируются как “count”, хотя атрибуты элементов могут быть визуализированы в виде интегрированных или смежных графиков.\nкогда вы хотите посмотреть на все комбинации пересечений множеств. Если вы хотите посмотреть на попарные пересечения между наборами, лучшим выбором может быть какая-то матрица комбинаций.\n\nUpSet отображает пересечения множества в виде матрицы, как показано на следующем рисунке. Каждый столбец соответствует набору, а столбчатые диаграммы сверху показывают размер набора. Каждая строка соответствует возможному пересечению: заполненные ячейки показывают, какой набор является частью пересечения. Также обратите внимание на линии, соединяющие заполненные ячейки: они показывают, в каком направлении вы должны читать график:\n\n\nFigure 1: Чтение графика\n\n\nРассмотрим как эти пересечения соответствуют сегментам на диаграмме Венна.\n\nПервая строка на рисунке полностью пуста – соответствует всем элементам, которые не входят ни в один из наборов.\nЗеленая (третья) строка соответствует элементам, которые находятся только в наборе B (не в A или C).\nОранжевая (пятая) строка представляет элементы, которые являются общими для наборов A и B, но не для C.\nНаконец, последняя (фиолетовая) строка представляет элементы, общие для всех наборов.\n\n\n\nFigure 2: Сопоставление с диаграммой Венна\n\n\nЭтот график хорош тем, что мы можем отобразить размер пересечений (“мощность”) в виде гистограмм прямо рядом с матрицей, как вы можете видеть в следующем примере:\n\n\nFigure 3: Гистограмма мощности на графике UpSet\n\n\nТакое представление мощнойстей делает более понятным сравнение размеров пересечений.\nМатрица также очень полезна, потому что ее можно сортировать различными способами. Обычным способом является сортировка по мощности (размеру), как показано на следующем рисунке, но также возможны и другие виды сортировки.\n\n\nFigure 4: Пример сортировки по мощности\n\n\nНаконец, UpSet одинаково хорошо работает как по горизонтали, так и по вертикали. Вертикальные графики лучше подходят для интерактивных графиков, которые можно прокручивать, в то время как горизонтальные графики лучше всего подходят для статичного представления.\n\n\nFigure 5: Горизонтальный график UpSet\n\n\nМы уже частично коснулись матрицы в которая содержит комбинации атрибутов, теперь рассмотрим её подробнее."
  },
  {
    "objectID": "visualization/Diagramms/Upset/diagramm_upsetr.html#комбинационная-матрица",
    "href": "visualization/Diagramms/Upset/diagramm_upsetr.html#комбинационная-матрица",
    "title": "UpSet диаграммы - введение",
    "section": "Комбинационная матрица",
    "text": "Комбинационная матрица\nГрафик UpSet строится на комбинациях пересечений атрибутов набора данных. Атрибуты должны иметь значения (0, 1) или (TRUE, FALSE). Совокупность таких атрибутов называется комбинационной матрицей или матрицей комбинаций, рассмотрим её создание на примере пакета ComplexHeatmap.\nМатрицу комбинаций можно составить из:\n\nсписка, содержащего несколько векторов\nдвоичной матрицы или фрейма данных, где строки являются элементами, а столбцы - наборами\nесли переменная является фреймом данных, сохраняются только двоичные столбцы (содержащие только 0 и 1) и логические столбцы.\n\nДля простоты создадим список содержащий два вектора разных размеров и преобразуем его к матрице, чтобы посмотреть полученные комбинации\n\nls <- list(set1 = c(\"a\", \"b\", \"c\"), set2 = c(\"b\", \"c\", \"d\", \"e\"))\nlist_to_matrix(ls)\n\n  set1 set2\na    1    0\nb    1    1\nc    1    1\nd    0    1\ne    0    1\n\n\nВ полученной матрице наборы set1 (размер вектора 3 элемента) и set2 (размер вектора 4 элемента) образуют 5 комбинаций, давайте их перечислим\n\n\na - есть только в наборе set1\n\nb - есть в обоих наборах\n\nc - есть в обоих наборах\n\nd - есть только в наборе set2\n\ne - есть только в наборе set2\n\nИтого:\n\nкомбинаций, которые есть только в наборе set1 - 1 шт\nкомбинаций, которые есть в наборе set1 и set2 - 2 шт\nкомбинаций, которые есть только в наборе set2 - 2 шт\n\nНа графике это количество комбинаций или пересечений отображается как Intersection size, а длины векторов или наборы в матрице как Set size.\n\n\n\n\nFigure 6: Сопоставление комбинационной матрицы с графиком\n\n\n\n\nТеперь создадим матрицу комбинаций функцией make_comb_mat.\nУ функции make_comb_mat есть три режима работы:\n\n\ndistinct (по умолчанию)\nintersect\nunion mode\n\nКак режимы влияют на пересечение наборов показано на рисунке ниже, а влияние на графиках разберем ниже.\n\n\nFigure 7: Режимы комбинационной матрицы\n\n\nСоздадим матрицу комбинаций\n\n# задание режимов расчета размеров набора\nmx <- make_comb_mat(ls)\n\nm2 = make_comb_mat(ls, mode = \"intersect\")\nm3 = make_comb_mat(ls, mode = \"union\")\n\n# Когда наборов слишком много, наборы могут быть предварительно отфильтрованы по заданным размерам.\n# Фильтрация по размеру наборов\n# min_set_size - Минимальный размер набора, который используется для генерации комбинированной матрицы\nm1 = make_comb_mat(ls, min_set_size = 4)\n# top_n_sets - Количество наборов с наибольшими размерами, которые используется для генерации комбинированной матрицы\nm2 = make_comb_mat(ls, top_n_sets = 1) \n\nДальше с этой матрицей будем работать черех пакет ComplexHeatmap."
  },
  {
    "objectID": "visualization/Diagramms/Upset/diagramm_upsetr.html#реализация-графиков-upset",
    "href": "visualization/Diagramms/Upset/diagramm_upsetr.html#реализация-графиков-upset",
    "title": "UpSet диаграммы - введение",
    "section": "Реализация графиков UpSet",
    "text": "Реализация графиков UpSet\nСоздать графики можно на различных языках программирования, мы рассмотрим R и Python в дальнейших статьях.\nЭти графики в языке R реализованы в трех пакетах:\n\nUpSetR\nComplexHeatmap\nComplexUpset\n\nНе нужно совместно инициализировать пакеты UpSetR и ComplexUpset, их методы пересекаются и привызове функции upset пакета UpSetR возникает ошибка: unused argument\nА в Python в двух библиотеках:\n\nUpSetPlot\npyUpSet\n\nПримеры графиков UpSet\n\n\n\n\n\n\nГоризонтальный график с метками данных\n\n\n\n\n\n\nГоризонтальный график с дополнительными диаграммами\n\n\n\n\n\n\n\n\nГоризонтальный график с несколькими дополнительными вертикальными диаграммами\n\n\n\n\nFigure 8: Примеры UpSet графиков\n\n\n\nReferences"
  },
  {
    "objectID": "visualization/Diagramms/Upset/diagramm_upsetr.html#используемые-источники",
    "href": "visualization/Diagramms/Upset/diagramm_upsetr.html#используемые-источники",
    "title": "UpSet диаграммы - введение",
    "section": "Используемые источники:",
    "text": "Используемые источники:\n\nhttps://upset.app/\nhttps://jokergoo.github.io/ComplexHeatmap-reference/book/upset-plot.html"
  },
  {
    "objectID": "visualization/Diagramms/Upset/packege_upsetr.html",
    "href": "visualization/Diagramms/Upset/packege_upsetr.html",
    "title": "Создание графиков в пакете UpSetR",
    "section": "",
    "text": "Создание графиков UpSet в пакете UpSetR процесс достаточно простой и интуитивно понятный, пакет поможет создавать качественные и красивые визуализации для полного и глубокого анализа данных. \n\nЗагрузим набор данных предоставляемый этим пакетом. Для построения графика будем использовать функцию upset, подробнее об этой функции в ?upset\n\nmovies <- read.csv(system.file(\"extdata\", \"movies.csv\", package = \"UpSetR\"), \n    header = T, sep = \";\")\n\nВыберем 6 наибольших наборов.\n\nupset(movies, nsets = 6, number.angles = 0, point.size = 3.5, line.size = 2, \n    mainbar.y.label = \"Genre Intersections\", sets.x.label = \"Movies Per Genre\", \n    text.scale = c(1.3, 1.3, 1, 1, 2, 0.75))\n\n\n\nFigure 1: На оси Movies Per Genre показано количество фильмов каждого жанра. На оси Genre Intersections количество фильмов в разрезе пересечений с другими жанрами. Видно, что наибольшее количество набирается когда пересечений с другими жанрами нет либо оно минимальное, а самые популярные жанры: Драма, Комедия и Ужасы\n\n\n\n\n\n\nmb.ratio = c(0.75, 0.25) - через этот параметр задаем соотношение между столбчатой диаграммой и диаграммой пересечений. Сумма коэффициентов должна равняться единице.\n\n```{r}\nupset(movies, sets = c(\"Action\", \"Adventure\", \"Comedy\", \"Drama\", \"Mystery\", \n    \"Thriller\", \"Romance\", \"War\", \"Western\"), mb.ratio = c(0.75, 0.25), order.by = \"degree\")\n\nupset(movies, sets = c(\"Action\", \"Adventure\", \"Comedy\", \"Drama\", \"Mystery\", \n    \"Thriller\", \"Romance\", \"War\", \"Western\"), mb.ratio = c(0.55, 0.45), order.by = c(\"degree\", \"freq\"))\n```\n\n\n\n\n\n(a) First\n\n\n\n\n\n\n(b) Second\n\n\n\n\nFigure 2: В обоих графиках задаем список наборов, соотношения между столбчатой диаграммой и диаграммой пересечений поставили разные. В первом графике сортировка задана по возрастанию наборов, а во втором графике по частоте\n\n\n\n\nkeep.order - при значении TRUE упорядочивает наборы в том порядке в котором они записаны в sets при значении FALSE по их размеру\n\n\nupset(movies, sets = c(\"Action\", \"Adventure\", \"Comedy\", \"Drama\", \"Mystery\", \n    \"Thriller\", \"Romance\", \"War\", \"Western\"), mb.ratio = c(0.55, 0.45), order.by = \"freq\", \n    keep.order = TRUE)\n\n\n\nFigure 3: Наборы на графике отсортированны согласно заданному нами списку, а размеры пересечений по убыванию.\n\n\n\n\n\n\nnintersects - количество пересечений выведенных на график, по умолчанию выводятся все пересечения group.by - способ группировки по наборам или по количеству пересечений наборов cutoff - Количество пересечений из каждого набора (для отсечения) при агрегировании по наборам\n\n\nupset(movies, nintersects = 70, group.by = \"sets\", cutoff = 7)\n\n\n\nFigure 4: На графике видим размер пересечений сгруппированые по жанрам, в каждой группе не более 7 значений. Так пересекающихся жанров несколько , то значения в нескольких пересекающихся друг с другом жанрах будут повторяться.\n\n\n\n\n\n\nempty.intersections = “on” - свойство позволяет дополнительно отображать пустые пересечения\n\n\nupset(movies, empty.intersections = \"on\", order.by = \"freq\")\n\n\n\nFigure 5: Видно, что на графике появились пустые пересечения т.е. размер которых равен нулю.\n\n\n\n\n\n\n\n\nС помощью атрибутов можно выводить дополнительные диаграммы на график.\nПараметр attribute.plots содержит три поля: gridrows, plots, and ncols\n\n\ngridrows указывает на сколько нужно увеличить высоту окна графика чтобы добавить место под диаграммы атрибутов. График UpSetR отрисовывается на сетка размером 100 х 100. Например если установить парамерт gridrows = 50, то размер новой сетки окна будет 150 х 100.\n\nplots также содержит список параметров, в нем задаются plot, x, y и queries.\n\nplot функция возвращающая ggplot\n\nx задает параметр к оси X\n\ny задает параметр к оси Y\n\nqueries: указывает необходимо ли применять к графиком атрибутов результаты параметра queries функции upset. Если значение True, то к графику будет применен параметр queries, если False, то нет. Сам же параметр queries имеет атрибут query который определяет какая функция будет применена к графику, например intersects или самописная функция.\n\nncols указывает, как должны быть расположены графики в пространстве строк сетки. Если введены два графика атрибутов и значение ncols равно 1, то графики будут отображаться один над другим. В качестве альтернативы, если введены два графика атрибутов и значение ncols равно 2, графики атрибутов будут отображаться рядом. \n\n\n\nupset(movies, main.bar.color = \"black\", queries = list(list(query = intersects, \n    params = list(\"Drama\"), active = T)), \n    attribute.plots = list(gridrows = 50, \n                           plots = list(\n                             list(plot = histogram, x = \"ReleaseDate\", queries = F), \n                             list(plot = histogram, x = \"AvgRating\", queries = T)), \n                           ncols = 2)\n    )\n\n\n\nFigure 6: На графике выделенно синим цветом пересечение по жанру драма. В дополнительной диаграмме среднего рейтинга фильмов выделена доля фильмов жанра драма. И на левом дополнительном графике показана частота выхода фильмов в зависимости от года\n\n\n\n\n\nВ этом коде задаем форматирование для пересечений нужным цветом. Потом в дополнительных диаграммах атрибутов определяем использовать это форматирование или нет.\n\nupset(movies, main.bar.color = \"black\", \n      queries = list(\n        list(query = intersects, params = list(\"Drama\"), color = \"red\", active = F), \n        list(query = intersects, params = list(\"Action\", \"Drama\"), active = T), \n        list(query = intersects, params = list(\"Drama\", \"Comedy\", \"Action\"), color = \"orange\", active = T)\n        ),\n      attribute.plots = list(gridrows = 45, \n                             plots = list(list(plot = scatter_plot, x = \"ReleaseDate\", y = \"AvgRating\", queries = T),\n                                          list(plot = scatter_plot, x = \"AvgRating\", y = \"Watches\", queries = F)\n                                          ), \n                             ncols = 2), query.legend = \"bottom\")\n\n\n\nFigure 7: На графике выделили три типа пересечений и спроецировали их на одну дополнительную диаграмму. На первой доп диаграмме показана зависимость среднего рейтинга от даты выхода фильма, а также какую часть в нем занимают интересующие нас пересечения. На второй доп диаграмме зависимость просмотров от среднего рейтинга, логично, что чем выше рейтинг тем выше количество просмотров\n\n\n\n\n\nЗдесь вместо одной из точечных диаграмм, добавляем диаграмму постороенную по пользовательской функцие.\n\nmyplot <- function(mydata, x, y) {\n    plot <- (ggplot(data = mydata, aes_string(x = x, y = y, colour = \"color\")) + \n        geom_point() + scale_color_identity() + theme(plot.margin = unit(c(0, 0, 0, 0), \"cm\")))\n}\n\nanother.plot <- function(data, x, y) {\n    data$decades <- round_any(as.integer(unlist(data[y])), 10, ceiling)\n    data <- data[which(data$decades >= 1970), ]\n    myplot <- (ggplot(data, aes_string(x = x)) + geom_density(aes(fill = factor(decades)), \n        alpha = 0.4) + theme(plot.margin = unit(c(0, 0, 0, 0), \"cm\"), legend.key.size = unit(0.4, \n        \"cm\")))\n}\n\nupset(movies, main.bar.color = \"black\", \n      queries = list(list(query = intersects, params = list(\"Drama\"), color = \"red\", active = F), \n                     list(query = intersects, params = list(\"Action\", \"Drama\"), active = T), \n                     list(query = intersects, params = list(\"Drama\", \"Comedy\", \"Action\"), color = \"orange\", active = T)), \n                attribute.plots = list(gridrows = 45, \n                                       plots = list(\n                                         list(plot = myplot, x = \"ReleaseDate\", y = \"AvgRating\", queries = T), \n                                         list(plot = another.plot, x = \"AvgRating\", y = \"ReleaseDate\", queries = F)), \n                                       ncols = 2))\n\n\n\nFigure 8: На график добавили диаграмму постороенную по своей функции. Она отображает средний рейтинг фильмов в зависимости от даты выхода в разрезе десятилетий\n\n\n\n\nОбъединение встроенного точечного графика и графика гистограммы с пользовательским графиком myplot, определенным в приведенном выше примере.\n\nupset(movies, main.bar.color = \"black\", mb.ratio = c(0.5, 0.5), \n      queries = list(list(query = intersects, params = list(\"Drama\"), color = \"red\", active = F), \n                     list(query = intersects, params = list(\"Action\", \"Drama\"), active = T), \n                     list(query = intersects, params = list(\"Drama\", \"Comedy\", \"Action\"), color = \"orange\", active = T)), \n    attribute.plots = list(gridrows = 50, \n                           plots = list(\n                             list(plot = histogram,x = \"ReleaseDate\", queries = F), \n                             list(plot = scatter_plot, x = \"ReleaseDate\", y = \"AvgRating\", queries = T), \n                             list(plot = myplot, x = \"AvgRating\", y = \"Watches\", queries = F)), \n                           ncols = 3))\n\n\n\nFigure 9: На этом графике добавлены дополнительные диаграммы. Теперь можно анализировать данные с нескольких сторон: частоты выхода фильмов и среднего рейтинга в зависимости от даты выхода, а также количество просмотров от серднего рейтинга фильмов\n\n\n\n\n\nboxplot, показывает распределение атрибута по всем пересечениям. Может отображать одновременно не более двух сводок графиков. Параметр boxplot.summary принимает вектор из одного или двух имен атрибутов.\n\nupset(movies, boxplot.summary = c(\"AvgRating\", \"ReleaseDate\"))\n\n\n\nFigure 10: Под каждым столбцом с пересечениями находится свой элемент диаграммы ящик с усами, он показывает распределение значений по диапозону. Например для фильмо с жанров драма видим, что медиана среднего рейтинга находится между 3 и 4, а медиана даты выхода ближе к 2000 году\n\n\n\n\n\nРазберем параметр query, он часто использовался на предыдущих диаграммах, пора его подробно описать.\n\n\nquery указывает, какой запрос будет выполняться\n\nparams это список параметров, с которыми будет работать запрос\n\ncolor это цвет, который будет представлять запрос на графике. Если цвет не указан, будет выбран цвет из палитры цветов по умолчанию.\n\nactive определяет, как запрос будет представлен на графике. Если значение active равно TRUE, строка размера пересечения будет перекрыта строкой, представляющей запрос. Если значение active равно FALSE, на панели размера пересечения будет размещена точка дрожания.\n\nВ этом примере показано, как использовать встроенный запрос пересечений intersects для поиска или отображения элементов в определенных пересечениях. В этом примере цвет, выбранный для активного запроса, выбран из цветовой палитры по умолчанию.\n\nupset(movies, \n      queries = list(list(query = intersects, params = list(\"Drama\",\"Comedy\", \"Action\"), color = \"orange\", active = T), \n                     list(query = intersects, params = list(\"Drama\"), color = \"red\", active = F), \n                     list(query = intersects, params = list(\"Action\", \"Drama\"), active = T)))\n\n\n\nFigure 11: с помощью запросов подсветили интересующие нас пересечения, где они активированы там цветом выделены столбец гистограммы и столбец на графике пересечений наборов, а где запрос не активирован, то там галочкой показана величина пересечения.\n\n\n\n\n\nЕсли необходимо визуализировать как конкретные значения атрибутов распределяются между пересечениями, то тогда можно использовать запрос элемента elements.\n\nupset(movies, \n      queries = list(list(query = elements, params = list(\"AvgRating\", 3.5, 4.1), color = \"blue\", active = T), \n                     list(query = elements, params = list(\"ReleaseDate\", 1980, 1990, 2000), color = \"red\", active = F)))\n\n\n\nFigure 12: в гистограме пересечений подсветили интересующие нас конкретные значения среднего рейтинга синим цветом и даты выхода фильмов красным цветом\n\n\n\n\n\nВ этом примере показано, как использовать параметр expression для фильтрации подмножества результатов запросов элементов и пересечений.\n\nupset(movies, \n      queries = list(\n        list(query = intersects, params = list(\"Action\", \"Drama\"), active = T), \n        list(query = elements, params = list(\"ReleaseDate\", 1980, 1990, 2000), color = \"red\", active = F)\n        ), \n      expression = \"AvgRating > 3 & Watches > 100\")\n\n\n\nFigure 13: Отфильтровали график по условиям средний рейтинг > 3 и количество просмотров > 100. Далее выделили пересечение жанров экшен и драмы. А также красным цветом показали содержащееся в пересечениях количество фильмов с датами выхода 1980, 1990 и 2000\n\n\n\n\n\n\nMyfunc <- function(row, release, rating) {\n    data <- (row[\"ReleaseDate\"] %in% release) & (row[\"AvgRating\"] > rating)\n}\n\nupset(movies, \n      queries = list(list(query = Myfunc, params = list(c(1970, 1980, 1990, 1999, 2000), 2.5), \n                          color = \"blue\", active = T))\n      )\n\n\n\nFigure 14: На графике подсвечиваем с помощью написанной функции количество фильмов с заданой датой выхода и выше нужного нам рейтинга\n\n\n\n\n\nЧтобы добавить условные обозначения для примененных запросов, можно использовать параметр query.legend. Параметр query.legend задает положение, в котором должна отображаться легенда, либо сверху, либо снизу. Чтобы применить определенное имя к каждому запросу, параметр query.name может использоваться при определении запроса в параметре запросов. Если query.name не задан, то будет использоваться общее название. В приведенном ниже примере показано, как это сделать.\n\nupset(movies, \n      query.legend = \"top\", \n      queries = list(\n        list(query = intersects, params = list(\"Drama\", \"Comedy\", \"Action\"), color = \"orange\", active = T,\n             query.name = \"Funny action\"), \n        list(query = intersects, params = list(\"Drama\"), color = \"red\", active = F), \n        list(query = intersects, params = list(\"Action\", \"Drama\"), active = T, \n             query.name = \"Emotional action\"))\n      )\n\n\n\nFigure 15: График с легендой\n\n\n\n\nОбъединим примененные выше методы\n\nupset(movies, \n      query.legend = \"bottom\", \n      queries = list(\n        list(query = Myfunc, params = list(c(1970, 1980, 1990, 1999, 2000), 2.5), color = \"orange\", active = T), \n        list(query = intersects, params = list(\"Action\", \"Drama\"), active = F), \n        list(query = elements, params = list(\"ReleaseDate\", 1980, 1990, 2000), color = \"red\", active = F,\n             query.name = \"Decades\")), \n      expression = \"AvgRating > 3 & Watches > 100\")\n\n\n\nFigure 16: График с пользовательскими наборами\n\n\n\n\n\nДобавление метаданных задается параметром: set.metadata\nРазберем атрибуты этого параметра:\n\ndata: принимает фрейм данных, где первый столбец - это имена наборов, а следующие столбцы - атрибуты наборов.\nplots: это список, который принимает список параметров, используемых для создания графиков. Эти параметры включают столбец, тип, назначение и цвета.\ncolumn: столбец используемого набора данныхЮ по которому будет строиться график\ntype: это то, какой тип графика следует использовать для отображения данных из указанного столбца. Если данные в столбце числовые, то тип графика может быть либо гистограммой (“hist”), либо тепловой картой (“heat”). Если данные в столбце являются логическими, то типом графика может быть тепловая карта “bool”. Если данные в столбце являются категориальными (символьными), то тип графика может быть либо тепловой картой (“тепло”), либо текстом (“текст”). Кроме того, если данные в столбце порядковые (коэффициентные), то тип графика может быть либо тепловой картой, либо текстом. Существует также тип под названием “matrix_rows”, который позволяет нам использовать применение цветов к фону матрицы с использованием категориальных данных. Этот тип полезен для определения характеристик наборов с использованием матрицы.\nassign: это количество столбцов, которые должны быть назначены конкретному графику. Например, если вы строите 2 набора графиков метаданных, то вы можете выбрать один график, который будет занимать 20 столбцов, а другой - 10 столбцов. Поскольку график смещения обычно наносится на сетку размером 100 на 100, сетка теперь будет иметь размер 100 на 130, где примерно 1/4 участка отводится графикам метаданных.\n\ncolors: используется для указания цветов, используемых в графиках метаданных. Если тип графика - линейчатый график, то параметр принимает только один цвет для всего графика. Если тип графика “heat” или “bool”, то может быть предоставлен вектор цветов, в котором для каждой уникальной категории (символа) есть один цвет. Однако, если тип данных порядковый (фактор), ввод цветов отсутствует, и тепловая карта работает с цветовым градиентом, а не применяет разные цвета к каждому уровню. Наконец, если тип графика - “текст”, то может быть предоставлен вектор цветов, где для каждой уникальной строки есть один цвет. Если цвета не указаны, вам будет предоставлена цветовая палитра.\nВ этом примере в качестве метаданных набора будут использоваться средние рейтинги фильмов Rotten Tomatoes для каждого набора. Это может помочь нам сделать больше выводов из визуализации, зная, как профессиональные рецензенты обычно оценивают фильмы в этих категориях.\n\n\n\nsets <- names(movies[3:19])\navgRottenTomatoesScore <- round(runif(17, min = 0, max = 90))\nmetadata <- as.data.frame(cbind(sets, avgRottenTomatoesScore))\nnames(metadata) <- c(\"sets\", \"avgRottenTomatoesScore\")\n\n# При создании гистограммы с использованием информации метаданных набора важно убедиться, что указанный столбец является числовым.\n# is.numeric(metadata$avgRottenTomatoesScore)\n\n# Столбец не является числовым! На самом деле это фактор, поэтому мы должны преобразовать его в символы, а затем в целые числа.\nmetadata$avgRottenTomatoesScore <- as.numeric(as.character(metadata$avgRottenTomatoesScore))\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"hist\", column = \"avgRottenTomatoesScore\", assign = 20)))\n      )\n\n\n\nFigure 17: График с добавлением метаданных\n\n\n\n\n\nВ этом примере мы составим наши собственные данные о том, в каких крупных городах эти жанры были наиболее популярны. Поскольку это категориальный, а не порядковый номер, мы должны не забыть изменить столбец на символы (это снова фактор). Чтобы убедиться, что мы назначаем определенные цвета каждой категории, вы можете указать название каждой категории в цветовом векторе, как показано ниже. Если вам все равно, какой цвет присвоен каждой категории, то вам не нужно указывать названия категорий в цветовом векторе. R просто применит цвета к каждой категории в том порядке, в котором они встречаются. Кроме того, если вы ничего не укажете для параметра colors, вам будет предоставлена цветовая палитра по умолчанию.\n\nCities <- sample(c(\"Boston\", \"NYC\", \"LA\"), 17, replace = T)\nmetadata <- cbind(metadata, Cities)\nmetadata$Cities <- as.character(metadata$Cities)\n# metadata[which(metadata$sets %in% c(\"Drama\", \"Comedy\", \"Action\", \"Thriller\", \"Romance\")), ]\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"heat\", column = \"Cities\", assign = 10, \n             colors = c(Boston = \"green\", NYC = \"navy\", LA = \"purple\"))))\n      )\n\n\n\nFigure 18: График с добавлением тепловой карты\n\n\n\n\nТеперь давайте также использовать наши числовые значения критики!\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"heat\", column = \"Cities\", assign = 10, \n             colors = c(Boston = \"green\", NYC = \"navy\", LA = \"purple\")), \n        list(type = \"heat\", column = \"avgRottenTomatoesScore\", assign = 10)))\n      )\n\n\n\nFigure 19: График с несколькими тепловыми картами\n\n\n\n\n\nТеперь предположим, что у нас есть метаданные, которые сообщают нам, хорошо ли эти жанры приняты за рубежом. Это может быть использовано в качестве категориального столбца, где есть только две категории, но для этого примера мы предположим, что ваши данные закодированы в 1 и 0. Важно иметь в виду, что если вы запустите “heat” с 0 и 1 вместо “bool”, двоичные данные будут обрабатываться как числовые значения, а цветовой градиент будет использоваться для отображения относительных различий.\n\naccepted <- round(runif(17, min = 0, max = 1))\nmetadata <- cbind(metadata, accepted)\n# metadata[which(metadata$sets %in% c(\"Drama\", \"Comedy\", \"Action\", \"Thriller\", \"Romance\")), ]\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"bool\", column = \"accepted\", assign = 5, colors = c(\"#FF3333\", \"#006400\"))))\n      )\n\n\n\nFigure 20: График с логической тепловой картой\n\n\n\n\nДавайте посмотрим, что произойдет, когда мы выберем “heat” вместо “bool” для нашего столбца двоичных данных.\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"heat\", column = \"accepted\", assign = 5, colors = c(\"red\", \"green\"))))\n      )\n\n\n\nFigure 21: График с тепловой картой\n\n\n\n\nДопустим, мы предпочитаем показывать текст вместо тепловой карты для городов, в которых эти жанры были наиболее популярны.\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"text\", column = \"Cities\", assign = 10, \n             colors = c(Boston = \"green\", NYC = \"navy\", LA = \"purple\"))))\n      )\n\n\n\nFigure 22: График с тепловой картой в виде текста\n\n\n\n\n\nВ некоторых случаях мы можем просто захотеть включить метаданные категориального набора непосредственно в график расслоения, чтобы легко идентифицировать характеристики наборов с помощью матрицы. Для этого нам нужно указать тип как matrix_rows, какой столбец мы используем для категоризации наборов, и цвета, которые будут применяться к каждой категории. Существует также возможность изменить непрозрачность фона матрицы с помощью альфа-кода. Чтобы изменить непрозрачность фона матрицы без применения заданных метаданных, см. параметр shade.alpha в документации к функции disapport().\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"hist\", column = \"avgRottenTomatoesScore\", assign = 20), \n        list(type = \"matrix_rows\", column = \"Cities\", \n             colors = c(Boston = \"green\", NYC = \"navy\", LA = \"purple\"), \n    alpha = 0.5)))\n    )\n\n\n\nFigure 23: Окрашивание пересечений по значениям категорий\n\n\n\n\nОбъединим методы рассмотренные выше на одном графике\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"hist\", column = \"avgRottenTomatoesScore\", assign = 20), \n        list(type = \"bool\", column = \"accepted\", assign = 5, colors = c(\"#FF3333\", \"#006400\")), \n        list(type = \"text\", column = \"Cities\", assign = 5, \n             colors = c(Boston = \"green\", NYC = \"navy\", LA = \"purple\"))))\n      )\n\n\n\nFigure 24: График с совмещенными методами метаданных\n\n\n\n\nА теперь соединим методы добавления метаданных, атрибутов и запросов\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"hist\", column = \"avgRottenTomatoesScore\", assign = 20), \n        list(type = \"bool\", column = \"accepted\", assign = 5, colors = c(\"#FF3333\", \"#006400\")), \n        list(type = \"text\", column = \"Cities\",   assign = 5, colors = c(Boston = \"green\", NYC = \"navy\", LA = \"purple\")), \n        list(type = \"matrix_rows\", column = \"Cities\", colors = c(Boston = \"green\", NYC = \"navy\", LA = \"purple\"), \n             alpha = 0.5))), \n      queries = list(list(query = intersects, params = list(\"Drama\"), color = \"red\", active = F), \n                     list(query = intersects, params = list(\"Action\", \"Drama\"), active = T), \n                     list(query = intersects, params = list(\"Drama\", \"Comedy\", \"Action\"), \n                          color = \"orange\", active = T)), \n      attribute.plots = list(gridrows = 45, plots = list(\n        list(plot = scatter_plot, x = \"ReleaseDate\", y = \"AvgRating\", queries = T), \n        list(plot = scatter_plot, x = \"AvgRating\", y = \"Watches\", queries = F)), ncols = 2), \n      query.legend = \"bottom\")\n\n\n\nFigure 25: методы добавления метаданных, атрибутов и запросов на одном графике"
  }
]