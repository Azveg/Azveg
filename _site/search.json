[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Best Practices IT",
    "section": "",
    "text": "Примеры практик, статьи и описание технологий IT\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDplyr\n\n\n\n\n\n\n\nR\n\n\ndplyr\n\n\ntidyverse\n\n\n\n\nОбзор основного функционала пакета dplyr\n\n\n\n\n\n\nNov 16, 2022\n\n\n31 min\n\n\n\n\n\n\n\n\nQuarto cheat sheet\n\n\n\n\n\n\n\nR\n\n\nQuarto\n\n\ncheatsheet\n\n\n\n\nОписание возможностей Quarto для создания web сайтов и их наполнения\n\n\n\n\n\n\nOct 11, 2022\n\n\n6 min\n\n\n\n\n\n\n\n\nR language\n\n\n\n\n\n\n\n\n\n\n\n\n1 min\n\n\n\n\n\n\n\n\nTibble\n\n\n\n\n\n\n\nR\n\n\ntibble\n\n\ntidyverse\n\n\n\n\nОбзор основного функционала пакета tibble\n\n\n\n\n\n\nFeb 9, 2023\n\n\n20 min\n\n\n\n\n\n\n\n\nUpSet диаграммы - введение\n\n\n\n\n\n\n\nR\n\n\nUpSet\n\n\nHeatmap\n\n\nvisualization\n\n\n\n\nПостроение диаграмм пересечения множеств с помощью UpSet графиков развитие диаграмм Вена на большом количестве анализируемых атрибутов\n\n\n\n\n\n\nOct 18, 2022\n\n\n5 min\n\n\n\n\n\n\n\n\nVisualization\n\n\n\n\n\n\n\n\n\n\n\n\n1 min\n\n\n\n\n\n\n\n\nСоздание графиков в пакете UpSetR\n\n\n\n\n\n\n\nR\n\n\nUpSet\n\n\nvisualization\n\n\n\n\nРассмотрим пакет UpSetR, разберем примеры построения качественных и красивых графиков\n\n\n\n\n\n\nNov 24, 2022\n\n\n24 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html",
    "title": "Dplyr",
    "section": "",
    "text": "Выполним установку пакета dplyr и загрузим набор данных starwars"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#выборка-данных",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#выборка-данных",
    "title": "Dplyr",
    "section": "Выборка данных",
    "text": "Выборка данных\nВ R возможно делать выборку столбцов разными стособами. Просто перечислить названия столбцов или их номера, перечислить какие столбцы не нужно выводить или выводить столбцы с именем соответствующим определенному условию.Выбор с использованием tidyselect рассмотрели выше, теперь рассмотрим ещё пару стандартных способов отбора столбцов.\n\nВернуть вектор\nЕсли нужно вернуть столбец не как таблицу, а вектор, то делаем это через pull\n\n\nstarwars %&gt;% \n  pull('name')\n\n [1] \"Luke Skywalker\"        \"C-3PO\"                 \"R2-D2\"                \n [4] \"Darth Vader\"           \"Leia Organa\"           \"Owen Lars\"            \n [7] \"Beru Whitesun lars\"    \"R5-D4\"                 \"Biggs Darklighter\"    \n[10] \"Obi-Wan Kenobi\"        \"Anakin Skywalker\"      \"Wilhuff Tarkin\"       \n[13] \"Chewbacca\"             \"Han Solo\"              \"Greedo\"               \n[16] \"Jabba Desilijic Tiure\" \"Wedge Antilles\"        \"Jek Tono Porkins\"     \n[19] \"Yoda\"                  \"Palpatine\"             \"Boba Fett\"            \n[22] \"IG-88\"                 \"Bossk\"                 \"Lando Calrissian\"     \n[25] \"Lobot\"                 \"Ackbar\"                \"Mon Mothma\"           \n[28] \"Arvel Crynyd\"          \"Wicket Systri Warrick\" \"Nien Nunb\"            \n[31] \"Qui-Gon Jinn\"          \"Nute Gunray\"           \"Finis Valorum\"        \n[34] \"Jar Jar Binks\"         \"Roos Tarpals\"          \"Rugor Nass\"           \n[37] \"Ric Olié\"              \"Watto\"                 \"Sebulba\"              \n[40] \"Quarsh Panaka\"         \"Shmi Skywalker\"        \"Darth Maul\"           \n[43] \"Bib Fortuna\"           \"Ayla Secura\"           \"Dud Bolt\"             \n[46] \"Gasgano\"               \"Ben Quadinaros\"        \"Mace Windu\"           \n[49] \"Ki-Adi-Mundi\"          \"Kit Fisto\"             \"Eeth Koth\"            \n[52] \"Adi Gallia\"            \"Saesee Tiin\"           \"Yarael Poof\"          \n[55] \"Plo Koon\"              \"Mas Amedda\"            \"Gregar Typho\"         \n[58] \"Cordé\"                 \"Cliegg Lars\"           \"Poggle the Lesser\"    \n[61] \"Luminara Unduli\"       \"Barriss Offee\"         \"Dormé\"                \n[64] \"Dooku\"                 \"Bail Prestor Organa\"   \"Jango Fett\"           \n[67] \"Zam Wesell\"            \"Dexter Jettster\"       \"Lama Su\"              \n[70] \"Taun We\"               \"Jocasta Nu\"            \"Ratts Tyerell\"        \n[73] \"R4-P17\"                \"Wat Tambor\"            \"San Hill\"             \n[76] \"Shaak Ti\"              \"Grievous\"              \"Tarfful\"              \n[79] \"Raymus Antilles\"       \"Sly Moore\"             \"Tion Medon\"           \n[82] \"Finn\"                  \"Rey\"                   \"Poe Dameron\"          \n[85] \"BB8\"                   \"Captain Phasma\"        \"Padmé Amidala\"        \n\n\n\n\nСтолбцы\n\nПеречисление\n\nstarwars %&gt;% \n  select(name)\n\n\n\n  \n\n\n\n\n\nОтрицательное перечисление\nЕсли нужно указать какой столбец не включать в выборку то ставится знак минус:\n\nstarwars %&gt;% \n  select(-c(name, mass))\n\n\n\n  \n\n\n\n\n\nПо номерам\nИли можно указать номера столбцов\n\nstarwars %&gt;% \n  select(1, 2)\n\n\n\n  \n\n\n\n\n\nУпорядочивание столбцов\n\nrelocate\nrelocate(.data, …, .before = NULL, .after = NULL) - смена позиции столбца, использует иснтаксис select(включая tidy-select) чтобы легко перемещать один или несколько столбоц за один раз\n\n.data - указываем, что переместить\n.before - перемещение до и указваем столбец или выражение tidy-select\n.after - перемещение после и указваем столбец или выражение tidy-select\n\n\n\n\ndf &lt;- tibble(a = 1, d = \"a\", b = 1, f = \"a\")\ndf\n\n\n\n  \n\n\n\n\n# ставим стоблец f в начало\ndf %&gt;% relocate(f)\n\n\n\n  \n\n\n\n\n# ставим стоблец a после d\ndf %&gt;% relocate(a, .after = d)\n\n\n\n  \n\n\n\n\n# ставим стоблец f перед b\ndf %&gt;% relocate(f, .before = b)\n\n\n\n  \n\n\n\n\n\nИ ещё несколько вариантов используя tidy-select\n\n\n\n# числовые столбцы в конец\ndf %&gt;% \n  relocate(where(is.numeric), \n           .after = last_col())\n\n\n\n  \n\n\n\n\n# если есть столбцы с такими названиями\n# то их ставим вначало\ndf %&gt;% \n  relocate(any_of(c(\"a\", \"e\", \"i\", \"o\", \"u\")))\n\n\n\n  \n\n\n\n\n# числовые столбцы после символьных\ndf %&gt;% \n  relocate(where(is.numeric), \n           .after = where(is.character))\n\n\n\n  \n\n\n\n\n\n\n\n\n\nСтроки\n\nУникальные значения\n\nstarwars %&gt;% \n  distinct(sex)\n\n\n\n  \n\n\n\n\n\nСлучайные строки\n\nsample_n\nВозвращаем n - случайных строк\n\nstarwars %&gt;% \n  sample_n(5)\n\n\n\n  \n\n\n\n\n\nsample_frac\nЕсли нужно указать долю строк из общего числа, которые должны быть в итоговой таблице, то используем sample_frac. Например, при параметре 0.5 вернется половина строк из таблицы, выбранные случайным образом.\n\nstarwars %&gt;% \n  sample_frac(0.1)\n\n\n\n  \n\n\n\n\n\n\nСрезы\nФункции slice позволяют сделать срез из выборки данных по условию, рассмотрим аргументы функций:\n\nn, prop - задает количество (n) или пропорцию (prop) выбираемых строк, по умолчанию n = 1. Если указано отрицательное значение n или prop, указанное количество или пропорция строк будут удалены. Если n больше, чем количество строк в группе (или prop &gt; 1), результат будет автоматически усечен до размера группы. Если доля размера группы не дает целого числа строк, абсолютное значение prop * nrow(.data) округляется в меньшую сторону.\nwith_ties - указывает нужно ли включать в выборку дубликаты по выбранному столбцу\nweight_by - задает взвешенную случайную выборку фрейма данных т.е. задает вероятность включения каждой строки в результирующее подмножество, которая будет пропорциональна значениям в указанном столбце. Указав вес столбца, можно гарантировать, что более важные строки с большей вероятностью попадут в выборку. Используется когда нужно сделать репрезентативную выборку для исследования.\nreplace - указывает нужно ли переписывать текущий фрейм, если значение TRUE, то текущий фрейм сразу заменяется результатом выборки, если FALSE, то выборка возвращается как новый фрейм данных, без изменения исходного фрейма.\n\nСоздадим набор данных для описания возможностей работы со срезами\n\ndf &lt;- tribble(\n  ~key, ~val_y, ~val_x,\n     1, \"y1\",   6,\n     2, \"y2\",   1,\n     3, \"y3\",   3,\n     4, \"y4\",   9,\n     5, \"y5\",   2,\n     6, \"y6\",   7,\n     7, \"y7\",   4,\n     8, \"y8\",   10,\n     9, \"y9\",   5,\n     9, \"y10\",  8 \n)\ndf\n\n\n\n  \n\n\n\n\n\nslice\nslice(.data, ..., .preserve = FALSE)\nФункция slice() позволяет выбирать строки из фрейма данных на основе их положения. Функция принимает два аргумента, первый из которых является фреймом данных, а второй - диапазоном строк для выбора. Диапазон задается с помощью оператора : и может быть одним значением или диапазоном значений.\n\n\n\ndf %&gt;% \n  slice(1:n()) \n\n\n\n  \n\n\n\n\ndf %&gt;% \n  slice(1:4) \n\n\n\n  \n\n\n\n\ndf %&gt;% \n  slice(1L)\n\n\n\n  \n\n\n\n\n\n\n\n\nslice_head\nslice_head(.data, ..., n, prop)\nФункция slice_head() аналогична функции slice(), но выбирает первые n строк фрейма данных. Функция принимает два аргумента, первый из которых является фреймом данных, а второй - количеством строк для выбора.\n\n\n\ndf %&gt;% \n  slice_head(n = 5) \n\n\n\n  \n\n\n\n\ndf %&gt;% \n  slice_head(prop = 0.2) \n\n\n\n  \n\n\n\n\n\n\n\n\nslice_tail\nslice_tail(.data, ..., n, prop)\nФункция slice_tail() аналогична функции slice(), но выбирает последние n строк фрейма данных. Функция принимает два аргумента, первый из которых является фреймом данных, а второй - количеством строк для выбора.\n\n\n\ndf %&gt;% \n  slice_tail(n = 5) \n\n\n\n  \n\n\n\n\ndf %&gt;% \n  slice_tail(prop = 0.1) \n\n\n\n  \n\n\n\n\n\n\n\n\nslice_min\nslice_min(.data, order_by, ..., n, prop, with_ties = TRUE)\nФункция slice_min() используется для выбора строк с минимальными значениями указанного столбца.\n\ndf %&gt;% \n  slice_min(key, n = 2) \n\n\n\n  \n\n\n\n\n\n\nslice_max\nslice_max(.data, order_by, ..., n, prop, with_ties = TRUE)\nФункция slice_max() используется для выбора строк с максимальными значениями указанного столбца. Функция принимает аргументы, первый из которых является фреймом данных, а второй - столбцом для выбора.\n\n\n\ndf %&gt;% \n  slice_max(key, n = 3) \n\n\n\n  \n\n\n\n\ndf %&gt;% \n  slice_max(key, n = 1, with_ties = T) \n\n\n\n  \n\n\n\n\ndf %&gt;% \n  slice_max(key, n = 1, with_ties = F) \n\n\n\n  \n\n\n\n\n\n\n\n\nslice_sample\nslice_sample(.data, ..., n, prop, weight_by = NULL, replace = FALSE)\nФункция slice_sample() используется для выбора случайной выборки строк из фрейма данных. Функция принимает аргументы, первый из которых является фреймом данных, а второй - количеством строк для выбора.\n\n\n\ndf %&gt;% \n  slice_sample(n = 4) \n\n\n\n  \n\n\n\n\ndf %&gt;% \n  slice_sample(n = 4, weight_by = val_x)"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#фильтрация-строк",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#фильтрация-строк",
    "title": "Dplyr cheat sheet",
    "section": "Фильтрация строк",
    "text": "Фильтрация строк\nПо логическому условию\n\nstarwars %>% \n  filter(mass > 50)\n\n\n\n  \n\n\n#комбинировать несколько условий можно с помощью & и |:\nstarwars %>% \n  filter(mass > 50 & height > 170)\n\n\n\n  \n\n\n\nКонструировать логические условия можно и другими операторами\n\n>=\n<=\nis.na\n!is.na\n%in%\n!\nbetween\nnear\nxor\n\n\nstarwars %>% \n  filter(skin_color %in% c('fair', 'green'))"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#сортировка-строк",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#сортировка-строк",
    "title": "Dplyr cheat sheet",
    "section": "Сортировка строк",
    "text": "Сортировка строк\nДля сортировки в языке есть достаточно широкие возможности. Вот самые основные виды сортировки:\nПо возрастанию\n\nstarwars %>% \n  arrange(mass)\n\n\n\n  \n\n\n\nПо убыванию\n\n# сортировка по убыванию\nstarwars %>% \n  arrange(desc(mass))\n\n\n\n  \n\n\n\nПо нескольким столбцам\n\n# сортировка по нескольким столбцам\nstarwars %>% \n  arrange(height, desc(mass))\n\n\n\n  \n\n\n\nРасширенная сортировка\nПри сортировке можно использовать вспомогательные функции для select, только внутри функции across\n\nstarwars %>% \n  arrange(across(ends_with('_color'), desc))"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#группировка-и-агрегатные-функции",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#группировка-и-агрегатные-функции",
    "title": "Dplyr cheat sheet",
    "section": "Группировка и агрегатные функции",
    "text": "Группировка и агрегатные функции\n\n# сама по себе группировка не несет смысла, только в сочетании с агрегирующими функциями\nstarwars %>% \n  group_by(eye_color)\n\n\n\n  \n\n\n\n\nstarwars %>% \n  group_by(eye_color) %>% # группируем по полю\n  summarise(\n    'mean mass' = mean(mass), # задаем имя столбцу и применяем функцию\n    'max mass' = max(mass),\n    'min mass' = min(mass),\n    'first mass' = first(mass),\n    'median mass' = median(mass),\n    'quantity' = n()\n  )\n\n\n\n  \n\n\n# про другие функции summarise в ?summarise\n\nРассчитать показатели только для нескольких столбцов сразу\n\nstarwars %>% \n  group_by(eye_color) %>% \n  summarise(\n    across(\n      .cols = c(mass, height), # столбцы к котторым применятся функции\n      .fns = list(mean = mean, max = max, min = min, first = first, median = median), # набор функций\n      .names = \"{.col}.fn_{.fn}\"  # шаблон имени столбца\n    )\n  )"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#вычисляемые-столбцы",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#вычисляемые-столбцы",
    "title": "Dplyr",
    "section": "Вычисляемые столбцы",
    "text": "Вычисляемые столбцы\n\nmutate\nmutate(.data, ..., .by = NULL, .keep = c(\"all\", \"used\", \"unused\", \"none\"), .before = NULL, .after = NULL)\nФункция создает новый столбец на основе существующих переменных, а также может изменяет текущий столец (если имена равны) или удалять столбцы (устанавливая их значение равным NULL)\nАргументы:\n\n.by - пока статус в жизненном цикле пакета [Experimental], будет альтернативой group_by()\n.before \\ .after - указывает место где расположить созданный\\измененный столбец, этот агрумент также рассматривался в функции relocate\n.keep - указывает какие столбцы останутся в выходных данных после применения функции\n\nall - сохраняет все столбцы из .data, используется по умолчанию\nused - сохраняет только столбцы, используемые в функции, чтобы создать новый столбец. Это полезно для проверки работы, так как при этом входные и выходные данные отображаются параллельно\nunused - сохраняет только те столбцы, в которые не используется в функции, чтобы создать новые столбцы. Это полезно, если вы создаете новые столбцы, но столбцы, использованные для их создания, больше не нужны\nnone - сохраняет только группирующие переменные и столбцы созданные с помощью mutate\n\n\nРассмотрим простой пример создания нового столбца:\n\n\n\nstarwars %&gt;% \n  select(name, height, mass) %&gt;% \n  mutate('coef' = mass/height, .keep = \"all\")\n\n\n\n  \n\n\n\n\nstarwars %&gt;% \n  select(name, height, mass) %&gt;% \n  mutate('coef' = mass/height, .keep = \"used\")\n\n\n\n  \n\n\n\n\n\n\n\n\nstarwars %&gt;% \n  select(name, height, mass) %&gt;% \n  mutate('coef' = mass/height, .keep = \"unused\")\n\n\n\n  \n\n\n\n\nstarwars %&gt;% \n  select(name, height, mass) %&gt;% \n  mutate('coef' = mass/height, .keep = \"none\")\n\n\n\n  \n\n\n\n\n\nС mutate применяются следующие функции:\n\nОконные функции:\n\nlead(), lag()\ndense_rank(), min_rank(), percent_rank(), row_number(), cume_dist(), ntile()\ncumsum(), cummean(), cummin(), cummax(), cumany(), cumall()\n\nОбработка Null: na_if(), coalesce()\nУсловные функции: if_else(), recode(), case_when()\n\n\n\nrename | rename_with\nrename(.data, ...) - переименновывает отдельные столбцы\nrename_with(.data, .fn, .cols = everything(), ...) - переименновывает несколько столбцов с помощью функции\n.cols - использует синтаксис tidy-select\nПриведем простые примеры изменения наименований, в первом случае через функцию rename переименуем mass на weight, во втором все имена заканчивающиеся на “…color” сделаем верхним регистром\n\n\n\nstarwars %&gt;% \n  select(name, height, mass) %&gt;%\n  rename(weight = mass)\n\n\n\n  \n\n\n\n\nstarwars %&gt;% \n  select(name, hair_color, skin_color, eye_color) %&gt;% \n  rename_with(toupper, ends_with(\"color\"))\n\n\n\n  \n\n\n\n\n\n\n\nacross\nФункция позволяет применить одно и то же преобразование к нескольким столбцам\nacross(.cols, .fns, ..., .names = NULL, .unpack = FALSE)\nАргументы функции:\n\n.cols - столбцы к которым нужно применить функцию, для выбрки доступен tidyselect\n.fns - применяемая функция\n.names - спецификация имен после применения функции, можно использовать {.col} для обозначения имени выбранного столбца и {.fn} для обозначения имени применяемой функции. По умолчанию “{.col}” для случая с одной функцией и “{.col}_{.fn}” для случая, когда для .fns используется список функций.\n\nПример с mutate:\nВыберем несколько числовых столбцов и применим к ним округление\n\nstarwars %&gt;% \n  mutate(across(c(2,3), round) )\n\n\n\n  \n\n\n\nПример с summarise:\nВ этом примере выберем два числовых столбца, применим к ним функции среднего и стандартного отклонения, также зададим спецификацию имен как: “название_столбца.название_функции”\n\nstarwars %&gt;% \n  group_by(skin_color) %&gt;% \n  summarise(\n    across(c(height, mass), list(mean = mean, sd = sd), .names = \"{.col}.{.fn}\"))\n\n\n\n  \n\n\n\n\n\nif_any | if_all\nФункции применяют одну и ту же функцию к нескольким столбцам и объединяют результаты в единый логический вектор\nif_any(.cols, .fns, ..., .names = NULL) - имеет значение TRUE, когда предикат имеет значение TRUE для любого из выбранных столбцов\nif_all(.cols, .fns, ..., .names = NULL) - имеет значение TRUE, когда предикат имеет значение TRUE для всех выбранных столбцов\nВыполним три запроса: - базовый запрос, чтобы сформировать первоначальную выборку - второй запрос в котором применим функцию if_any - третий запрос в котором применим функцию if_all\nДля обоих функций условия будут идентичные: во всех столбцах с типом double отбираем строки со значениями меньше 40.\n\n\n\nstarwars %&gt;% \n  select(name, mass, birth_year) %&gt;% \n  slice(1:10)\n\n\n\n  \n\n\n\n\nstarwars %&gt;% \n  select(name, mass, birth_year) %&gt;% \n  slice(1:10) %&gt;% \n  filter(if_any(where(is.double), ~ . &lt; 40))\n\n\n\n  \n\n\n\n\nstarwars %&gt;% \n  select(name, mass, birth_year) %&gt;% \n  slice(1:10) %&gt;% \n  filter(if_all(where(is.double), ~ . &lt; 40))"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#оконные-функции",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#оконные-функции",
    "title": "Dplyr",
    "section": "Оконные функции",
    "text": "Оконные функции\n\nФормирование окна функции\nЕсли вы привыкли писать код на SQL, то при упониминании оконной функции в голове возникает следующая модель:\n```{sql}\nSelect *\n  ,SUM(col_1) # любая агрегатная функция\n    OVER ( # ключевое слово описания окна\n          PARTITION BY col_2 # формируем группы\n          ORDER BY col_3 # сортируем данные внутри группы\n          RANGE | ROWS | GROUPS UNBOUNDED PRECEDING # задаем начало и конец рамки окна\n          )\nFrom table\n```\nПереходя на R нужно переключиться на другие концепции, но постоянно будут возникать вопросы, наподобии: понятно как это сделать на SQL, но как это реализовать в концепции языка?\nПопробуем разобраться как переложить на концепцию на синтаксис языка R\nДля этого нужно перевести набор данных во временную таблицу, как будто это таблица из базы данных. У такого преобразования есть особенности, перевести можно набор данных, который содержит столбцы с поддерживаемыми типами данных в базе данных.\nПоэтому неполучится перевести во временную таблицу набор starwars как есть из-за того, что он содержит тип list, сначала исключим из выборки столбцы с данным типом и преобразуем набор:\n\nmy_db &lt;- DBI::dbConnect(RSQLite::SQLite(), \":memory:\")\n\nstarwars_db &lt;- copy_to(my_db, starwars %&gt;% select(!where(is.list)), name = \"starwars_db\", overwrite = FALSE)\n\nИ уже после этого можно смотреть как выглядит запрос на языке R в терминах SQL, например:\n\nstarwars_db %&gt;% \n  arrange(mass) %&gt;% \n  filter(species == 'Human') %&gt;% \n  show_query()\n\n&lt;SQL&gt;\nSELECT *\nFROM `starwars_db`\nWHERE (`species` = 'Human')\nORDER BY `mass`\n\n\nОписать несколько решений через slider и dbplyr\nТакже сделать примеры реализации на SQL и сравнение реализации через другие пакеты\nВозможно стоит сначала описать базовое формирование окна и потом в каждой функции ракрывать её применение\n\n\nOffset\nФункции позволяющие расчитать смещение по строкам\nАргументы функций\n\nx - вектор, который будем перебирать\nn - положительное число, задающее смещение относительно текущей строки, по умолчанию единица\ndefault - если при смещении не найдено значение, то по умолчанию ставится Null, можно задать своё значение\norder_by - необязательное условие, сортировки вектора по дополнительному вектору, после применения смещения, т.е. сначала применили смещение, а потом отсортировали результат\n\n\nlag\nФункция задает смещение назад по вектору\nlag(x, n = 1L, default = NULL, order_by = NULL, ...)\nРассмотрим смещение с разным набором атрибутов\n\nstarwars %&gt;% \n  select(1:3) %&gt;% slice(1:10) %&gt;% \n  mutate(name_lag  = lag(name)) %&gt;% \n  mutate(name_lag2 = lag(name, n = 2)) %&gt;% \n  mutate(name_lag3 = lag(name, n = 3, default = 'Frodo')) %&gt;% \n  mutate(name_lag4 = lag(name, n = 3, order_by = mass))\n\n\n\n  \n\n\n\n\n\nlead\nФункция задает смещение вперед по вектору\nlead(x, n = 1L, default = NULL, order_by = NULL, ...)\nРассмотрим смещение с разным набором атрибутов\n\nstarwars %&gt;% \n  select(1:3) %&gt;% slice(1:10) %&gt;% \n  mutate(name_lag  = lead(name)) %&gt;% \n  mutate(name_lag2 = lead(name, n = 2)) %&gt;% \n  mutate(name_lag3 = lead(name, n = 3, default = 'Frodo')) %&gt;% \n  mutate(name_lag4 = lead(name, n = 3, order_by = mass))\n\n\n\n  \n\n\n\n\n\n\nCumulative\n\ncumall | cumany\nФункции создают логические вектора с накопительным эффектом, т.е. до первого события\nКак интерпретировать функции:\n\ncum all(x): все случаи до первого FALSE\ncumall(!x): все случаи до первого значения TRUE\ncumany(x) : все случаи после первого TRUE\ncumany(!x): все случаи после первого FALSE\n\nПрименение этих функций полезно с сочетании с фильтром, для того чтобы разделить выборку на до и после какого-то события и оставить либо часть, которая была ДО или часть после\n\ndf &lt;- data.frame(\n  x = c(1, 3, 5, 2, 2)\n)\n\ndf %&gt;% \n  mutate(cumall = cumall(x &lt; 5)) %&gt;% \n  mutate(not_cumall = cumall(!(x &lt; 5))) %&gt;% \n  mutate(cumany = cumany(x &lt; 5)) %&gt;% \n  mutate(not_cumany = cumany(!(x &lt; 5)))\n\n\n\n  \n\n\n\n\n\ncummean\nФункция вычисляет среднее значение накопительным итогом\n\ndf &lt;- data.frame(\n  x = c(1, 3, 5, 2, 2)\n)\n\ndf %&gt;% \n  mutate(cummean = cummean(x))\n\n\n\n  \n\n\n\nСледующие функции cummax, cummin, cumprod и cumsum относятся к базовому пакету R, но они также важны при рассмотрении оконных функций\n\n\ncummax\nФункция cummax определяет максимальное значение найденое в векторе к текущему элементу\n\ndf &lt;- data.frame(\n  x = c(1, 3, 5, 2, 2)\n)\n\ndf %&gt;% \n  mutate(cummax = cummax(x))\n\n\n\n  \n\n\n\n\n\ncummin\nФункция cummin определяет минимальное значение найденое в векторе к текущему элементу\n\ndf &lt;- data.frame(\n  x = c(1, 3, 5, 2, 2)\n)\n\ndf %&gt;% \n  mutate(cummin = cummin(x))\n\n\n\n  \n\n\n\n\n\ncumprod\nФункция cumprod перемножает элементы вектора накопительным итогом\n\ndf &lt;- data.frame(\n  x = c(1, 3, 5, 2, 2)\n)\n\ndf %&gt;% \n  mutate(cumprod = cumprod(x))\n\n\n\n  \n\n\n\n\n\ncumsum\nФункция cumsum суммирует элементы вектора накопительным итогом\n\ndf &lt;- data.frame(\n  x = c(1, 3, 5, 2, 2)\n)\n\ndf %&gt;% \n  mutate(cumsum = cumsum(x))\n\n\n\n  \n\n\n\n\n\n\nRanking\n\ncume_dist\nФункция cume_dist() подсчитывает общее количество значений, меньшее или равное i-му значению, и делит его на количество наблюдений\nРассмотрим пример по строчно:\n\nx = 1 - меньше или равно 1, только одно значение, а длина вектора 5 отсюда 1 / 5 = 0.2\nx = 3 - - меньше или равно 3, четыре значения, а длина вектора 5 отсюда 4 / 5 = 0.8\nx = 5 - - меньше или равно 5, пять значений, а длина вектора 5 отсюда 5 / 5 = 1\nx = 2 - - меньше или равно 2, три значения, а длина вектора 5 отсюда 3 / 5 = 0.6\n\n\ndf &lt;- data.frame(\n  x = c(1, 3, 5, 2, 2)\n)\n\ndf %&gt;% \n  mutate(cume_dist = cume_dist(x))\n\n\n\n  \n\n\n\n\n\npercent_rank\n\n\ndense_rank\n\n\nmin_rank\n\n\nntile\n\n\nrow_number"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#обработка-null",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#обработка-null",
    "title": "Dplyr cheat sheet",
    "section": "Обработка null",
    "text": "Обработка null\ncoaleasce\nna_if"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#объединение-таблиц",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#объединение-таблиц",
    "title": "Dplyr",
    "section": "Объединение таблиц",
    "text": "Объединение таблиц\nВ процессе объединения таблиц можно выделить операции трех видов:\n\nMutating joins, которые добавляют новые переменные в один фрейм данных из совпадающих наблюдений в другом.\nFiltering joins, которые фильтруют наблюдения из одного фрейма данных на основе того, соответствуют ли они наблюдению в другой таблице.\nSet operations, эти операции работают с пересечениями двух фреймов\n\nДля разбора операций соединения, загрузим набор данных nycflights13\n```{r}\nlibrary(nycflights13)\n```\n\nКлючи соединения\n\nСопоставление ключей\nПри соединении фреймов данных нужно указать ключи соединения иногда это может быть один ключ или набор ключей, они могут совпадать по наименованию или различаться. Давайте рассмотрим разные варианты.\n\nСоединить по всем совпадающим полям\nЧтобы соединить по всем совпадающим по названию полям, нужно оставить by = NULL\n\nflights2 %&gt;% \n  left_join(weather)\n\nJoining with `by = join_by(year, month, day, origin, hour, time_hour)`\n\n\n\n\n  \n\n\n\n\n\n\nСоединить по одному ключу\nСоединение по одному ключу с общим для обоих фреймов названием:\n\nflights2 %&gt;% \n  left_join(planes, by = \"tailnum\")\n\n\n\n  \n\n\n\n\n\n\nСоединить по нескольким ключам\n\nby = c(“a” = “b”) -&gt; x$a == y$b - соединить с помощью разных переменных на x и y, используется именованный вектор.\nby = c(“a”, “b”) -&gt; x$a == y$a and x$b == y$b - соединить по нескольким переменным\nby = c(“a” = “b”, “c” = “d” -&gt; x$a == y$b and x$c  == y$d - соединить сопоставив раличные переменные из двух фреймов\n\n\nflights2 %&gt;% \n  left_join(airports, c(\"dest\" = \"faa\"))\n\n\n\n  \n\n\n\n\n\n\nПроблемы с ключами\nНе всегда бывает так, что значения в ключевом столбце уникальные. Когда соединяются дублированные ключи, получаются все возможные комбинации, декартово произведение. В функции Join нет никакой обработки таких случаев, поэтому нужно быть внимательным к своим данным и проверять результирующий набор данных. А также при необходимости удалять дублирующие строки.\nУбедитесь, что ваши внешние ключи совпадают с первичными ключами в другой таблице. Лучший способ сделать это - с помощью anti_join(). Часто ключи не совпадают из-за ошибок ввода данных. Их устранение часто требует большой работы.\n\n\n\nMutating joins\nВ принципе это самые обычные и привычные Join-ы, которые мы используем каждый день. Рассмотрим аргументы этих функций:\n\nx, y - пара фреймов данных, которые нужно соединить\nby - вектор переменных в котором задаются ключи\nsuffix - добавляет суффиксы для одноименных не ключевых полей\nkeep - указывает, нужно ли сохранять ключевые поля в результирующем фрейме данных\nna_matches - задает считать или нет равными значения NA и NaN, по умолчанию “na” считаются равными, “never” - исчтать не равными\n\nЧтобы понять суть разных типов соединений, создадим два тестовых фрейма данных и проиллюстрируем на их примере каждый тип:\n\nx &lt;- tribble(\n  ~key, ~val_x,\n     1, \"x1\",\n     2, \"x2\",\n     3, \"x3\"\n)\ny &lt;- tribble(\n  ~key, ~val_y,\n     1, \"y1\",\n     2, \"y2\",\n     4, \"y3\"\n)\n\nx\ny\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n\n\n\n\n\nInner join\nВнутреннее соединение сопоставляет пары наблюдений всякий раз, когда их ключи равны.Наиболее важным свойством внутреннего соединения является то, что несогласованные строки не включаются в результат. Это означает, что, как правило, внутренние соединения обычно не подходят для использования в анализе, потому что слишком легко потерять наблюдения.\n```{r}\ninner_join(\n  x,\n  y,\n  by = NULL,\n  copy = FALSE,\n  suffix = c(\".x\", \".y\"),\n  ...,\n  keep = FALSE,\n  na_matches = c(\"na\", \"never\")\n)\n```\n\n\n\nx\n\n\n\n  \n\n\n\n\ny\n\n\n\n  \n\n\n\n\n\n\n\ninner_join\n\n\n\n\ninner_join(x, y, by = \"key\")\n\n\n\n  \n\n\n\n\n\n\n\nOuter joins\nВнешнее соединение сохраняет наблюдения, которые отображаются по крайней мере в одной из таблиц.\n\nLeft Join\nleft_join - сохраняет все строки из первой таблицы и соединяет все совпавшие по ключу строки из второй таблицы.\nНаиболее часто используемым соединением является левое соединение: его используют всякий раз, когда просматривают дополнительные данные из другой таблицы, потому что оно сохраняет исходные наблюдения, даже если совпадения нет. Левое соединение должно быть соединением по умолчанию: используйте его, если у нет веских причин предпочесть одно из других.\n```{r}\nleft_join(\n  x,\n  y,\n  by = NULL,\n  copy = FALSE,\n  suffix = c(\".x\", \".y\"),\n  ...,\n  keep = FALSE,\n  na_matches = c(\"na\", \"never\")\n)\n```\nРазберем подробнее левое соединение:\n\n\n\nx\n\n\n\n  \n\n\n\n\ny\n\n\n\n  \n\n\n\n\n\n\n\nleft_join\n\n\n\n\nleft_join(x, y, by = \"key\")\n\n\n\n  \n\n\n\n\n\n\n\nRight Join\nright_join - сохраняет все строки из второй таблицы и соединяет все совпавшие по ключу строки из первой таблицы\n```{r}\nright_join(\n  x,\n  y,\n  by = NULL,\n  copy = FALSE,\n  suffix = c(\".x\", \".y\"),\n  ...,\n  keep = FALSE,\n  na_matches = c(\"na\", \"never\")\n)\n```\n\n\n\nx\n\n\n\n  \n\n\n\n\ny\n\n\n\n  \n\n\n\n\n\n\n\nright_join\n\n\n\n\nright_join(x, y, by = \"key\")\n\n\n\n  \n\n\n\n\n\n\n\nFull Join\nfull_join - сохраняет все строки из обоих таблиц\n```{r}\nfull_join(\n  x,\n  y,\n  by = NULL,\n  copy = FALSE,\n  suffix = c(\".x\", \".y\"),\n  ...,\n  keep = FALSE,\n  na_matches = c(\"na\", \"never\")\n)\n```\n\n\n\nx\n\n\n\n  \n\n\n\n\ny\n\n\n\n  \n\n\n\n\n\n\n\nfull_join\n\n\n\n\nfull_join(x, y, by = \"key\")\n\n\n\n  \n\n\n\n\n\n\n\n\n\nFiltering joins\nФильтрующие соединения используются для фильтрации первого фрейма на основе данных из второго фрейма данных.\n\nsemi_join\nsemi_join соединяет две таблицы подобно мутирующему соединению, но вместо добавления новых столбцов сохраняет только те строки в x, которые совпадают в y.\n\n\n\nx\n\n\n\n  \n\n\n\n\ny\n\n\n\n  \n\n\n\n\n\n\n\nsemi_join\n\n\n\n\nsemi_join(x, y, by = \"key\")\n\n\n\n  \n\n\n\n\n\nВажно только наличие совпадения; не имеет значения, какому наблюдению соответствует. Это означает, что фильтрующие соединения никогда не дублируют строки, как это делают мутирующие соединения.\n\n\nanti_join\nАнтисоединения полезны для диагностики несоответствий соединений. Например, так можно делать проверку полноты данных по эталонным справочникам:\n\n\n\nx\n\n\n\n  \n\n\n\n\ny\n\n\n\n  \n\n\n\n\n\n\n\nanti_join\n\n\n\n\nanti_join(x, y, by = \"key\")\n\n\n\n  \n\n\n\n\n\n\n\nnest_join\nnest_join() возвращает все строки и столбцы в x с новым столбцом в каждой строке которого вложен фрейм, содержащий все совпадения из y. Если совпадений нет, то фрейм будет пустой.\n\n\n\nx\n\n\n\n  \n\n\n\n\ny\n\n\n\n  \n\n\n\n\nnest_join(x, y, by = \"key\")\n\n\n\n  \n\n\n\n\nnest_join(x, y, by = \"key\") %&gt;% \n  unnest(cols = c(y))\n\n\n\n  \n\n\n\n\n\n\n\n\nSet operations\nОперации с наборами требуют чтобы соединяемые фреймы данных имели одинаковое количество столбцов, эти функции объединяют два фрейма данных как бы складывая их друг под друга.\nСоздадим два фрейма, чтобы показать работу этих функций:\n\ndf1 &lt;- tribble(\n  ~x, ~y,\n   1,  1,\n   2,  1\n)\ndf2 &lt;- tribble(\n  ~x, ~y,\n   1,  1,\n   1,  2\n)\n\n\nunion\n\nunion - оставляет только уникальные строки из обоих наборов\nunion_all - оставляет все строки из обоих наборов\n\n\n\n\ndf1\n\n\n\n  \n\n\n\n\ndf2\n\n\n\n  \n\n\n\n\nunion(df1, df2)\n\n\n\n  \n\n\n\n\nunion_all(df1, df2)\n\n\n\n  \n\n\n\n\n\n\n\nintersect\nоставляет только совпавшие строки из обоих наборов:\n\n\n\ndf1\n\n\n\n  \n\n\n\n\ndf2\n\n\n\n  \n\n\n\n\n\n\n\nintersect\n\n\n\n\nintersect(df1, df2)\n\n\n\n  \n\n\n\n\n\n\n\nsetdiff\nоставляет строки из первого фрейма только не совпавшие со строками из второго фрейма\n\n\n\ndf1\n\n\n\n  \n\n\n\n\ndf2\n\n\n\n  \n\n\n\n\n\n\n\nintersect\n\n\n\n\nsetdiff(df1, df2)\n\n\n\n  \n\n\n\n\nsetdiff(df2, df1)"
  },
  {
    "objectID": "r_language/Tutorial/Quarto_cheatsheet.html",
    "href": "r_language/Tutorial/Quarto_cheatsheet.html",
    "title": "Quarto cheat sheet",
    "section": "",
    "text": "toc: true|false - включение/отключение отображения содержания страницы\ntoc-depth: 2 - глубина отображаемых заголовков в содержании\ntoc-title: Contents - заголовок содержания\ntoc-location: left - положение содержания\n\n\n\n\nВ блоке кода опции можно задавать через комментарий вида: #|, вот некоторые опции:\n\necho: true|false - показать\\скрыть код\ninclude: false - показать\\скрыть результат работы кода\nwarning: true|false - показать\\скрыть предупреждения\nerror: true|false - показать\\скрыть ошибки при выполнении\ncode-fold: true - добавить опцию свернуть\\развернуть код\ncode-summary: \"Show the code\" - заголовок свернутого блока кода\ncode-overflow: wrap|scroll - добавляет скролл или перенос по словам для длинных строк кода\n\n\n\n\nОписание вариантов размещения изображений и графиков приведено в статье1."
  },
  {
    "objectID": "visualization/Diagramms/Upset/diagramm_upsetr.html",
    "href": "visualization/Diagramms/Upset/diagramm_upsetr.html",
    "title": "UpSet диаграммы - введение",
    "section": "",
    "text": "Понимание взаимосвязей между атрибутами изучаемого набора данных является важной задачей анализа. Основной проблемой в этом контексте является комбинаторный взрыв числа пересечений множеств, если количество множеств превышает тривиальный порог. Наиболее распространенный подход к визуализации наборов – Диаграммы Венна - не масштабируется дальше трех или четырех наборов.\nГрафики UpSet дают возможность проводить анализ взаимосвязей гораздо большего числа атрибутов.\n\n\nUpSet лучше всего работает для наборов данных, содержащих более трех и менее 30 наборов. Для менее чем 4 наборов лучшим выбором может быть пропорциональная площади диаграмма Венна, поскольку они более привычны пользователям.\nUpSet хорошо подходит для анализа распределений и свойств многих элементов. Элементы абстрагируются как “count”, хотя атрибуты элементов могут быть визуализированы в виде интегрированных или смежных графиков.\nкогда вы хотите посмотреть на все комбинации пересечений множеств. Если вы хотите посмотреть на попарные пересечения между наборами, лучшим выбором может быть какая-то матрица комбинаций.\n\nUpSet отображает пересечения множества в виде матрицы, как показано на следующем рисунке. Каждый столбец соответствует набору, а столбчатые диаграммы сверху показывают размер набора. Каждая строка соответствует возможному пересечению: заполненные ячейки показывают, какой набор является частью пересечения. Также обратите внимание на линии, соединяющие заполненные ячейки: они показывают, в каком направлении вы должны читать график:\n\n\nFigure 1: Чтение графика\n\n\nРассмотрим как эти пересечения соответствуют сегментам на диаграмме Венна.\n\nПервая строка на рисунке полностью пуста – соответствует всем элементам, которые не входят ни в один из наборов.\nЗеленая (третья) строка соответствует элементам, которые находятся только в наборе B (не в A или C).\nОранжевая (пятая) строка представляет элементы, которые являются общими для наборов A и B, но не для C.\nНаконец, последняя (фиолетовая) строка представляет элементы, общие для всех наборов.\n\n\n\nFigure 2: Сопоставление с диаграммой Венна\n\n\nЭтот график хорош тем, что мы можем отобразить размер пересечений (“мощность”) в виде гистограмм прямо рядом с матрицей, как вы можете видеть в следующем примере:\n\n\nFigure 3: Гистограмма мощности на графике UpSet\n\n\nТакое представление мощнойстей делает более понятным сравнение размеров пересечений.\nМатрица также очень полезна, потому что ее можно сортировать различными способами. Обычным способом является сортировка по мощности (размеру), как показано на следующем рисунке, но также возможны и другие виды сортировки.\n\n\nFigure 4: Пример сортировки по мощности\n\n\nНаконец, UpSet одинаково хорошо работает как по горизонтали, так и по вертикали. Вертикальные графики лучше подходят для интерактивных графиков, которые можно прокручивать, в то время как горизонтальные графики лучше всего подходят для статичного представления.\n\n\nFigure 5: Горизонтальный график UpSet\n\n\nМы уже частично коснулись матрицы в которая содержит комбинации атрибутов, теперь рассмотрим её подробнее."
  },
  {
    "objectID": "visualization/Diagramms/Upset/diagramm_upsetr.html#комбинационная-матрица",
    "href": "visualization/Diagramms/Upset/diagramm_upsetr.html#комбинационная-матрица",
    "title": "UpSet диаграммы - введение",
    "section": "Комбинационная матрица",
    "text": "Комбинационная матрица\nГрафик UpSet строится на комбинациях пересечений атрибутов набора данных. Атрибуты должны иметь значения (0, 1) или (TRUE, FALSE). Совокупность таких атрибутов называется комбинационной матрицей или матрицей комбинаций, рассмотрим её создание на примере пакета ComplexHeatmap.\nМатрицу комбинаций можно составить из:\n\nсписка, содержащего несколько векторов\nдвоичной матрицы или фрейма данных, где строки являются элементами, а столбцы - наборами\nесли переменная является фреймом данных, сохраняются только двоичные столбцы (содержащие только 0 и 1) и логические столбцы.\n\nДля простоты создадим список содержащий два вектора разных размеров и преобразуем его к матрице, чтобы посмотреть полученные комбинации\n\nls <- list(set1 = c(\"a\", \"b\", \"c\"), set2 = c(\"b\", \"c\", \"d\", \"e\"))\nlist_to_matrix(ls)\n\n  set1 set2\na    1    0\nb    1    1\nc    1    1\nd    0    1\ne    0    1\n\n\nВ полученной матрице наборы set1 (размер вектора 3 элемента) и set2 (размер вектора 4 элемента) образуют 5 комбинаций, давайте их перечислим\n\n\na - есть только в наборе set1\n\nb - есть в обоих наборах\n\nc - есть в обоих наборах\n\nd - есть только в наборе set2\n\ne - есть только в наборе set2\n\nИтого:\n\nкомбинаций, которые есть только в наборе set1 - 1 шт\nкомбинаций, которые есть в наборе set1 и set2 - 2 шт\nкомбинаций, которые есть только в наборе set2 - 2 шт\n\nНа графике это количество комбинаций или пересечений отображается как Intersection size, а длины векторов или наборы в матрице как Set size.\n\n\n\n\nFigure 6: Сопоставление комбинационной матрицы с графиком\n\n\n\n\nТеперь создадим матрицу комбинаций функцией make_comb_mat.\nУ функции make_comb_mat есть три режима работы:\n\n\ndistinct (по умолчанию)\nintersect\nunion mode\n\nКак режимы влияют на пересечение наборов показано на рисунке ниже, а влияние на графиках разберем ниже.\n\n\nFigure 7: Режимы комбинационной матрицы\n\n\nСоздадим матрицу комбинаций\n\n# задание режимов расчета размеров набора\nmx <- make_comb_mat(ls)\n\nm2 = make_comb_mat(ls, mode = \"intersect\")\nm3 = make_comb_mat(ls, mode = \"union\")\n\n# Когда наборов слишком много, наборы могут быть предварительно отфильтрованы по заданным размерам.\n# Фильтрация по размеру наборов\n# min_set_size - Минимальный размер набора, который используется для генерации комбинированной матрицы\nm1 = make_comb_mat(ls, min_set_size = 4)\n# top_n_sets - Количество наборов с наибольшими размерами, которые используется для генерации комбинированной матрицы\nm2 = make_comb_mat(ls, top_n_sets = 1) \n\nДальше с этой матрицей будем работать черех пакет ComplexHeatmap."
  },
  {
    "objectID": "visualization/Diagramms/Upset/diagramm_upsetr.html#реализация-графиков-upset",
    "href": "visualization/Diagramms/Upset/diagramm_upsetr.html#реализация-графиков-upset",
    "title": "UpSet диаграммы - введение",
    "section": "Реализация графиков UpSet",
    "text": "Реализация графиков UpSet\nСоздать графики можно на различных языках программирования, мы рассмотрим R и Python в дальнейших статьях.\nЭти графики в языке R реализованы в трех пакетах:\n\nUpSetR\nComplexHeatmap\nComplexUpset\n\nНе нужно совместно инициализировать пакеты UpSetR и ComplexUpset, их методы пересекаются и привызове функции upset пакета UpSetR возникает ошибка: unused argument\nА в Python в двух библиотеках:\n\nUpSetPlot\npyUpSet\n\nПримеры графиков UpSet\n\n\n\n\n\n\nГоризонтальный график с метками данных\n\n\n\n\n\n\nГоризонтальный график с дополнительными диаграммами\n\n\n\n\n\n\n\n\nГоризонтальный график с несколькими дополнительными вертикальными диаграммами\n\n\n\n\nFigure 8: Примеры UpSet графиков\n\n\n\nReferences"
  },
  {
    "objectID": "visualization/Diagramms/Upset/diagramm_upsetr.html#используемые-источники",
    "href": "visualization/Diagramms/Upset/diagramm_upsetr.html#используемые-источники",
    "title": "UpSet диаграммы - введение",
    "section": "Используемые источники:",
    "text": "Используемые источники:\n\nhttps://upset.app/\nhttps://jokergoo.github.io/ComplexHeatmap-reference/book/upset-plot.html"
  },
  {
    "objectID": "visualization/Diagramms/Upset/packege_upsetr.html",
    "href": "visualization/Diagramms/Upset/packege_upsetr.html",
    "title": "Создание графиков в пакете UpSetR",
    "section": "",
    "text": "Создание графиков UpSet в пакете UpSetR процесс достаточно простой и интуитивно понятный, пакет поможет создавать качественные и красивые визуализации для полного и глубокого анализа данных. \n\nЗагрузим набор данных предоставляемый этим пакетом. Для построения графика будем использовать функцию upset, подробнее об этой функции в ?upset\n\nmovies <- read.csv(system.file(\"extdata\", \"movies.csv\", package = \"UpSetR\"), \n    header = T, sep = \";\")\n\nВыберем 6 наибольших наборов.\n\nupset(movies, nsets = 6, number.angles = 0, point.size = 3.5, line.size = 2, \n    mainbar.y.label = \"Genre Intersections\", sets.x.label = \"Movies Per Genre\", \n    text.scale = c(1.3, 1.3, 1, 1, 2, 0.75))\n\n\n\nFigure 1: На оси Movies Per Genre показано количество фильмов каждого жанра. На оси Genre Intersections количество фильмов в разрезе пересечений с другими жанрами. Видно, что наибольшее количество набирается когда пересечений с другими жанрами нет либо оно минимальное, а самые популярные жанры: Драма, Комедия и Ужасы\n\n\n\n\n\n\nmb.ratio = c(0.75, 0.25) - через этот параметр задаем соотношение между столбчатой диаграммой и диаграммой пересечений. Сумма коэффициентов должна равняться единице.\n\n```{r}\nupset(movies, sets = c(\"Action\", \"Adventure\", \"Comedy\", \"Drama\", \"Mystery\", \n    \"Thriller\", \"Romance\", \"War\", \"Western\"), mb.ratio = c(0.75, 0.25), order.by = \"degree\")\n\nupset(movies, sets = c(\"Action\", \"Adventure\", \"Comedy\", \"Drama\", \"Mystery\", \n    \"Thriller\", \"Romance\", \"War\", \"Western\"), mb.ratio = c(0.55, 0.45), order.by = c(\"degree\", \"freq\"))\n```\n\n\n\n\n\n(a) First\n\n\n\n\n\n\n(b) Second\n\n\n\n\nFigure 2: В обоих графиках задаем список наборов, соотношения между столбчатой диаграммой и диаграммой пересечений поставили разные. В первом графике сортировка задана по возрастанию наборов, а во втором графике по частоте\n\n\n\n\nkeep.order - при значении TRUE упорядочивает наборы в том порядке в котором они записаны в sets при значении FALSE по их размеру\n\n\nupset(movies, sets = c(\"Action\", \"Adventure\", \"Comedy\", \"Drama\", \"Mystery\", \n    \"Thriller\", \"Romance\", \"War\", \"Western\"), mb.ratio = c(0.55, 0.45), order.by = \"freq\", \n    keep.order = TRUE)\n\n\n\nFigure 3: Наборы на графике отсортированны согласно заданному нами списку, а размеры пересечений по убыванию.\n\n\n\n\n\n\nnintersects - количество пересечений выведенных на график, по умолчанию выводятся все пересечения group.by - способ группировки по наборам или по количеству пересечений наборов cutoff - Количество пересечений из каждого набора (для отсечения) при агрегировании по наборам\n\n\nupset(movies, nintersects = 70, group.by = \"sets\", cutoff = 7)\n\n\n\nFigure 4: На графике видим размер пересечений сгруппированые по жанрам, в каждой группе не более 7 значений. Так пересекающихся жанров несколько , то значения в нескольких пересекающихся друг с другом жанрах будут повторяться.\n\n\n\n\n\n\nempty.intersections = “on” - свойство позволяет дополнительно отображать пустые пересечения\n\n\nupset(movies, empty.intersections = \"on\", order.by = \"freq\")\n\n\n\nFigure 5: Видно, что на графике появились пустые пересечения т.е. размер которых равен нулю.\n\n\n\n\n\n\n\n\nС помощью атрибутов можно выводить дополнительные диаграммы на график.\nПараметр attribute.plots содержит три поля: gridrows, plots, and ncols\n\n\ngridrows указывает на сколько нужно увеличить высоту окна графика чтобы добавить место под диаграммы атрибутов. График UpSetR отрисовывается на сетка размером 100 х 100. Например если установить парамерт gridrows = 50, то размер новой сетки окна будет 150 х 100.\n\nplots также содержит список параметров, в нем задаются plot, x, y и queries.\n\nplot функция возвращающая ggplot\n\nx задает параметр к оси X\n\ny задает параметр к оси Y\n\nqueries: указывает необходимо ли применять к графиком атрибутов результаты параметра queries функции upset. Если значение True, то к графику будет применен параметр queries, если False, то нет. Сам же параметр queries имеет атрибут query который определяет какая функция будет применена к графику, например intersects или самописная функция.\n\nncols указывает, как должны быть расположены графики в пространстве строк сетки. Если введены два графика атрибутов и значение ncols равно 1, то графики будут отображаться один над другим. В качестве альтернативы, если введены два графика атрибутов и значение ncols равно 2, графики атрибутов будут отображаться рядом. \n\n\n\nupset(movies, main.bar.color = \"black\", queries = list(list(query = intersects, \n    params = list(\"Drama\"), active = T)), \n    attribute.plots = list(gridrows = 50, \n                           plots = list(\n                             list(plot = histogram, x = \"ReleaseDate\", queries = F), \n                             list(plot = histogram, x = \"AvgRating\", queries = T)), \n                           ncols = 2)\n    )\n\n\n\nFigure 6: На графике выделенно синим цветом пересечение по жанру драма. В дополнительной диаграмме среднего рейтинга фильмов выделена доля фильмов жанра драма. И на левом дополнительном графике показана частота выхода фильмов в зависимости от года\n\n\n\n\n\nВ этом коде задаем форматирование для пересечений нужным цветом. Потом в дополнительных диаграммах атрибутов определяем использовать это форматирование или нет.\n\nupset(movies, main.bar.color = \"black\", \n      queries = list(\n        list(query = intersects, params = list(\"Drama\"), color = \"red\", active = F), \n        list(query = intersects, params = list(\"Action\", \"Drama\"), active = T), \n        list(query = intersects, params = list(\"Drama\", \"Comedy\", \"Action\"), color = \"orange\", active = T)\n        ),\n      attribute.plots = list(gridrows = 45, \n                             plots = list(list(plot = scatter_plot, x = \"ReleaseDate\", y = \"AvgRating\", queries = T),\n                                          list(plot = scatter_plot, x = \"AvgRating\", y = \"Watches\", queries = F)\n                                          ), \n                             ncols = 2), query.legend = \"bottom\")\n\n\n\nFigure 7: На графике выделили три типа пересечений и спроецировали их на одну дополнительную диаграмму. На первой доп диаграмме показана зависимость среднего рейтинга от даты выхода фильма, а также какую часть в нем занимают интересующие нас пересечения. На второй доп диаграмме зависимость просмотров от среднего рейтинга, логично, что чем выше рейтинг тем выше количество просмотров\n\n\n\n\n\nЗдесь вместо одной из точечных диаграмм, добавляем диаграмму постороенную по пользовательской функцие.\n\nmyplot <- function(mydata, x, y) {\n    plot <- (ggplot(data = mydata, aes_string(x = x, y = y, colour = \"color\")) + \n        geom_point() + scale_color_identity() + theme(plot.margin = unit(c(0, 0, 0, 0), \"cm\")))\n}\n\nanother.plot <- function(data, x, y) {\n    data$decades <- round_any(as.integer(unlist(data[y])), 10, ceiling)\n    data <- data[which(data$decades >= 1970), ]\n    myplot <- (ggplot(data, aes_string(x = x)) + geom_density(aes(fill = factor(decades)), \n        alpha = 0.4) + theme(plot.margin = unit(c(0, 0, 0, 0), \"cm\"), legend.key.size = unit(0.4, \n        \"cm\")))\n}\n\nupset(movies, main.bar.color = \"black\", \n      queries = list(list(query = intersects, params = list(\"Drama\"), color = \"red\", active = F), \n                     list(query = intersects, params = list(\"Action\", \"Drama\"), active = T), \n                     list(query = intersects, params = list(\"Drama\", \"Comedy\", \"Action\"), color = \"orange\", active = T)), \n                attribute.plots = list(gridrows = 45, \n                                       plots = list(\n                                         list(plot = myplot, x = \"ReleaseDate\", y = \"AvgRating\", queries = T), \n                                         list(plot = another.plot, x = \"AvgRating\", y = \"ReleaseDate\", queries = F)), \n                                       ncols = 2))\n\n\n\nFigure 8: На график добавили диаграмму постороенную по своей функции. Она отображает средний рейтинг фильмов в зависимости от даты выхода в разрезе десятилетий\n\n\n\n\nОбъединение встроенного точечного графика и графика гистограммы с пользовательским графиком myplot, определенным в приведенном выше примере.\n\nupset(movies, main.bar.color = \"black\", mb.ratio = c(0.5, 0.5), \n      queries = list(list(query = intersects, params = list(\"Drama\"), color = \"red\", active = F), \n                     list(query = intersects, params = list(\"Action\", \"Drama\"), active = T), \n                     list(query = intersects, params = list(\"Drama\", \"Comedy\", \"Action\"), color = \"orange\", active = T)), \n    attribute.plots = list(gridrows = 50, \n                           plots = list(\n                             list(plot = histogram,x = \"ReleaseDate\", queries = F), \n                             list(plot = scatter_plot, x = \"ReleaseDate\", y = \"AvgRating\", queries = T), \n                             list(plot = myplot, x = \"AvgRating\", y = \"Watches\", queries = F)), \n                           ncols = 3))\n\n\n\nFigure 9: На этом графике добавлены дополнительные диаграммы. Теперь можно анализировать данные с нескольких сторон: частоты выхода фильмов и среднего рейтинга в зависимости от даты выхода, а также количество просмотров от серднего рейтинга фильмов\n\n\n\n\n\nboxplot, показывает распределение атрибута по всем пересечениям. Может отображать одновременно не более двух сводок графиков. Параметр boxplot.summary принимает вектор из одного или двух имен атрибутов.\n\nupset(movies, boxplot.summary = c(\"AvgRating\", \"ReleaseDate\"))\n\n\n\nFigure 10: Под каждым столбцом с пересечениями находится свой элемент диаграммы ящик с усами, он показывает распределение значений по диапозону. Например для фильмо с жанров драма видим, что медиана среднего рейтинга находится между 3 и 4, а медиана даты выхода ближе к 2000 году\n\n\n\n\n\nРазберем параметр query, он часто использовался на предыдущих диаграммах, пора его подробно описать.\n\n\nquery указывает, какой запрос будет выполняться\n\nparams это список параметров, с которыми будет работать запрос\n\ncolor это цвет, который будет представлять запрос на графике. Если цвет не указан, будет выбран цвет из палитры цветов по умолчанию.\n\nactive определяет, как запрос будет представлен на графике. Если значение active равно TRUE, строка размера пересечения будет перекрыта строкой, представляющей запрос. Если значение active равно FALSE, на панели размера пересечения будет размещена точка дрожания.\n\nВ этом примере показано, как использовать встроенный запрос пересечений intersects для поиска или отображения элементов в определенных пересечениях. В этом примере цвет, выбранный для активного запроса, выбран из цветовой палитры по умолчанию.\n\nupset(movies, \n      queries = list(list(query = intersects, params = list(\"Drama\",\"Comedy\", \"Action\"), color = \"orange\", active = T), \n                     list(query = intersects, params = list(\"Drama\"), color = \"red\", active = F), \n                     list(query = intersects, params = list(\"Action\", \"Drama\"), active = T)))\n\n\n\nFigure 11: с помощью запросов подсветили интересующие нас пересечения, где они активированы там цветом выделены столбец гистограммы и столбец на графике пересечений наборов, а где запрос не активирован, то там галочкой показана величина пересечения.\n\n\n\n\n\nЕсли необходимо визуализировать как конкретные значения атрибутов распределяются между пересечениями, то тогда можно использовать запрос элемента elements.\n\nupset(movies, \n      queries = list(list(query = elements, params = list(\"AvgRating\", 3.5, 4.1), color = \"blue\", active = T), \n                     list(query = elements, params = list(\"ReleaseDate\", 1980, 1990, 2000), color = \"red\", active = F)))\n\n\n\nFigure 12: в гистограме пересечений подсветили интересующие нас конкретные значения среднего рейтинга синим цветом и даты выхода фильмов красным цветом\n\n\n\n\n\nВ этом примере показано, как использовать параметр expression для фильтрации подмножества результатов запросов элементов и пересечений.\n\nupset(movies, \n      queries = list(\n        list(query = intersects, params = list(\"Action\", \"Drama\"), active = T), \n        list(query = elements, params = list(\"ReleaseDate\", 1980, 1990, 2000), color = \"red\", active = F)\n        ), \n      expression = \"AvgRating > 3 & Watches > 100\")\n\n\n\nFigure 13: Отфильтровали график по условиям средний рейтинг > 3 и количество просмотров > 100. Далее выделили пересечение жанров экшен и драмы. А также красным цветом показали содержащееся в пересечениях количество фильмов с датами выхода 1980, 1990 и 2000\n\n\n\n\n\n\nMyfunc <- function(row, release, rating) {\n    data <- (row[\"ReleaseDate\"] %in% release) & (row[\"AvgRating\"] > rating)\n}\n\nupset(movies, \n      queries = list(list(query = Myfunc, params = list(c(1970, 1980, 1990, 1999, 2000), 2.5), \n                          color = \"blue\", active = T))\n      )\n\n\n\nFigure 14: На графике подсвечиваем с помощью написанной функции количество фильмов с заданой датой выхода и выше нужного нам рейтинга\n\n\n\n\n\nЧтобы добавить условные обозначения для примененных запросов, можно использовать параметр query.legend. Параметр query.legend задает положение, в котором должна отображаться легенда, либо сверху, либо снизу. Чтобы применить определенное имя к каждому запросу, параметр query.name может использоваться при определении запроса в параметре запросов. Если query.name не задан, то будет использоваться общее название. В приведенном ниже примере показано, как это сделать.\n\nupset(movies, \n      query.legend = \"top\", \n      queries = list(\n        list(query = intersects, params = list(\"Drama\", \"Comedy\", \"Action\"), color = \"orange\", active = T,\n             query.name = \"Funny action\"), \n        list(query = intersects, params = list(\"Drama\"), color = \"red\", active = F), \n        list(query = intersects, params = list(\"Action\", \"Drama\"), active = T, \n             query.name = \"Emotional action\"))\n      )\n\n\n\nFigure 15: График с легендой\n\n\n\n\nОбъединим примененные выше методы\n\nupset(movies, \n      query.legend = \"bottom\", \n      queries = list(\n        list(query = Myfunc, params = list(c(1970, 1980, 1990, 1999, 2000), 2.5), color = \"orange\", active = T), \n        list(query = intersects, params = list(\"Action\", \"Drama\"), active = F), \n        list(query = elements, params = list(\"ReleaseDate\", 1980, 1990, 2000), color = \"red\", active = F,\n             query.name = \"Decades\")), \n      expression = \"AvgRating > 3 & Watches > 100\")\n\n\n\nFigure 16: График с пользовательскими наборами\n\n\n\n\n\nДобавление метаданных задается параметром: set.metadata\nРазберем атрибуты этого параметра:\n\ndata: принимает фрейм данных, где первый столбец - это имена наборов, а следующие столбцы - атрибуты наборов.\nplots: это список, который принимает список параметров, используемых для создания графиков. Эти параметры включают столбец, тип, назначение и цвета.\ncolumn: столбец используемого набора данныхЮ по которому будет строиться график\ntype: это то, какой тип графика следует использовать для отображения данных из указанного столбца. Если данные в столбце числовые, то тип графика может быть либо гистограммой (“hist”), либо тепловой картой (“heat”). Если данные в столбце являются логическими, то типом графика может быть тепловая карта “bool”. Если данные в столбце являются категориальными (символьными), то тип графика может быть либо тепловой картой (“тепло”), либо текстом (“текст”). Кроме того, если данные в столбце порядковые (коэффициентные), то тип графика может быть либо тепловой картой, либо текстом. Существует также тип под названием “matrix_rows”, который позволяет нам использовать применение цветов к фону матрицы с использованием категориальных данных. Этот тип полезен для определения характеристик наборов с использованием матрицы.\nassign: это количество столбцов, которые должны быть назначены конкретному графику. Например, если вы строите 2 набора графиков метаданных, то вы можете выбрать один график, который будет занимать 20 столбцов, а другой - 10 столбцов. Поскольку график смещения обычно наносится на сетку размером 100 на 100, сетка теперь будет иметь размер 100 на 130, где примерно 1/4 участка отводится графикам метаданных.\n\ncolors: используется для указания цветов, используемых в графиках метаданных. Если тип графика - линейчатый график, то параметр принимает только один цвет для всего графика. Если тип графика “heat” или “bool”, то может быть предоставлен вектор цветов, в котором для каждой уникальной категории (символа) есть один цвет. Однако, если тип данных порядковый (фактор), ввод цветов отсутствует, и тепловая карта работает с цветовым градиентом, а не применяет разные цвета к каждому уровню. Наконец, если тип графика - “текст”, то может быть предоставлен вектор цветов, где для каждой уникальной строки есть один цвет. Если цвета не указаны, вам будет предоставлена цветовая палитра.\nВ этом примере в качестве метаданных набора будут использоваться средние рейтинги фильмов Rotten Tomatoes для каждого набора. Это может помочь нам сделать больше выводов из визуализации, зная, как профессиональные рецензенты обычно оценивают фильмы в этих категориях.\n\n\n\nsets <- names(movies[3:19])\navgRottenTomatoesScore <- round(runif(17, min = 0, max = 90))\nmetadata <- as.data.frame(cbind(sets, avgRottenTomatoesScore))\nnames(metadata) <- c(\"sets\", \"avgRottenTomatoesScore\")\n\n# При создании гистограммы с использованием информации метаданных набора важно убедиться, что указанный столбец является числовым.\n# is.numeric(metadata$avgRottenTomatoesScore)\n\n# Столбец не является числовым! На самом деле это фактор, поэтому мы должны преобразовать его в символы, а затем в целые числа.\nmetadata$avgRottenTomatoesScore <- as.numeric(as.character(metadata$avgRottenTomatoesScore))\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"hist\", column = \"avgRottenTomatoesScore\", assign = 20)))\n      )\n\n\n\nFigure 17: График с добавлением метаданных\n\n\n\n\n\nВ этом примере мы составим наши собственные данные о том, в каких крупных городах эти жанры были наиболее популярны. Поскольку это категориальный, а не порядковый номер, мы должны не забыть изменить столбец на символы (это снова фактор). Чтобы убедиться, что мы назначаем определенные цвета каждой категории, вы можете указать название каждой категории в цветовом векторе, как показано ниже. Если вам все равно, какой цвет присвоен каждой категории, то вам не нужно указывать названия категорий в цветовом векторе. R просто применит цвета к каждой категории в том порядке, в котором они встречаются. Кроме того, если вы ничего не укажете для параметра colors, вам будет предоставлена цветовая палитра по умолчанию.\n\nCities <- sample(c(\"Boston\", \"NYC\", \"LA\"), 17, replace = T)\nmetadata <- cbind(metadata, Cities)\nmetadata$Cities <- as.character(metadata$Cities)\n# metadata[which(metadata$sets %in% c(\"Drama\", \"Comedy\", \"Action\", \"Thriller\", \"Romance\")), ]\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"heat\", column = \"Cities\", assign = 10, \n             colors = c(Boston = \"green\", NYC = \"navy\", LA = \"purple\"))))\n      )\n\n\n\nFigure 18: График с добавлением тепловой карты\n\n\n\n\nТеперь давайте также использовать наши числовые значения критики!\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"heat\", column = \"Cities\", assign = 10, \n             colors = c(Boston = \"green\", NYC = \"navy\", LA = \"purple\")), \n        list(type = \"heat\", column = \"avgRottenTomatoesScore\", assign = 10)))\n      )\n\n\n\nFigure 19: График с несколькими тепловыми картами\n\n\n\n\n\nТеперь предположим, что у нас есть метаданные, которые сообщают нам, хорошо ли эти жанры приняты за рубежом. Это может быть использовано в качестве категориального столбца, где есть только две категории, но для этого примера мы предположим, что ваши данные закодированы в 1 и 0. Важно иметь в виду, что если вы запустите “heat” с 0 и 1 вместо “bool”, двоичные данные будут обрабатываться как числовые значения, а цветовой градиент будет использоваться для отображения относительных различий.\n\naccepted <- round(runif(17, min = 0, max = 1))\nmetadata <- cbind(metadata, accepted)\n# metadata[which(metadata$sets %in% c(\"Drama\", \"Comedy\", \"Action\", \"Thriller\", \"Romance\")), ]\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"bool\", column = \"accepted\", assign = 5, colors = c(\"#FF3333\", \"#006400\"))))\n      )\n\n\n\nFigure 20: График с логической тепловой картой\n\n\n\n\nДавайте посмотрим, что произойдет, когда мы выберем “heat” вместо “bool” для нашего столбца двоичных данных.\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"heat\", column = \"accepted\", assign = 5, colors = c(\"red\", \"green\"))))\n      )\n\n\n\nFigure 21: График с тепловой картой\n\n\n\n\nДопустим, мы предпочитаем показывать текст вместо тепловой карты для городов, в которых эти жанры были наиболее популярны.\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"text\", column = \"Cities\", assign = 10, \n             colors = c(Boston = \"green\", NYC = \"navy\", LA = \"purple\"))))\n      )\n\n\n\nFigure 22: График с тепловой картой в виде текста\n\n\n\n\n\nВ некоторых случаях мы можем просто захотеть включить метаданные категориального набора непосредственно в график расслоения, чтобы легко идентифицировать характеристики наборов с помощью матрицы. Для этого нам нужно указать тип как matrix_rows, какой столбец мы используем для категоризации наборов, и цвета, которые будут применяться к каждой категории. Существует также возможность изменить непрозрачность фона матрицы с помощью альфа-кода. Чтобы изменить непрозрачность фона матрицы без применения заданных метаданных, см. параметр shade.alpha в документации к функции disapport().\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"hist\", column = \"avgRottenTomatoesScore\", assign = 20), \n        list(type = \"matrix_rows\", column = \"Cities\", \n             colors = c(Boston = \"green\", NYC = \"navy\", LA = \"purple\"), \n    alpha = 0.5)))\n    )\n\n\n\nFigure 23: Окрашивание пересечений по значениям категорий\n\n\n\n\nОбъединим методы рассмотренные выше на одном графике\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"hist\", column = \"avgRottenTomatoesScore\", assign = 20), \n        list(type = \"bool\", column = \"accepted\", assign = 5, colors = c(\"#FF3333\", \"#006400\")), \n        list(type = \"text\", column = \"Cities\", assign = 5, \n             colors = c(Boston = \"green\", NYC = \"navy\", LA = \"purple\"))))\n      )\n\n\n\nFigure 24: График с совмещенными методами метаданных\n\n\n\n\nА теперь соединим методы добавления метаданных, атрибутов и запросов\n\nupset(movies, \n      set.metadata = list(data = metadata, plots = list(\n        list(type = \"hist\", column = \"avgRottenTomatoesScore\", assign = 20), \n        list(type = \"bool\", column = \"accepted\", assign = 5, colors = c(\"#FF3333\", \"#006400\")), \n        list(type = \"text\", column = \"Cities\",   assign = 5, colors = c(Boston = \"green\", NYC = \"navy\", LA = \"purple\")), \n        list(type = \"matrix_rows\", column = \"Cities\", colors = c(Boston = \"green\", NYC = \"navy\", LA = \"purple\"), \n             alpha = 0.5))), \n      queries = list(list(query = intersects, params = list(\"Drama\"), color = \"red\", active = F), \n                     list(query = intersects, params = list(\"Action\", \"Drama\"), active = T), \n                     list(query = intersects, params = list(\"Drama\", \"Comedy\", \"Action\"), \n                          color = \"orange\", active = T)), \n      attribute.plots = list(gridrows = 45, plots = list(\n        list(plot = scatter_plot, x = \"ReleaseDate\", y = \"AvgRating\", queries = T), \n        list(plot = scatter_plot, x = \"AvgRating\", y = \"Watches\", queries = F)), ncols = 2), \n      query.legend = \"bottom\")\n\n\n\nFigure 25: методы добавления метаданных, атрибутов и запросов на одном графике"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#tidy-select",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#tidy-select",
    "title": "Dplyr",
    "section": "tidy-select",
    "text": "tidy-select\nПакет tidyselect - это серверная часть таких функций, как dplyr::select() или dplyr::pull(), а также нескольких глаголов tidyr. Это позволяет создавать глаголы выбора, которые совместимы с другими пакетами tidyverse.\nКонечно логичнее было разместить раздел tidyselect в части выборки данных -&gt; Столбцы, но tidyselect имеет гораздо большее значение и может применяться не только в select.\ntidyselect поддерживает базовые функции R по выборке:\n\n: для выбора диапазона последовательных переменных.\n! для получения дополнения к набору переменных.\n& и | для выбора пересечения или объединения двух наборов переменных.\nc() для объединения выделений.\n\nТакже можно использовать функции помощи в выборке, для конкретных столбцов\n\neverything() - выбирает все столбцы, обычно применяется с другими операторами tidyselect\nlast_col() - выбирает последнюю переменную\n\nДля выборки столбцов сопоставляя шаблоны в их именах:\n\nstarts_with: название столбца начинается с точного префикса\nends_with: название столбца заканчивается на точный суффикс\ncontains: название столбца содержит символ\nmatches: название столбца соответствует регулярному выражению\nnum_range: поиск занумерованных столбцов, например, «V1, V2, V3…»\nall_of() : точный поиск по значениям, проверяет наличие значений\nany_of() : поиск без проверки наличия значений, используется, чтобы убедиться, что столбец удален\none_of: название столбца соответствует одному из вариантов\nwhere() : условие функции должно быть True\n\nСделать строки с блоками кода на подобии тех, что использую в соединениях и наглядно показать как работают и чем отличаются функции помощи\nРассмотрим подробнее функции помощи\n\nФункции выбора\n\neverything\neverything(vars = NULL) - выбирает все столбцы, обычно применяется с другими операторами tidyselect\nvars - Символьный вектор имен переменных. Если не указано, переменные берутся из текущего контекста выбора (как установлено такими функциями, как select() или pivot_longer()).\n\nstarwars %&gt;% \n  select(everything())\n\n\n\n  \n\n\n\n\n\nlast_col\nlast_col(offset = 0L, vars = NULL) - выбирает последнюю переменную\noffset - устанавливает какое количество столбцов с конца нужно пропустить\n\n\n\nstarwars %&gt;% \n  select(1:last_col(9))\n\n\n\n  \n\n\n\n\nstarwars %&gt;% \n  select(last_col(9))\n\n\n\n  \n\n\n\n\n\n\n\n\nФункции поиска по шаблону\nАргументы функций поиска по шаблону:\n\nmatch - Вектор символов. Если длина &gt; 1, берется объединение совпадений. Для starts_with(), ends_with() и contains() это точное совпадение. Для matches() это регулярное выражение и может быть шаблоном stringr.\nignore.case - Если значение по умолчанию равно TRUE, регистр игнорируется при сопоставлении имен\nvars - Символьный вектор имен переменных. Если не указано, переменные берутся из текущего контекста выбора (как установлено такими функциями, как select() или pivot_longer()).\nprefix, suffix - Префикс/суффикс, добавленный до/после числового диапазона\nrange - Последовательность целых чисел, например 1:5\nwidth - Необязательный аргумент, “ширина” числового диапазона. Например, диапазон из 2 дает “01”, диапазон из трех “001” и т.д\n\n\nstarts_with\nstarts_with() - отбирает те столбцы название которых начинается с точного префикса\nstarts_with(match, ignore.case = TRUE, vars = NULL)\nВ функции starts_with() есть возможность задать мульти префикс, в этом случае порядок столбцов будет зависеть от порядка указания префиксов.\n\n\n\n# отберем столбцы, название которых начинается на символ «h».\nstarwars %&gt;% \n  select(starts_with(\"h\"))\n\n\n\n  \n\n\n\n\n# отберем столбцы, название которых начинается на символы \"b\" и «h».\nstarwars %&gt;% \n  select(starts_with(c(\"b\", \"h\")))\n\n\n\n  \n\n\n\n\n\n\n\nends_with\nends_with(match, ignore.case = TRUE, vars = NULL) - отбирает те столбцы название которых заканчивается на точный суффикс\nВ функции ends_with() есть возможность задать мульти суффикс, в этом случае порядок столбцов будет зависеть от порядка указания суффиксов.\n\n\n\n# отберем столбцы, название которых заканчивается на слово «color».\nstarwars %&gt;% \n  select(ends_with(\"color\"))\n\n\n\n  \n\n\n\n\n# отберем столбцы, название которых заканчивается на слова \"year\" и «color».\nstarwars %&gt;% \n  select(ends_with(c(\"year\", \"color\")))\n\n\n\n  \n\n\n\n\n\n\n\ncontains\ncontains(match, ignore.case = TRUE, vars = NULL) - отбирает те столбцы название которых содержит в названии символ/ы\nВ функции contains() есть возможность задать несколько символьных шаблонов, в этом случае порядок столбцов будет зависеть от порядка указания символов.\n\n\n\n# отберем столбцы, название которых содержит букву «а».\nstarwars %&gt;% \n  select(contains('a'))\n\n\n\n  \n\n\n\n\n# отберем столбцы, название которых содержит буквы «m» и \"f\".\nstarwars %&gt;% \n  select(contains(c('m', 'f')))\n\n\n\n  \n\n\n\n\n\n\n\nmatches\nФункции starts_with(), ends_with() и contains() не используют регулярные выражения. Для выбора с помощью регулярного выражения нужно использовать matches()\nmatches(match, ignore.case = TRUE, perl = FALSE, vars = NULL) - отбирает те столбцы название которых соответствует регулярному выражению\n\n# отберем столбцы, название которых соответствует регулярному выражению\nstarwars %&gt;% \n  select(matches('[rne]_color'))\n\n\n\n  \n\n\n\n\n\nnum_range\nnum_range(prefix, range, suffix = \"\", width = NULL, vars = NULL) - отбирает те столбцы название которых соответствует префиксу и числовому диапозону\nФункции starts_with() и num_range() похожи, только первая ищет по префиксу, то num_range() отбирает по числовому диапозону внутри этого префикса.\nСравним эти функции на фрейме данных billboard, который содержит столбцы одиннаковым префиксом + номер столбца\n\n\n\n# отбираем столбцы с префиксом \"wk\"\nbillboard %&gt;% \n  select(starts_with(\"wk\"))\n\n\n\n  \n\n\n\n\n# отбираем столбцы с префиксом \"wk\" и числовым диапозоном от 2 до 5\nbillboard %&gt;% \n  select(num_range(\"wk\", 2:5))\n\n\n\n  \n\n\n\n\n\n\n\n\nФункции выбора по символьному вектору\n\nall_of\nall_of(x) - предназначен для строгого отбора. Если какая-либо из переменных в символьном векторе отсутствует, выдается сообщение об ошибке\n\n\n\nvar &lt;- c('name', 'mass')\nstarwars %&gt;% \n  select(all_of(var))\n\n\n\n  \n\n\n\n\n```{r}\n# Если какая-либо переменная отсутствует во фрейме данных, это ошибка\nvar &lt;- c('name', 'mass', 'class')\nstarwars %&gt;% \n  select(all_of(var))\n\n\n# Error in `select()`:\n# ! Problem while evaluating `all_of(var)`.\n# Backtrace:\n#  1. starwars %&gt;% select(all_of(var))\n#  3. dplyr:::select.data.frame(., all_of(var))\n# Error in select(., all_of(var)) :\n```\n\n\n\n\n\nany_of\nany_of(x, ..., vars = NULL) - не проверяет наличие отсутствующих переменных. Это особенно полезно при отрицательном выборе, когда вы хотите убедиться, что переменная удалена\n\n\n\n# Проверяем, что столбец отсутствует во фрейме\nvar &lt;- c('class')\nstarwars %&gt;% \n  select(any_of(var))\n\n\n\n  \n\n\n\n\n# Удаляем из фрейма столбцы\n# Даже вызвав одну функцию несколько раз ошибки не будет\nvar &lt;- c('name', 'mass')\nstarwars %&gt;% \n  select(-any_of(var)) %&gt;% \n  select(-any_of(var))\n\n\n\n  \n\n\n\n\n\n\n\n\nВыбор через функцию\n\nwhere\nwhere(fn) - Применяет функцию ко всем переменным и выбирает те, для которых функция возвращает значение TRUE\nВнутри функции можно создавать анонимные функции подобно тем, что создаются в пакете purrr, рассмотрим разные варианты реализации одной и той же логики\n\n\n\n# отбираем только числовые столбцы\niris %&gt;% \n  select(where(is.numeric))\n\n\n\n  \n\n\n\n\n# отбираем только числовые столбцы\niris %&gt;% \n  select(where(function(x) is.numeric(x)))\n\n\n\n  \n\n\n\n\n\n\n# отбираем только числовые столбцы\niris %&gt;% \n  select(where(~ is.numeric(.x)))\n\n\n\n  \n\n\n\n\n# отбираем только числовые столбцы # у которых стреднее больше 3.5\niris %&gt;% \n  select(where(~ is.numeric(.x) &&  mean(.x) &gt; 3.5))"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#фильтрация",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#фильтрация",
    "title": "Dplyr",
    "section": "Фильтрация",
    "text": "Фильтрация\n\nПо логическому условию\n\nstarwars %&gt;% \n  filter(mass &gt; 50)\n\n\n\n  \n\n\n#комбинировать несколько условий можно с помощью & и |:\nstarwars %&gt;% \n  filter(mass &gt; 50 & height &gt; 170)\n\n\n\n  \n\n\n\nКонструировать логические условия можно и другими операторами:\n\n&gt;=\n&lt;=\nis.na\n!is.na\n%in%\n!\nbetween\nnear\nxor\n\n\nstarwars %&gt;% \n  filter(skin_color %in% c('fair', 'green'))\n\n\n\n  \n\n\n\n\nbetween\n\n\nnear"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#сортировка",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#сортировка",
    "title": "Dplyr",
    "section": "Сортировка",
    "text": "Сортировка\nДля сортировки в языке есть достаточно широкие возможности. Вот самые основные виды сортировки:\n\nПо возрастанию\n\nstarwars %&gt;% \n  arrange(mass)\n\n\n\n  \n\n\n\n\n\nПо убыванию\n\n# сортировка по убыванию\nstarwars %&gt;% \n  arrange(desc(mass))\n\n\n\n  \n\n\n\n\n\nПо нескольким столбцам\n\n# сортировка по нескольким столбцам\nstarwars %&gt;% \n  arrange(height, desc(mass))\n\n\n\n  \n\n\n\n\n\nРасширенная сортировка\nПри сортировке можно использовать вспомогательные функции для select, только внутри функции across\n\nstarwars %&gt;% \n  arrange(across(ends_with('_color'), desc))"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#группировка-и-обработка-групп",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#группировка-и-обработка-групп",
    "title": "Dplyr cheat sheet",
    "section": "Группировка и обработка групп",
    "text": "Группировка и обработка групп\nГруппировка\ngroup_by\ngroup_map\ngroup_cols\ngroup_modify\ngroup_walk\ngroup_split\ngroup_trim\nrowwise\nungroup"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#манипуляция-отдельными-строками",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#манипуляция-отдельными-строками",
    "title": "Dplyr",
    "section": "Манипуляция отдельными строками",
    "text": "Манипуляция отдельными строками\nГруппа этих функций позволяет манипулировать отдельными строками на подобии SQL без создания копии фрейма данных.\nРассмотрим атрибуты функций:\n\nx, y -\nby -\nconflict -\ncopy -\nin_place -\nunmatched -\n\nСоздадим набор данных для описания возможностей работы с функциями:\n\ndata &lt;- tibble(a = 1:3, b = letters[c(1:2, NA)], c = 0.5 + 0:2)\ndata\n\n\n\n  \n\n\n\n\nInsert\nrows_insert(x, y, by = NULL, ..., conflict = c(\"error\", \"ignore\"), copy = FALSE, in_place = FALSE)\nrows_insert() - добавляет новую стороку во фрейм данных, по умолчанию ключевые значения добавляемой строки не должны существовать во фрейме.\n\n\n\nrows_insert(data, tibble(a = 4, b = \"z\"))\n\nMatching, by = \"a\"\n\n\n\n\n  \n\n\n\n\nrows_insert(data, tibble(a = 3, b = \"z\"), conflict = \"ignore\")\n\nMatching, by = \"a\"\n\n\n\n\n  \n\n\n\n\n\nВоспроизведем ситуацию когда ключевые значения совпадают, и функция не дополнена аргументом conflict\n\ntry(rows_insert(data, tibble(a = 3, b = \"z\")))\n\nMatching, by = \"a\"\n\n\nError in rows_insert(data, tibble(a = 3, b = \"z\")) : \n  `y` can't contain keys that already exist in `x`.\nℹ The following rows in `y` have keys that already exist in `x`: `c(1)`.\nℹ Use `conflict = \"ignore\"` if you want to ignore these `y` rows."
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#определить-куда-это-относится",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#определить-куда-это-относится",
    "title": "Dplyr cheat sheet",
    "section": "Определить куда это относится",
    "text": "Определить куда это относится\nn() gives the current group size.\ncur_data() gives the current data for the current group (excluding grouping variables).\ncur_data_all() gives the current data for the current group (including grouping variables)\ncur_group() gives the group keys, a tibble with one row and one column for each grouping variable.\ncur_group_id() gives a unique numeric identifier for the current group.\ncur_group_rows() gives the row indices for the current group.\ncur_column() gives the name of the current column (in across() only)."
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#и-это",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#и-это",
    "title": "Dplyr cheat sheet",
    "section": "И это",
    "text": "И это\nCompute results of a query\ncompute(): dbplyr (tbl_sql), dplyr (data.frame)\ncollect(): dbplyr (tbl_sql), dplyr (data.frame)\ncollapse(): dbplyr (tbl_sql), dplyr (data.frame)\n\n# сама по себе группировка не несет смысла, только в сочетании с агрегирующими функциями\nstarwars %>% \n  group_by(eye_color)\n\n\n\n  \n\n\n\n\nstarwars %>% \n  group_by(eye_color) %>% # группируем по полю\n  summarise(\n    'mean mass' = mean(mass), # задаем имя столбцу и применяем функцию\n    'max mass' = max(mass),\n    'min mass' = min(mass),\n    'first mass' = first(mass),\n    'median mass' = median(mass),\n    'quantity' = n()\n  )\n\n\n\n  \n\n\n# про другие функции summarise в ?summarise\n\nРассчитать показатели только для нескольких столбцов сразу\n\nstarwars %>% \n  group_by(eye_color) %>% \n  summarise(\n    across(\n      .cols = c(mass, height), # столбцы к котторым применятся функции\n      .fns = list(mean = mean, max = max, min = min, first = first, median = median), # набор функций\n      .names = \"{.col}.fn_{.fn}\"  # шаблон имени столбца\n    )\n  )"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#агрегатные-функции",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#агрегатные-функции",
    "title": "Dplyr",
    "section": "Агрегатные функции",
    "text": "Агрегатные функции\n\nsummarise\nС summarise применяются следующие функции:\n\nCenter: mean(), median()\nSpread: sd(), IQR(), mad(), var()\nRange: min(), max(), quantile()\nPosition: first(), last(), nth(),\nCount: n(), n_distinct()\nLogical: any(), all()"
  },
  {
    "objectID": "r_language/Tidyverse/tibble_tidyverse.html",
    "href": "r_language/Tidyverse/tibble_tidyverse.html",
    "title": "Tibble",
    "section": "",
    "text": "Класс tbl_df является подклассом data.frame, созданным для того, чтобы иметь другое поведение по умолчанию. Разговорный термин “tibble” относится к фрейму данных, который имеет класс tbl_df.\nУ класса tbl_df следующие зависимости:\n\nатрибуты класса: c(“tbl_df”, “tbl”, “data.frame”)\nбазовый элемент - вектор, где каждый вектор имеет одину и ту же длинну vctrs::vec_size()\nатрибут names, представляющий собой вектор символов той же длины, что и базовый список\nатрибут row.names, включенный для совместимости с data.frame. К этому атрибуту обращаются только для запроса количества строк, любые имена строк, которые могут там храниться, игнорируются большинством методов tibble.\n\nПоведение объектов класса tbl_df\n\nсимвольные вектора не приводятся принудительно к типу факторов\nимена столбцов не изменяются\nПереработка происходит только для векторов длиной 1, т.к. расширение векторов длинной более 1 элемента к длинне других векторов фрейма часто приводит к ошибкам vctrs::vec_recycle()\n\nИмена столбцов не заполняются, хотя отсутствующие имена заполняются автоматически. Пустые и дублирующиеся имена столбцов категорически не рекомендуются, но пользователь должен указать, как их разрешить. Подробнее читайте в vctrs::vec_as_names()\n\nИмена строк не добавляются и настоятельно не рекомендуются в пользу сохранения этой информации в виде столбца. Читайте об этом в именах строк\n\ndf[, j] возвращает tibble; он не извлекает автоматически столбец внутри. значение по умолчанию - df[, j, drop = FALSE]. Подробнее читайте в разделе подмножество"
  },
  {
    "objectID": "r_language/Tidyverse/tibble_tidyverse.html#создание-tibble",
    "href": "r_language/Tidyverse/tibble_tidyverse.html#создание-tibble",
    "title": "Tibble",
    "section": "Создание tibble",
    "text": "Создание tibble\nАргументы:\n\n\n.rows - количество строк\n\n.name_repair - проверка имен столбцов\n\n\nminimal - без проверки, кроме самого наличия имени столбца\n\nunique - имя должно быть уникальное и не пустое\n\ncheck_unique - имя должно быть уникальное\n\nuniversal - делает имена уникальными и синтетическими\n\n\n\ntibble\nОпределение\nМетод создающий фрейм данных\nИспользование\ntibble(..., .rows = NULL, .name_repair = c(\"check_unique\", \"unique\", \"universal\", \"minimal\"))\n\na <- 1:5\ntibble(a, a * 2, a, .name_repair = \"universal\")\n\nNew names:\n• `a` -> `a...1`\n• `a * 2` -> `a...2`\n• `a` -> `a...3`\n\n\n# A tibble: 5 × 3\n  a...1 a...2 a...3\n  <int> <dbl> <int>\n1     1     2     1\n2     2     4     2\n3     3     6     3\n4     4     8     4\n5     5    10     5\n\n\ntibble_row\nОпределение\nМетод создающий фрейм данных содержащий только одну строку. Векторные столбцы должны иметь длинну в один элемент, не векторные приводятся к типу список\nИспользование\ntibble_row(..., .name_repair = c(\"check_unique\", \"unique\", \"universal\", \"minimal\") )\n\ntibble_row(a = 1, lm = lm(Height ~ Girth + Volume, data = trees))\n\n# A tibble: 1 × 2\n      a lm    \n  <dbl> <list>\n1     1 <lm>  \n\n\ntribble\nОпределение\nМетод для создания фрейма данных строка за строкой, т.е. задать вручную данные для небольшого набора, где важна удобочитаемость примера.\n\n\n\ntribble(\n  ~colA, ~colB,\n  \"a\",   1,\n  \"b\",   2,\n  \"c\",   3\n)\n\n# A tibble: 3 × 2\n  colA   colB\n  <chr> <dbl>\n1 a         1\n2 b         2\n3 c         3\n\n\n\ntribble(\n  ~a, ~b, ~c,\n  1, \"2000-01-01\", \"1.5\"\n) %>%\n  dplyr::mutate(\n    dplyr::across(a, as.integer),\n    dplyr::across(b, as.Date)\n  )\n\n# A tibble: 1 × 3\n      a b          c    \n  <int> <date>     <chr>\n1     1 2000-01-01 1.5  \n\n\n\n\nnew_tibble\nОпределение\nМетод создающий фрейм данных, оптимизированный по производительности, проверки сведены к минимуму. Реализован на основе метода new_data_frame() из пакета vctrs\nИспользование\nnew_tibble(x, ..., nrow = NULL, class = NULL, subclass = NULL)\n\nnew_tibble(list(a = 1:3, b = 4:6), nrow = 3)\n\n# A tibble: 3 × 2\n      a     b\n  <int> <int>\n1     1     4\n2     2     5\n3     3     6"
  },
  {
    "objectID": "r_language/Tidyverse/tibble_tidyverse.html#создание-матрицы",
    "href": "r_language/Tidyverse/tibble_tidyverse.html#создание-матрицы",
    "title": "Tibble",
    "section": "Создание матрицы",
    "text": "Создание матрицы\nframe_matrix\nОпределение\nМетод для создания небольших матриц, например ковариационных, где важна наглядность с расположением данных по строкам\nИспользование\nframe_matrix(...)\n\nframe_matrix(\n  ~col1, ~col2,\n  1,     3,\n  5,     2\n)\n\n     col1 col2\n[1,]    1    3\n[2,]    5    2"
  },
  {
    "objectID": "r_language/Tidyverse/tibble_tidyverse.html#отображение-tibble",
    "href": "r_language/Tidyverse/tibble_tidyverse.html#отображение-tibble",
    "title": "Tibble",
    "section": "Отображение tibble",
    "text": "Отображение tibble\nprint\nОпределение\nВыводит на печать фрейм данных\nАтрибуты метода:\n\n\nx - объект, который нужно отформатировать или напечатать\n\nwidth - ширина выводимого текста фрейма\n\nn - количество отображаемых строк\n\nmax_extra_cols - количество дополнительных столбцов для печати сокращенной информации, если ширина слишком мала для всего текста\n\nmax_footer_lines - максимальное количество строк нижнего колонтитула. Если значение равно NULL, используется параметр max_footer_lines.\n\nИспользование\nprint(x, width = NULL, ..., n = NULL, max_extra_cols = NULL, max_footer_lines = NULL)\n\n\n\nprint(as_tibble(mtcars), n = 1, width = 50)\n\n# A tibble: 32 × 11\n    mpg   cyl  disp    hp  drat    wt  qsec    vs\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1    21     6   160   110   3.9  2.62  16.5     0\n# … with 31 more rows, and 3 more variables:\n#   am <dbl>, gear <dbl>, carb <dbl>\n\n\n\nprint(as_tibble(mtcars), n = 3, width = 50)\n\n# A tibble: 32 × 11\n    mpg   cyl  disp    hp  drat    wt  qsec    vs\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1  21       6   160   110  3.9   2.62  16.5     0\n2  21       6   160   110  3.9   2.88  17.0     0\n3  22.8     4   108    93  3.85  2.32  18.6     1\n# … with 29 more rows, and 3 more variables:\n#   am <dbl>, gear <dbl>, carb <dbl>\n\n\n\n\nview\nОпределение\nВыводит отображение фрейма данных в отдельное окно. Опять же не так актуально при работе с данными в блокноте.\n\nview(as_tibble(mtcars), title = 'Date frame', n = 10)"
  },
  {
    "objectID": "r_language/Tidyverse/tibble_tidyverse.html#обработка-векторов",
    "href": "r_language/Tidyverse/tibble_tidyverse.html#обработка-векторов",
    "title": "Tibble",
    "section": "Обработка векторов",
    "text": "Обработка векторов\nnum\nОпределение\nСоздает числовой вектор, которорый можно отформатировать\nАтрибуты метода:\n\n\nx - числовой вектор\n\nsigfig - задает количество значащих цифр, не комбинируется с digits\n\n\ndigits - количество отображаемых цифр после десятичных знаков, не комбинируется с sigfig\n\n\nlabel - метка столбца вместо отображения типа\n\nscale - множитель применяемый перед отображением\n\nnotation - нотация отображения\n\n\nfit - десятичная нотация, используется если поле содержит 13 и меньше цифр\n\ndec - десятичная нотация, не зависящая от ширины\n\nsci - научная нотация\n\neng - инженерная нотация (научная нотация использующая показатели равные трем)\n\nsi - система SI (поддерживаются префиксы между 1e-24 и 1e24)\n\n\n\nfixed_exponent - задает показатель степени для всех чисел в научной, инженерной системе счисления или системе SI\n\nextra_sigfig -\n\nИспользование\n\ndf <- tibble(\n  x   = num(9:11 * 100 + 0.5, label = \"базовый\"),\n  x0  = num(9:11 * 100 + 0.5, digits = 0,       label = \"dig 0\"),\n  x1  = num(9:11 * 100 + 0.5, digits = -1,      label = \"dig -1\"),\n  x2  = num(9:11 * 100 + 0.5, digits = -2,      label = \"dig -2\"),\n  x3  = num(9:11 * 100 + 0.5, digits = 2,       label = \"dig 2\"),\n  x4  = num(9:11 * 100 + 0.5, sigfig = 3,       label = \"sig 3\"),\n  x5  = num(9:11 * 100 + 0.5, sigfig = 4,       label = \"sig 4\"),\n  x6  = num(9:11 * 100 + 0.5, sigfig = 5,       label = \"sig 5\"),\n  x7  = num(9:11 * 100 + 0.5, scale = 10,       label = \"scale 10\"),\n  x8  = num(9:11 * 100 + 0.5, scale = 100,      label = \"scale 100\"),\n  x9  = num(9:11 * 100 + 0.5, scale = 0.1,      label = \"scale 0.1\"),\n  x10 = num(9:11 * 100 + 0.5, notation = \"sci\", label = \"sci\"),\n  x11 = num(9:11 * 100 + 0.5, notation = \"eng\", label = \"eng\"),\n  x12 = num(9:11 * 100 + 0.5, notation = \"si\",  label = \"si\"),\n  x13 = num(9:11 * 100 + 0.5, notation = \"dec\", label = \"dec\"),\n) \n\nprint(df, width = 200)\n\n# A tibble: 3 × 15\n        x    x0     x1     x2      x3    x4     x5     x6       x7        x8\n  базовый dig 0 dig -1 dig -2   dig 2 sig 3  sig 4  sig 5 scale 10 scale 100\n1    900.  900.  900.5  900.5  900.50  900.  900.5  900.5     9005     90050\n2   1000. 1000. 1000.5 1000.5 1000.50 1000. 1000.  1000.5    10005    100050\n3   1100. 1100. 1100.5 1100.5 1100.50 1100. 1100.  1100.5    11005    110050\n         x9    x10      x11     x12   x13\n  scale 0.1    sci      eng      si   dec\n1      90.1 9.01e2 900.  e0 900.     900.\n2     100.  1.00e3   1.00e3   1.00k 1000.\n3     110.  1.10e3   1.10e3   1.10k 1100.\n\n\n\ntibble(\n  scismall = num(10^(-7:6) * 123, notation = \"sci\", fixed_exponent = -3),\n  scilarge = num(10^(-7:6) * 123, notation = \"sci\", fixed_exponent = 3),\n  scimax   = num(10^(-7:6) * 123, notation = \"sci\", fixed_exponent = Inf)\n)\n\n# A tibble: 14 × 3\n            scismall          scilarge            scimax\n               [e-3]              [e3]              [e8]\n 1            0.0123      0.0000000123 0.000000000000123\n 2            0.123       0.000000123  0.00000000000123 \n 3            1.23        0.00000123   0.0000000000123  \n 4           12.3         0.0000123    0.000000000123   \n 5          123           0.000123     0.00000000123    \n 6         1230           0.00123      0.0000000123     \n 7        12300           0.0123       0.000000123      \n 8       123000           0.123        0.00000123       \n 9      1230000           1.23         0.0000123        \n10     12300000          12.3          0.000123         \n11    123000000         123            0.00123          \n12   1230000000        1230            0.0123           \n13  12300000000       12300            0.123            \n14 123000000000      123000            1.23             \n\n\n\ntibble(\n  default = num(100 + 1:3 * 0.001),\n  extra1 = num(100 + 1:3 * 0.001, extra_sigfig = TRUE),\n  extra2 = num(100 + 1:3 * 0.0001, extra_sigfig = TRUE),\n  extra3 = num(10000 + 1:3 * 0.00001, extra_sigfig = TRUE)\n)\n\n# A tibble: 3 × 4\n  default  extra1   extra2      extra3\n    <num>   <num>    <num>       <num>\n1    100. 100.001 100.0001 10000.00001\n2    100. 100.002 100.0002 10000.00002\n3    100. 100.003 100.0003 10000.00003\n\n\nchar\nОпределение\nСоздает вектор символов, который может быть отформатирован с заданной минимальной шириной или без ограничений по ширине, и в котором можно настроить стиль аббревиатуры.\nАтрибуты метода:\n\n\nx - символьный вектор\n\nmin_chars - Минимальная ширина, выделяемая для этого столбца, по умолчанию равна 15\n\nshorten - задает сокращение и его стиль\n\n\nback - добавляет многоточие в конце (по умолчанию)\n\nfront - добавляет многоточие спереди\n\nmid - добавляет многоточие по середине\n\nabbreviate - использование аббревиатуры\n\n\n\nИспользование\nchar(x, ..., min_chars = NULL,shorten = c(\"back\", \"front\", \"mid\", \"abbreviate\"))\n\nlipsum <- unlist(strsplit(stringi::stri_rand_lipsum(1), \"(?<=[.]) +\", perl = TRUE))\ntibble(\n  x = char(lipsum, min_chars = 15),\n  x0 = char(lipsum, min_chars = 10),\n  x1 = char(lipsum, min_chars = 10, shorten = 'back'),\n  x2 = char(lipsum, min_chars = 10, shorten = 'front'),\n  x3 = char(lipsum, min_chars = 10, shorten = 'mid'),\n  x4 = char(lipsum, min_chars = 10, shorten = 'abbreviate')\n)\n\n# A tibble: 12 × 6\n   x                      x0         x1         x2         x3         x4        \n   <char>                 <char>     <char>     <char>     <char>     <char>    \n 1 Lorem ipsum dolor sit… Lorem ips… Lorem ips… … integer. Lore…eger. Lidsapsps…\n 2 Nec proin volutpat.    Nec proin… Nec proin… …volutpat. Nec …tpat. Ncprvltpt.\n 3 Elementum non nisi se… Elementum… Elementum… …c sed ac. Elem…d ac. Ennselvfn…\n 4 Mollis justo ut sed a… Mollis ju… Mollis ju… …habitant. Moll…tant. Mjusanahb.\n 5 Ultricies felis adipi… Ultricies… Ultricies… … a at ex. Ultr…t ex. Ufadp,aae.\n 6 Orci neque sagittis c… Orci nequ… Orci nequ… …d sapien. Orci…pien. Onscv,apss\n 7 Torquent quis malesua… Torquent … Torquent … … quis ac. Torq…s ac. Tqmanaqac.\n 8 Bibendum in in vitae.  Bibendum … Bibendum … …in vitae. Bibe…itae. Bbndmiivt.\n 9 Erat eget et nisi, no… Erat eget… Erat eget… …e, etiam. Erat…tiam. Eeen,ncv,e\n10 Eu eleifend tellus to… Eu eleife… Eu eleife… …m libero. Eu e…bero. Eettpammbl\n11 Et etiam feugiat cum … Et etiam … Et etiam … … cum est. Et e… est. Etetfcest.\n12 Sem auctor augue moll… Sem aucto… Sem aucto… …e mollis. Sem …llis. Smacamlls.\n\n\nlst\nОпределение\nСоздает список с последовательным определением компонентов и автоматической генерацией отсутствующих имен. При определении компонента можно ссылаться на компоненты, созданные ранее в вызове\nИспользование\nlst(...)\n\ntibble(\n  lst(1:3, z = letters[4:6], runif(3))\n)\n\n# A tibble: 3 × 1\n  `lst(1:3, z = letters[4:6], runif(3))`\n  <named list>                          \n1 <int [3]>                             \n2 <chr [3]>                             \n3 <dbl [3]>                             \n\n\nenframe\nОпределение\nпреобразует именованные атомарные векторы или списки в фреймы данных с одним или двумя столбцами. Для списка результатом будет вложенный tibble со столбцом типа list. Для безымянных векторов в качестве столбца name используется естественная последовательность.\nАтрибуты метода:\n\n\nx - вектор\n\nname, value - имена столбцов, в которых хранятся имена и значения\n\nИспользование\nenframe(x, name = \"name\", value = \"value\")\n\n\n\nenframe(1:3)\n\n# A tibble: 3 × 2\n   name value\n  <int> <int>\n1     1     1\n2     2     2\n3     3     3\n\n\n\nenframe(c(a = 5, b = 7))\n\n# A tibble: 2 × 2\n  name  value\n  <chr> <dbl>\n1 a         5\n2 b         7\n\n\n\nenframe(list(one = 1, two = 2:3, three = 4:6))\n\n# A tibble: 3 × 2\n  name  value    \n  <chr> <list>   \n1 one   <dbl [1]>\n2 two   <int [2]>\n3 three <int [3]>\n\n\n\n\ndeframe\nОпределение\nпреобразует фреймы данных из двух столбцов в именованный вектор или список, используя первый столбец в качестве имени, а второй - в качестве значения. Если входные данные содержат только один столбец, возвращается безымянный вектор.\nАтрибуты метода:\n\n\nx - фрейм данных с одним или двумя столбцами\n\nИспользование\ndeframe(x)\n\n\n\ndeframe(enframe(3:1))\n\n1 2 3 \n3 2 1 \n\n\n\ndeframe(tibble(a = 1:3))\n\n[1] 1 2 3\n\n\n\ndeframe(tibble(a = as.list(1:3)))\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3"
  },
  {
    "objectID": "r_language/Tidyverse/tibble_tidyverse.html#проверки",
    "href": "r_language/Tidyverse/tibble_tidyverse.html#проверки",
    "title": "Tibble",
    "section": "Проверки",
    "text": "Проверки\nis_tibble\nОпределение\nПроверяет относится ли объект к tibbles или его подклассу\nИспользование\nis_tibble(x)\n\n\n\nx <- tibble(a = 1:3)\nis_tibble(x)\n\n[1] TRUE\n\n\n\ny <- data.frame(a = 1:3)\nis_tibble(y)\n\n[1] FALSE\n\n\n\n\nvalidate_tibble\nОпределение\nВыполняет проверки требований к Tibble, таких как:\n\nдлину столбцов и соответствие vectors::vec_size() данным\nстолбцы являютс векторами\\фреймами или матрицами\nналичие “минимальных” имен\n\nИспользование\nvalidate_tibble(x)\n\ntry(validate_tibble(new_tibble(trees, nrow = 3)))\n\nError : Tibble columns must have compatible sizes.\n• Size 3: Requested with `nrow` argument.\n• Size 31: Columns `Girth`, `Height`, and `Volume`.\nℹ Only values of size one are recycled."
  },
  {
    "objectID": "r_language/Tidyverse/tibble_tidyverse.html#манипуляция-данными",
    "href": "r_language/Tidyverse/tibble_tidyverse.html#манипуляция-данными",
    "title": "Tibble",
    "section": "Манипуляция данными",
    "text": "Манипуляция данными\nadd_row\nОпределение\nДобавляет новую строку во фрейм данных\nАтрибуты метода:\n.before, .after - индекс строки куда нужно добавить новую строку, по умолчанию добавляет в конец\nИспользование\nadd_row(.data, ..., .before = NULL, .after = NULL)\n\n\n\ndf <- tibble(x = 1:3, y = 3:1)\ndf\n\n# A tibble: 3 × 2\n      x     y\n  <int> <int>\n1     1     3\n2     2     2\n3     3     1\n\n\n\ndf %>% \n  add_row(x = 4, y = 0)\n\n# A tibble: 4 × 2\n      x     y\n  <dbl> <dbl>\n1     1     3\n2     2     2\n3     3     1\n4     4     0\n\n\n\ndf %>% \n  add_row(x = 4, y = 0, .before = 2)\n\n# A tibble: 4 × 2\n      x     y\n  <dbl> <dbl>\n1     1     3\n2     4     0\n3     2     2\n4     3     1\n\n\n\ndf %>% \n  add_row(x = 4:5, y = 0:-1)\n\n# A tibble: 5 × 2\n      x     y\n  <int> <int>\n1     1     3\n2     2     2\n3     3     1\n4     4     0\n5     5    -1\n\n\n\ndf %>% \n  add_row(tibble_row(x = 4, y = 0))\n\n# A tibble: 4 × 2\n      x     y\n  <dbl> <dbl>\n1     1     3\n2     2     2\n3     3     1\n4     4     0\n\n\n\n\nadd_column\nОпределение\nДобавляет один или несколько столбцов во фрейм данных\nАтрибуты метода:\n\n\n.before, .after - индекс или имя столбца докоторого нужно добавлять новый столбец\n\n.name_repair - проверка имен столбцов, типы проверок аналогичны используемым при создании tibble\n\nИспользование\nadd_column(.data,...,.before = NULL,.after = NULL,.name_repair = c(\"check_unique\", \"unique\", \"universal\", \"minimal\"))\n\n\n\ndf <- tibble(x = 1:3, y = 3:1)\ndf\n\n# A tibble: 3 × 2\n      x     y\n  <int> <int>\n1     1     3\n2     2     2\n3     3     1\n\n\n\ndf %>% \n  add_column(z = -1:1, w = 0)\n\n# A tibble: 3 × 4\n      x     y     z     w\n  <int> <int> <int> <dbl>\n1     1     3    -1     0\n2     2     2     0     0\n3     3     1     1     0\n\n\n\ndf %>% \n  add_column(z = -1:1, .before = \"y\")\n\n# A tibble: 3 × 3\n      x     z     y\n  <int> <int> <int>\n1     1    -1     3\n2     2     0     2\n3     3     1     1"
  },
  {
    "objectID": "r_language/Tidyverse/tibble_tidyverse.html#приведение-типов",
    "href": "r_language/Tidyverse/tibble_tidyverse.html#приведение-типов",
    "title": "Tibble",
    "section": "Приведение типов",
    "text": "Приведение типов\nas_tibble\nОпределение\nПриводит фрейм данных или матрицу к объекту tibble с классом tbl_df\nИспользование\n```{r}\nas_tibble(\n  x,\n  ...,\n  .rows = NULL,\n  .name_repair = c(\"check_unique\", \"unique\", \"universal\", \"minimal\"),\n  rownames = pkgconfig::get_config(\"tibble::rownames\", NULL)\n)\n```\n\nm <- matrix(rnorm(50), ncol = 5)\ncolnames(m) <- c(\"a\", \"b\", \"c\", \"d\", \"e\")\ndf <- as_tibble(m)\ndf\n\n# A tibble: 10 × 5\n        a       b      c       d      e\n    <dbl>   <dbl>  <dbl>   <dbl>  <dbl>\n 1 -0.531 -1.02    0.490  0.160   0.338\n 2  0.718 -0.604   0.120 -1.64    0.544\n 3 -1.46   0.626   0.813 -0.811  -0.409\n 4 -0.449 -1.36    1.48   1.59   -0.186\n 5  0.262  0.473   1.28   0.508   1.13 \n 6 -1.27   0.898   0.918 -0.714   0.466\n 7 -0.826 -0.263  -1.02   0.503   1.07 \n 8 -0.508 -0.0754  0.249  0.926  -0.929\n 9 -1.23   1.12   -1.07   2.74    1.47 \n10  0.575  0.901   2.14  -0.0107 -1.46 \n\n\nas_tibble_row\nОпределение\nПреобразует вектор в tibble с одной строкой. Если ввод представляет собой список, все элементы должны иметь один размер\nИспользование`\nas_tibble_row(x, .name_repair = c(\"check_unique\", \"unique\", \"universal\", \"minimal\"))\n\n\n\nas_tibble_row(c(a = 1, b = 2))\n\n# A tibble: 1 × 2\n      a     b\n  <dbl> <dbl>\n1     1     2\n\n\n\nas_tibble_row(list(c = \"three\", d = list(4:5)))\n\n# A tibble: 1 × 2\n  c     d        \n  <chr> <list>   \n1 three <int [2]>\n\n\n\nas_tibble_row(1:3, .name_repair = \"unique\")\n\nNew names:\n• `` -> `...1`\n• `` -> `...2`\n• `` -> `...3`\n\n\n# A tibble: 1 × 3\n   ...1  ...2  ...3\n  <int> <int> <int>\n1     1     2     3\n\n\n\n\nas_tibble_col\nОпределение\nПреобразует вектор в tibble с одним столбцом\nИспользование\nas_tibble_col(x, column_name = \"value\")\n\n\n\nas_tibble_col(1:3)\n\n# A tibble: 3 × 1\n  value\n  <int>\n1     1\n2     2\n3     3\n\n\n\nas_tibble_col(\n  list(c = \"three\", d = list(4:5)),\n  column_name = \"data\"\n)\n\n# A tibble: 2 × 1\n  data        \n  <named list>\n1 <chr [1]>   \n2 <list [1]>"
  },
  {
    "objectID": "r_language/Tidyverse/tibble_tidyverse.html#обработка-имен-строк",
    "href": "r_language/Tidyverse/tibble_tidyverse.html#обработка-имен-строк",
    "title": "Tibble",
    "section": "Обработка имен строк",
    "text": "Обработка имен строк\nРассмотрим обработку имен строк на примере фрейма данных mtcars\n\nmtcars\n\n# A tibble: 32 × 11\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n# … with 22 more rows\n\n\nhas_rownames\nОпределение\nПроверяет есть ли во фрейме имена строк\nИспользование\nhas_rownames(.data)\n\n\n\nhas_rownames(mtcars)\n\n[1] TRUE\n\n\n\nhas_rownames(trees)\n\n[1] FALSE\n\n\n\n\nremove_rownames\nОпределение\nУдаляет имена строк из фрейма данных\nИспользование\nremove_rownames(.data)\n\nremove_rownames(mtcars) %>% \n  has_rownames()\n\n[1] FALSE\n\n\nrownames_to_column\nОпределение\nПреобразует имена строк в столбец\nИспользование\nrownames_to_column(.data, var = \"rowname\")\n\n\n\nmtcars\n\n# A tibble: 32 × 11\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n# … with 22 more rows\n\n\n\nmtcars_tbl <- rownames_to_column(mtcars, var = \"car\") %>% \n  as_tibble()\n\nmtcars_tbl\n\n# A tibble: 32 × 12\n   car           mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <chr>       <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1 Mazda RX4    21       6  160    110  3.9   2.62  16.5     0     1     4     4\n 2 Mazda RX4 …  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n 3 Datsun 710   22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n 4 Hornet 4 D…  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n 5 Hornet Spo…  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n 6 Valiant      18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n 7 Duster 360   14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n 8 Merc 240D    24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n 9 Merc 230     22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n10 Merc 280     19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n# … with 22 more rows\n\n\n\n\ncolumn_to_rownames\nОпределение\nПреобразует столбец в имена строк\nИспользование\ncolumn_to_rownames(.data, var = \"rowname\")\n\ncolumn_to_rownames(mtcars_tbl, var = \"car\") %>% head()\n\n# A tibble: 6 × 11\n    mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1  21       6   160   110  3.9   2.62  16.5     0     1     4     4\n2  21       6   160   110  3.9   2.88  17.0     0     1     4     4\n3  22.8     4   108    93  3.85  2.32  18.6     1     1     4     1\n4  21.4     6   258   110  3.08  3.22  19.4     1     0     3     1\n5  18.7     8   360   175  3.15  3.44  17.0     0     0     3     2\n6  18.1     6   225   105  2.76  3.46  20.2     1     0     3     1\n\n\nrowid_to_column\nОпределение\nДобавляет столбец с идентификатором и удаляет все имена строк\nИспользование\nrowid_to_column(.data, var = \"rowid\")\n\nrowid_to_column(trees) %>% \n  head()\n\n# A tibble: 6 × 4\n  rowid Girth Height Volume\n  <int> <dbl>  <dbl>  <dbl>\n1     1   8.3     70   10.3\n2     2   8.6     65   10.3\n3     3   8.8     63   10.2\n4     4  10.5     72   16.4\n5     5  10.7     81   18.8\n6     6  10.8     83   19.7"
  },
  {
    "objectID": "r_language/Tidyverse/tibble_tidyverse.html#о-tibble",
    "href": "r_language/Tidyverse/tibble_tidyverse.html#о-tibble",
    "title": "Tibble",
    "section": "О tibble",
    "text": "О tibble\nКласс tbl_df является подклассом data.frame, созданным для того, чтобы иметь другое поведение по умолчанию. Разговорный термин “tibble” относится к фрейму данных, который имеет класс tbl_df.\nУ класса tbl_df следующие зависимости:\n\nатрибуты класса: c(“tbl_df”, “tbl”, “data.frame”)\nбазовый элемент - вектор, где каждый элемент имеет один и тот же vctrs::vec_size()\n\nатрибут names, представляющий собой вектор символов той же длины, что и базовый список\nатрибут row.names, включенный для совместимости с data.frame. К этому атрибуту обращаются только для запроса количества строк, любые имена строк, которые могут там храниться, игнорируются большинством методов tibble.\n\nПоведение объектов класса tbl_df\n\nсимвольные вектора не приводятся к факторам\nимена столбцов не изменяются\nПереработка происходит только для входных данных длиной 1 vctrs::vec_recycle()\n\nИмена столбцов не заполняются, хотя отсутствующие имена заполняются автоматически. Пустые и дублирующиеся имена столбцов категорически не рекомендуются, но пользователь должен указать, как их разрешить. Подробнее читайте в vctrs::vec_as_names()\n\nИмена строк не добавляются и настоятельно не рекомендуются в пользу сохранения этой информации в виде столбца. Читайте об этом в именах строк\n\ndf[, j] возвращает tibble; он не извлекает автоматически столбец внутри. значение по умолчанию - df[, j, drop = FALSE]. Подробнее читайте в разделе подмножество"
  },
  {
    "objectID": "r_language/Tidyverse/tibble_tidyverse.html#наследование-от-vctrs",
    "href": "r_language/Tidyverse/tibble_tidyverse.html#наследование-от-vctrs",
    "title": "Tibble",
    "section": "Наследование от vctrs",
    "text": "Наследование от vctrs"
  },
  {
    "objectID": "r_language/Tidyverse/tibble_tidyverse.html#производительность",
    "href": "r_language/Tidyverse/tibble_tidyverse.html#производительность",
    "title": "Tibble",
    "section": "Производительность",
    "text": "Производительность\nВыполним простой тест производительности объекта tibble и data.frame\n\n# пакет для замера производительности\n#| column-page-inset-left\n\nl <- replicate(26, sample(100), simplify = FALSE)\nnames(l) <- letters\n\ntiming <- bench::mark(\n  as_tibble(l),\n  as.data.frame(l),\n  tibble(l),\n  new_tibble(l),\n  check = FALSE\n)\n\nprint(timing )\n\n# A tibble: 4 × 13\n  expression            min  median itr/s…¹ mem_al…² gc/se…³ n_itr  n_gc total…⁴\n  <bch:expr>       <bch:tm> <bch:t>   <dbl> <bch:by>   <dbl> <int> <dbl> <bch:t>\n1 as_tibble(l)      143.2µs   152µs   6146.    7.6KB   16.9   2904     8   472ms\n2 as.data.frame(l)  761.4µs   819µs   1176.  31.51KB   15.2    541     7   460ms\n3 tibble(l)           267µs   349µs   2090.   1.63KB    8.36  1000     4   478ms\n4 new_tibble(l)       7.3µs     9µs  82156.     256B   16.4   9998     2   122ms\n# … with 4 more variables: result <list>, memory <list>, time <list>,\n#   gc <list>, and abbreviated variable names ¹​`itr/sec`, ²​mem_alloc,\n#   ³​`gc/sec`, ⁴​total_time\n\n\nРасшифровка результатов:\n\n\nexpression - анализируемое выражение\n\nmin - минимальное время выполнения\n\nmedian - медиана времени выполнения\n\nitr/sec - расчетное количество выполнений в секунду\n\nmem_alloc - общий объем памяти, выделенный R при выполнении выражения\n\ngc/sec - количество сборок мусора в секунду\n\nn_itr - общее количество итераций после фильтрации сборок мусора\n\nn_gc - общее количество сборок мусора, выполненных за все итерации\n\ntotal_time - общее время выполнения тестов\n\nresult - список объектов, возвращенных оцениваемым выражением\n\nmemory - список с результатами Rprofmem()\n\ntime - список векторов Bench_time для каждого оцениваемого выражения\n\ngc - список с таблицами, содержащими уровень сборки мусора (0-2, столбцы) для каждой итерации (строки)."
  },
  {
    "objectID": "r_language/Tidyverse/tibble_tidyverse.html#поддерживаемые-типы-данных",
    "href": "r_language/Tidyverse/tibble_tidyverse.html#поддерживаемые-типы-данных",
    "title": "Tibble",
    "section": "Поддерживаемые типы данных",
    "text": "Поддерживаемые типы данных\n\n\n\n\n\n\n\n\nClass\nData type\nExample\nColumn header\n\n\n\nAtomic\nlogical\nTRUE\nlgl\n\n\n-\ninteger\n1L\nint\n\n\n-\ndouble\n1.5\ndbl\n\n\n-\ncharacter\n“A”\nchr\n\n\n-\ncomplex\n0+1i\ncpl\n\n\n-\nraw\nas.raw(1)\nraw\n\n\n-\nlist\nlist(1)\nlist\n\n\n-\nnamed list\nlist(a = 1)\nnamed list\n\n\nBuilt-in objects\nfactor\nfactor(“A”)\nfct\n\n\n-\nordered\nordered(“a”)\nord\n\n\n-\nDate\nSys.Date()\ndate\n\n\n-\nPOSIXt\nSys.time()\ndttm\n\n\n-\ndifftime\nvctrs::new_duration(1)\ndrtn\n\n\nObjects from other packages\nhms\nhms::hms(1)\ntime\n\n\n-\ninteger64\nbit64::as.integer64(1e+10)\nint64\n\n\n-\nblob\nblob::blob(raw(1))\nblob\n\n\nData frames\ndata.frame\ndata.frame(a = 1)\ndf[,1]\n\n\n-\ntbl_df\ntibble(a = 1)\ntibble[,1]\n\n\nUnchanged\nAsIs\nI(1L)\nI\n\n\nvctrs types\nunspecified\nvctrs::unspecified(1)\n???\n\n\n-\nvctrs_list_of\nvctrs::list_of(c(1L))\nlist\n\n\n-\nvctrs_vctr\nvctrs::new_vctr(1L)\nvctrs_vc\n\n\n-\nvctrs_partial_factor\nvctrs::partial_factor(letters)\nprtl_fctr\n\n\n-\nvctrs_partial_frame\nvctrs::partial_frame(a = 1)\nprtl\n\n\nLanguage objects\nfunction\nfunction() NULL\nfn\n\n\n-\nsymbol\nquote(a)\nsym\n\n\n-\nexpression\nparse(text = “a <- 1<- 2”)\nexpression\n\n\n-\nquosures\nrlang::quos(a = 1)\nquos"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#обработка-групп",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#обработка-групп",
    "title": "Dplyr",
    "section": "Обработка групп",
    "text": "Обработка групп\n\ngroup_by\ngroup_by(.data, ..., .add = FALSE, .drop = group_by_drop_default(.data))\nФункция group_by() позволяет группировать данные по одному или нескольким столбцам, создавая объект “grouped_df”. Она принимает в качестве аргументов имена столбцов или переменные, по которым нужно провести группировку.\nАтрибуты:\n\n.data - набор данных\n... - поля по которым необходимо сгруппировать набор\n.add = FALSE - при значении FALSE функция group_by() по умолчанию переопределяет существующие группы. Чтобы добавить в существующие группы, используйте .add = TRUE.\n.drop = group_by_drop_default(.data) - удаляет группы, софрмированные по неотображаемым в наборе уровням фактора, по умолчанию TRUE\n\nПример использования:\n\n\n\n# Создаем таблицу данных\ndf &lt;- tibble(\n  group = rep(c(\"A\", \"B\"), each = 3),\n  x = rnorm(6), y = rnorm(6)\n)\ndf\n\n\n\n  \n\n\n\n\n# Группируем данные по столбцу \"group\"\ndf_grouped &lt;- df %&gt;%\n  group_by(group)\ndf_grouped\n\n\n\n  \n\n\n\n\n# Проверяем наличие группирующих переменных\ndf_grouped %&gt;%\n  group_vars()\n\n[1] \"group\"\n\n\n\n\nВ этом примере мы создали таблицу данных df с тремя столбцами: group, x и y. Затем мы использовали функцию group_by() для группировки данных по столбцу “group”, создав объект “grouped_df”. Наконец, мы использовали функцию group_vars чтобы проверить наличие в наборе группирующих переменных.\n\n\nМетаданные групп\nФункции из этого раздела дают дополнительную информацию о сгруппированном наборе данных и каждой отдельной группе внутри него.\n\ngroup_data\ngroup_data(.data)\nФункция возвращает фрейм данных, который определяет структуру группировки. В столбцах приведены значения группирующих переменных. Последний столбец, всегда называемый .rows, представляет собой список целочисленных векторов, который указывает расположение строк в каждой группе. По сути объединяет в себе результат работы функций group_keys и group_rows.\n\nstarwars %&gt;% \n  group_by(sex) %&gt;% \n  group_data()\n\n\n\n  \n\n\n\n\n\ngroup_keys\ngroup_keys(.tbl, ...)\nФункция возвращает набор данных описывающий группы\n\nstarwars %&gt;% \n  group_by(sex) %&gt;% \n  group_keys()\n\n\n\n  \n\n\n\n\n\ngroup_rows\ngroup_rows(.data)\nФункция возвращает список целочисленных векторов, содержащих строки, которые содержит каждая группа.\n\nstarwars %&gt;% \n  group_by(sex) %&gt;% \n  group_rows()\n\n&lt;list_of&lt;integer&gt;[5]&gt;\n[[1]]\n [1]  5  7 27 41 44 52 58 61 62 63 67 70 71 76 83 87\n\n[[2]]\n[1] 16\n\n[[3]]\n [1]  1  4  6  9 10 11 12 13 14 15 17 18 19 20 21 23 24 25 26 28 29 30 31 32 33\n[26] 34 35 36 38 39 42 43 45 46 47 48 49 50 51 53 54 55 56 57 59 60 64 65 66 68\n[51] 69 72 74 75 77 78 79 81 82 84\n\n[[4]]\n[1]  2  3  8 22 73 85\n\n[[5]]\n[1] 37 40 80 86\n\n\n\n\ngroup_indices\ngroup_indices(.data, ...)\nФункция возвращает целочисленный вектор той же длины, что и набор данных, который указывает группу, к которой принадлежит каждая строка.\n\nstarwars %&gt;% \n  group_by(sex) %&gt;% \n  group_indices()\n\n [1] 3 4 4 3 1 3 1 4 3 3 3 3 3 3 3 2 3 3 3 3 3 4 3 3 3 3 1 3 3 3 3 3 3 3 3 3 5 3\n[39] 3 5 1 3 3 1 3 3 3 3 3 3 3 1 3 3 3 3 3 1 3 3 1 1 1 3 3 3 1 3 3 1 1 3 4 3 3 1\n[77] 3 3 3 5 3 3 1 3 4 5 1\n\n\n\n\ngroup_vars\ngroup_vars(x) | groups(x)\nФункция group_vars(x) возвращает вектор содержащий имена группирующих переменных, а функция groups(x) в виде списка\n\n\n\nstarwars %&gt;% \n  group_by(sex) %&gt;% \n  group_vars()\n\n[1] \"sex\"\n\n\n\nstarwars %&gt;% \n  group_by(sex) %&gt;% \n  groups()\n\n[[1]]\nsex\n\n\n\n\n\n\ngroup_size\ngroup_size(x)\nФункция возвращает количество элементов в каждой группе\n\nstarwars %&gt;% \n  group_by(sex) %&gt;% \n  group_size()\n\n[1] 16  1 60  6  4\n\n\n\n\nn_groups\nn_groups(x)\nФункция возвращает количество групп в наборе данных\n\nstarwars %&gt;% \n  group_by(sex) %&gt;% \n  n_groups()\n\n[1] 5\n\n\n\n\n\nОписание группы\n\nn\nn()\nФункция возвращает количество элементов в каждой группе в виде набора данных\n\nstarwars %&gt;% \n  group_by(sex) %&gt;% \n  summarise(n = n())\n\n\n\n  \n\n\n\n\n\ncur_group\ncur_group()\nФункция возвращает ключи группы для каждой группирующей переменной в виде tibble с одной строкой и столбцами количество которых равно количеству группирующих переменных\n\nstarwars %&gt;% \n  group_by(sex, gender) %&gt;% \n  mutate(data = list(cur_group())) \n\n\n\n  \n\n\n\n\n\ncur_group_id\ncur_group_id()\nФункция задает уникальный идентификатор для текущей группы\n\nstarwars %&gt;% \n  group_by(sex, gender) %&gt;% \n  mutate(id = cur_group_id())\n\n\n\n  \n\n\n\n\n\ncur_group_rows\ncur_group_rows()\nФункция задает индексы строк для текущей группы\n\nstarwars %&gt;% \n  group_by(sex, gender) %&gt;% \n  reframe(row = cur_group_rows()) \n\n\n\n  \n\n\n\n\n\ncur_column\ncur_column()\nФункция возвращает имя текущего столбца и может применяться только с функцией across()\n\nstarwars %&gt;% \n  select(8,2,3) %&gt;% \n  group_by(sex) %&gt;% \n  mutate(across(everything(), ~ paste(cur_column(), round(.x, 2))))\n\n\n\n  \n\n\n\n\n\n\nФункции обработки групп\n\ngroup_map\ngroup_map(.data, .f, ..., .keep = FALSE)\ngroup_map() - это функция, которая позволяет применить к каждой группе данных заданную пользователем функцию. Результатом функции является список, каждый элемент которого содержит результат выполнения функции .f для соответствующей группы данных. Эта функция может быть полезна, когда требуется выполнить некоторую операцию над каждой группой данных, например, построить график или вычислить статистику.\nАргументы:\n\n.tbl - группированный data frame;\n.f - функция, которую требуется применить к каждой группе данных;\n… - дополнительные аргументы, которые будут переданы в функцию .f.\n\nПример использования:\n\nstarwars %&gt;% \n  group_by(sex) %&gt;% \n  group_map(~ quantile(.x$height, probs = c(0.25, 0.5, 0.75), na.rm = T))  \n\n[[1]]\n25% 50% 75% \n164 166 174 \n\n[[2]]\n25% 50% 75% \n175 175 175 \n\n[[3]]\n25% 50% 75% \n173 183 193 \n\n[[4]]\n25% 50% 75% \n 96  97 167 \n\n[[5]]\n  25%   50%   75% \n180.5 183.0 183.0 \n\n\nК сгруппированному набору применяем функцию quantile и выводим список c результатами работы функции примененной к каждой группе.\n\n\ngroup_modify\ngroup_modify(.data, .f, ..., .keep = FALSE)\nЭта функция используется для модификации каждой группы набора данных. В примере ниже сгруппируем набор по полю sex и в каждой группе оставим по одной верхней строке.\n\nstarwars %&gt;% \n  group_by(sex) %&gt;% \n  group_modify(~ head(.x, 1L))\n\n\n\n  \n\n\n\n\n\ngroup_walk\ngroup_walk(.data, .f, ..., .keep = FALSE)\nФункция возвращает данные каждой группы и без изменений передает их дальше. Это можно использовать для выполнения действий с данными из каждой группы внутри процесса не нарушая логику алгоритма. В примере ниже мы выводим на печать первые две строки из каждой группы в виде отдельного tibble, а дальше применяем функцию group_modify как в примере выше.\nВ примере документации показан вариант, где данные каждой группы сохраняются в отдельный файл:`\ngroup_walk(~ write.csv(.x, file = file.path(temp, paste0(.y$Species, \".csv\"))))\nМы же выведем на печать первую строку из каждой группы, а дальше применить функцию модификации групп, оставив в каждой по 2 первые строки\n\nstarwars %&gt;% \n  group_by(sex) %&gt;% \n  group_walk(~ print(head(.x, 1L))) %&gt;% \n  group_modify(~ head(.x, 2L))\n\n# A tibble: 1 × 13\n  name  height  mass hair_color skin_color eye_color birth_year gender homeworld\n  &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;    \n1 Leia…    150    49 brown      light      brown             19 femin… Alderaan \n# ℹ 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,\n#   starships &lt;list&gt;\n# A tibble: 1 × 13\n  name  height  mass hair_color skin_color eye_color birth_year gender homeworld\n  &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;    \n1 Jabb…    175  1358 &lt;NA&gt;       green-tan… orange           600 mascu… Nal Hutta\n# ℹ 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,\n#   starships &lt;list&gt;\n# A tibble: 1 × 13\n  name  height  mass hair_color skin_color eye_color birth_year gender homeworld\n  &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;    \n1 Luke…    172    77 blond      fair       blue              19 mascu… Tatooine \n# ℹ 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,\n#   starships &lt;list&gt;\n# A tibble: 1 × 13\n  name  height  mass hair_color skin_color eye_color birth_year gender homeworld\n  &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;    \n1 C-3PO    167    75 &lt;NA&gt;       gold       yellow           112 mascu… Tatooine \n# ℹ 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,\n#   starships &lt;list&gt;\n# A tibble: 1 × 13\n  name  height  mass hair_color skin_color eye_color birth_year gender homeworld\n  &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;    \n1 Ric …    183    NA brown      fair       blue              NA &lt;NA&gt;   Naboo    \n# ℹ 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,\n#   starships &lt;list&gt;\n\n\n\n\n  \n\n\n\n\n\ngroup_cols\ngroup_cols(vars = NULL, data = NULL)\nФункция позволяет выбирать к поля по которым выполнялась группировка, обычно используется при выборке данных. Таким образом с помощью group_cols можно обратиться ко всем полям по которым выполнялась группировка.\n\nstarwars %&gt;% \n  group_by(sex, gender) %&gt;% \n  select(group_cols())\n\n\n\n  \n\n\n\n\n\ngroup_split\ngroup_split(.tbl, ..., .keep = TRUE)\nФункция возвращает список отдельных групп данных, каждая из которых содержит только те строки, где значение переменных группировки соответствует данной группе.\nВ примере группируем набор по полю sex и разбиваем набор сформированным группам.\n\nstarwars %&gt;% \n  group_by(sex) %&gt;% \n  group_split()\n\n&lt;list_of&lt;\n  tbl_df&lt;\n    name      : character\n    height    : integer\n    mass      : double\n    hair_color: character\n    skin_color: character\n    eye_color : character\n    birth_year: double\n    sex       : character\n    gender    : character\n    homeworld : character\n    species   : character\n    films     : list\n    vehicles  : list\n    starships : list\n  &gt;\n&gt;[5]&gt;\n[[1]]\n# A tibble: 16 × 14\n   name     height  mass hair_color skin_color eye_color birth_year sex   gender\n   &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n 1 Leia Or…    150  49   brown      light      brown             19 fema… femin…\n 2 Beru Wh…    165  75   brown      light      blue              47 fema… femin…\n 3 Mon Mot…    150  NA   auburn     fair       blue              48 fema… femin…\n 4 Shmi Sk…    163  NA   black      fair       brown             72 fema… femin…\n 5 Ayla Se…    178  55   none       blue       hazel             48 fema… femin…\n 6 Adi Gal…    184  50   none       dark       blue              NA fema… femin…\n 7 Cordé       157  NA   brown      light      brown             NA fema… femin…\n 8 Luminar…    170  56.2 black      yellow     blue              58 fema… femin…\n 9 Barriss…    166  50   black      yellow     blue              40 fema… femin…\n10 Dormé       165  NA   brown      light      brown             NA fema… femin…\n11 Zam Wes…    168  55   blonde     fair, gre… yellow            NA fema… femin…\n12 Taun We     213  NA   none       grey       black             NA fema… femin…\n13 Jocasta…    167  NA   white      fair       blue              NA fema… femin…\n14 Shaak Ti    178  57   none       red, blue… black             NA fema… femin…\n15 Rey          NA  NA   brown      light      hazel             NA fema… femin…\n16 Padmé A…    165  45   brown      light      brown             46 fema… femin…\n# ℹ 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,\n#   vehicles &lt;list&gt;, starships &lt;list&gt;\n\n[[2]]\n# A tibble: 1 × 14\n  name      height  mass hair_color skin_color eye_color birth_year sex   gender\n  &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n1 Jabba De…    175  1358 &lt;NA&gt;       green-tan… orange           600 herm… mascu…\n# ℹ 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,\n#   vehicles &lt;list&gt;, starships &lt;list&gt;\n\n[[3]]\n# A tibble: 60 × 14\n   name     height  mass hair_color skin_color eye_color birth_year sex   gender\n   &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n 1 Luke Sk…    172    77 blond      fair       blue            19   male  mascu…\n 2 Darth V…    202   136 none       white      yellow          41.9 male  mascu…\n 3 Owen La…    178   120 brown, gr… light      blue            52   male  mascu…\n 4 Biggs D…    183    84 black      light      brown           24   male  mascu…\n 5 Obi-Wan…    182    77 auburn, w… fair       blue-gray       57   male  mascu…\n 6 Anakin …    188    84 blond      fair       blue            41.9 male  mascu…\n 7 Wilhuff…    180    NA auburn, g… fair       blue            64   male  mascu…\n 8 Chewbac…    228   112 brown      unknown    blue           200   male  mascu…\n 9 Han Solo    180    80 brown      fair       brown           29   male  mascu…\n10 Greedo      173    74 &lt;NA&gt;       green      black           44   male  mascu…\n# ℹ 50 more rows\n# ℹ 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,\n#   vehicles &lt;list&gt;, starships &lt;list&gt;\n\n[[4]]\n# A tibble: 6 × 14\n  name   height  mass hair_color skin_color  eye_color birth_year sex   gender  \n  &lt;chr&gt;   &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;   \n1 C-3PO     167    75 &lt;NA&gt;       gold        yellow           112 none  masculi…\n2 R2-D2      96    32 &lt;NA&gt;       white, blue red               33 none  masculi…\n3 R5-D4      97    32 &lt;NA&gt;       white, red  red               NA none  masculi…\n4 IG-88     200   140 none       metal       red               15 none  masculi…\n5 R4-P17     96    NA none       silver, red red, blue         NA none  feminine\n6 BB8        NA    NA none       none        black             NA none  masculi…\n# ℹ 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,\n#   vehicles &lt;list&gt;, starships &lt;list&gt;\n\n[[5]]\n# A tibble: 4 × 14\n  name      height  mass hair_color skin_color eye_color birth_year sex   gender\n  &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n1 Ric Olié     183    NA brown      fair       blue              NA &lt;NA&gt;  &lt;NA&gt;  \n2 Quarsh P…    183    NA black      dark       brown             62 &lt;NA&gt;  &lt;NA&gt;  \n3 Sly Moore    178    48 none       pale       white             NA &lt;NA&gt;  &lt;NA&gt;  \n4 Captain …     NA    NA unknown    unknown    unknown           NA &lt;NA&gt;  &lt;NA&gt;  \n# ℹ 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,\n#   vehicles &lt;list&gt;, starships &lt;list&gt;\n\n\n\n\ngroup_trim\ngroup_trim(.tbl, .drop = group_by_drop_default(.tbl))\nЗадача функции заключается в удалении неиспользуемых уровней факторов, которые используются в качестве переменных для группировки, а затем пересчёта структуры группировки.\nЭта функция особенно полезна после применения функции filter(), которая выбирает подмножество групп. В результате применения filter() могут появиться неиспользуемые уровни факторов, что может привести к ошибкам или непредсказуемым результатам.\n\nstarwars %&gt;% \n  group_by(sex) %&gt;% \n  filter(sex == 'none') %&gt;% \n  group_trim()\n\n\n\n  \n\n\n\n\n\nrowwise\nrowwise(data, ...)\nФункция rowwise() позволяет выполнять вычисления для каждой строки входных данных. Это особенно полезно, когда векторизованная функция не подходит для вычислений. Вызов функции rowwise() создает так называемый “row-wise” data frame, в котором вычисления выполняются по каждой строке, сохраняя все переменные в строке.\nВ примере по строчно вычисляем наименьшее значение из трех числовых столбцов\n\nstarwars %&gt;% \n  select(c(1,2,3,7)) %&gt;% \n  rowwise() %&gt;% \n  mutate(m = min(c(height, mass, birth_year)))\n\n\n\n  \n\n\n\n\n\nc_across\n\n\nungroup\nungroup(x, ...)\nФункция удаляет группировку из набора данных\n\n\n\n# группируем набор по двум полям\nstarwars %&gt;% \n  group_by(sex, gender) %&gt;% \n# проверяем наличие группирующих переменных\n  group_vars()\n\n[1] \"sex\"    \"gender\"\n\n\n\n# группируем набор по двум полям\nstarwars %&gt;% \n  group_by(sex, gender) %&gt;% \n# удаляем группировку\n  ungroup() %&gt;% \n# проверяем наличие группирующих переменных\n  group_vars()\n\ncharacter(0)\n\n\n\n\n\n\n\nreframe"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#метаданные-групп",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#метаданные-групп",
    "title": "Dplyr",
    "section": "Метаданные групп",
    "text": "Метаданные групп"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#функции-обработки-групп",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#функции-обработки-групп",
    "title": "Dplyr",
    "section": "Функции обработки групп",
    "text": "Функции обработки групп\n\ngroup_map\ngroup_map(.data, .f, ..., .keep = FALSE)\ngroup_map() - это функция, которая позволяет применить к каждой группе данных заданную пользователем функцию. Результатом функции является список, каждый элемент которого содержит результат выполнения функции .f для соответствующей группы данных. Эта функция может быть полезна, когда требуется выполнить некоторую операцию над каждой группой данных, например, построить график или вычислить статистику.\nАргументы:\n\n.tbl - группированный data frame;\n.f - функция, которую требуется применить к каждой группе данных;\n… - дополнительные аргументы, которые будут переданы в функцию .f.\n\nПример использования:\n\nstarwars %&gt;% \n  group_by(sex) %&gt;% \n  group_map(~ quantile(.x$height, probs = c(0.25, 0.5, 0.75), na.rm = T))  \n\n[[1]]\n25% 50% 75% \n164 166 174 \n\n[[2]]\n25% 50% 75% \n175 175 175 \n\n[[3]]\n25% 50% 75% \n173 183 193 \n\n[[4]]\n25% 50% 75% \n 96  97 167 \n\n[[5]]\n  25%   50%   75% \n180.5 183.0 183.0 \n\n\nК сгруппированному набору применяем функцию quantile и выводим список c результатами работы функции примененной к каждой группе.\n\n\ngroup_modify\ngroup_modify(.data, .f, ..., .keep = FALSE)\nЭта функция используется для модификации каждой группы набора данных. В примере ниже сгруппируем набор по полю sex и в каждой группе оставим по одной верхней строке.\n\nstarwars %&gt;% \n  group_by(sex) %&gt;% \n  group_modify(~ head(.x, 1L))\n\n\n\n  \n\n\n\n\n\ngroup_walk\ngroup_walk(.data, .f, ..., .keep = FALSE)\nФункция возвращает данные каждой группы и без изменений передает их дальше. Это можно использовать для выполнения действий с данными из каждой группы внутри процесса не нарушая логику алгоритма. В примере ниже мы выводим на печать первые две строки из каждой группы в виде отдельного tibble, а дальше применяем функцию group_modify как в примере выше.\nВ примере документации показан вариант, где данные каждой группы сохраняются в отдельный файл:`\ngroup_walk(~ write.csv(.x, file = file.path(temp, paste0(.y$Species, \".csv\"))))\n\nstarwars %&gt;% \n  group_by(sex) %&gt;% \n  group_walk(~ print(head(.x, 2L))) %&gt;% \n  group_modify(~ head(.x, 1L))\n\n# A tibble: 2 × 13\n  name  height  mass hair_color skin_color eye_color birth_year gender homeworld\n  &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;    \n1 Leia…    150    49 brown      light      brown             19 femin… Alderaan \n2 Beru…    165    75 brown      light      blue              47 femin… Tatooine \n# ℹ 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,\n#   starships &lt;list&gt;\n# A tibble: 1 × 13\n  name  height  mass hair_color skin_color eye_color birth_year gender homeworld\n  &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;    \n1 Jabb…    175  1358 &lt;NA&gt;       green-tan… orange           600 mascu… Nal Hutta\n# ℹ 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,\n#   starships &lt;list&gt;\n# A tibble: 2 × 13\n  name  height  mass hair_color skin_color eye_color birth_year gender homeworld\n  &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;    \n1 Luke…    172    77 blond      fair       blue            19   mascu… Tatooine \n2 Dart…    202   136 none       white      yellow          41.9 mascu… Tatooine \n# ℹ 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,\n#   starships &lt;list&gt;\n# A tibble: 2 × 13\n  name  height  mass hair_color skin_color eye_color birth_year gender homeworld\n  &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;    \n1 C-3PO    167    75 &lt;NA&gt;       gold       yellow           112 mascu… Tatooine \n2 R2-D2     96    32 &lt;NA&gt;       white, bl… red               33 mascu… Naboo    \n# ℹ 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,\n#   starships &lt;list&gt;\n# A tibble: 2 × 13\n  name  height  mass hair_color skin_color eye_color birth_year gender homeworld\n  &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;    \n1 Ric …    183    NA brown      fair       blue              NA &lt;NA&gt;   Naboo    \n2 Quar…    183    NA black      dark       brown             62 &lt;NA&gt;   Naboo    \n# ℹ 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,\n#   starships &lt;list&gt;\n\n\n\n\n  \n\n\n\n\n\ngroup_cols\ngroup_cols(vars = NULL, data = NULL)\nФункция позволяет выбирать к поля по которым выполнялась группировка, обычно используется при выборке данных. Таким образом с помощью group_cols можно обратиться ко всем полям по которым выполнялась группировка.\n\nstarwars %&gt;% \n  group_by(sex, gender) %&gt;% \n  select(group_cols())\n\n\n\n  \n\n\n\n\nstarwars %&gt;% \n  group_by(sex, gender) %&gt;% \n  group_split()\n\n&lt;list_of&lt;\n  tbl_df&lt;\n    name      : character\n    height    : integer\n    mass      : double\n    hair_color: character\n    skin_color: character\n    eye_color : character\n    birth_year: double\n    sex       : character\n    gender    : character\n    homeworld : character\n    species   : character\n    films     : list\n    vehicles  : list\n    starships : list\n  &gt;\n&gt;[6]&gt;\n[[1]]\n# A tibble: 16 × 14\n   name     height  mass hair_color skin_color eye_color birth_year sex   gender\n   &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n 1 Leia Or…    150  49   brown      light      brown             19 fema… femin…\n 2 Beru Wh…    165  75   brown      light      blue              47 fema… femin…\n 3 Mon Mot…    150  NA   auburn     fair       blue              48 fema… femin…\n 4 Shmi Sk…    163  NA   black      fair       brown             72 fema… femin…\n 5 Ayla Se…    178  55   none       blue       hazel             48 fema… femin…\n 6 Adi Gal…    184  50   none       dark       blue              NA fema… femin…\n 7 Cordé       157  NA   brown      light      brown             NA fema… femin…\n 8 Luminar…    170  56.2 black      yellow     blue              58 fema… femin…\n 9 Barriss…    166  50   black      yellow     blue              40 fema… femin…\n10 Dormé       165  NA   brown      light      brown             NA fema… femin…\n11 Zam Wes…    168  55   blonde     fair, gre… yellow            NA fema… femin…\n12 Taun We     213  NA   none       grey       black             NA fema… femin…\n13 Jocasta…    167  NA   white      fair       blue              NA fema… femin…\n14 Shaak Ti    178  57   none       red, blue… black             NA fema… femin…\n15 Rey          NA  NA   brown      light      hazel             NA fema… femin…\n16 Padmé A…    165  45   brown      light      brown             46 fema… femin…\n# ℹ 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,\n#   vehicles &lt;list&gt;, starships &lt;list&gt;\n\n[[2]]\n# A tibble: 1 × 14\n  name      height  mass hair_color skin_color eye_color birth_year sex   gender\n  &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n1 Jabba De…    175  1358 &lt;NA&gt;       green-tan… orange           600 herm… mascu…\n# ℹ 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,\n#   vehicles &lt;list&gt;, starships &lt;list&gt;\n\n[[3]]\n# A tibble: 60 × 14\n   name     height  mass hair_color skin_color eye_color birth_year sex   gender\n   &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n 1 Luke Sk…    172    77 blond      fair       blue            19   male  mascu…\n 2 Darth V…    202   136 none       white      yellow          41.9 male  mascu…\n 3 Owen La…    178   120 brown, gr… light      blue            52   male  mascu…\n 4 Biggs D…    183    84 black      light      brown           24   male  mascu…\n 5 Obi-Wan…    182    77 auburn, w… fair       blue-gray       57   male  mascu…\n 6 Anakin …    188    84 blond      fair       blue            41.9 male  mascu…\n 7 Wilhuff…    180    NA auburn, g… fair       blue            64   male  mascu…\n 8 Chewbac…    228   112 brown      unknown    blue           200   male  mascu…\n 9 Han Solo    180    80 brown      fair       brown           29   male  mascu…\n10 Greedo      173    74 &lt;NA&gt;       green      black           44   male  mascu…\n# ℹ 50 more rows\n# ℹ 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,\n#   vehicles &lt;list&gt;, starships &lt;list&gt;\n\n[[4]]\n# A tibble: 1 × 14\n  name   height  mass hair_color skin_color  eye_color birth_year sex   gender  \n  &lt;chr&gt;   &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;   \n1 R4-P17     96    NA none       silver, red red, blue         NA none  feminine\n# ℹ 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,\n#   vehicles &lt;list&gt;, starships &lt;list&gt;\n\n[[5]]\n# A tibble: 5 × 14\n  name  height  mass hair_color skin_color  eye_color birth_year sex   gender   \n  &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    \n1 C-3PO    167    75 &lt;NA&gt;       gold        yellow           112 none  masculine\n2 R2-D2     96    32 &lt;NA&gt;       white, blue red               33 none  masculine\n3 R5-D4     97    32 &lt;NA&gt;       white, red  red               NA none  masculine\n4 IG-88    200   140 none       metal       red               15 none  masculine\n5 BB8       NA    NA none       none        black             NA none  masculine\n# ℹ 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,\n#   vehicles &lt;list&gt;, starships &lt;list&gt;\n\n[[6]]\n# A tibble: 4 × 14\n  name      height  mass hair_color skin_color eye_color birth_year sex   gender\n  &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n1 Ric Olié     183    NA brown      fair       blue              NA &lt;NA&gt;  &lt;NA&gt;  \n2 Quarsh P…    183    NA black      dark       brown             62 &lt;NA&gt;  &lt;NA&gt;  \n3 Sly Moore    178    48 none       pale       white             NA &lt;NA&gt;  &lt;NA&gt;  \n4 Captain …     NA    NA unknown    unknown    unknown           NA &lt;NA&gt;  &lt;NA&gt;  \n# ℹ 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,\n#   vehicles &lt;list&gt;, starships &lt;list&gt;"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#условные-функции-и-обработка-null",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#условные-функции-и-обработка-null",
    "title": "Dplyr",
    "section": "Условные функции и обработка Null",
    "text": "Условные функции и обработка Null\n\nif_else\nif_else векторизованная условная функция с возможность задать правило обработки Null значений\nif_else(condition, true, false, missing = NULL, ..., ptype = NULL, size = NULL)\nАргументы:\n\ncondition - логическое условие\ntrue - значение если условие True\nfalse - значение если условие False\nmissing - значение если элемент равен Null\nptype - желаемый тип вывода\nsize - желаемый размер\\длинна вывода\n\nРассмотрим пример когда относительно роста нужно распределить персонажей по ростовым категориям, а где значение роста равно Null присвоем другое значение\n\nstarwars %&gt;%\n  slice(80:87) %&gt;% \n  mutate(category = if_else(height &lt; 100, \"short\", \"tall\", missing = \"Неопределенный\"), .keep = \"used\")\n\n\n\n  \n\n\n\n\n\ncase_when\nФункция позволяет векторизовать несколько операторов if_else(). Каждый случай оценивается последовательно, и первое совпадение для каждого элемента определяет соответствующее значение в выходном векторе. Если ни один из вариантов не совпадает, используется значение .default.\ncase_when(..., .default = NULL, .ptype = NULL, .size = NULL)\nВ примере ниже показано как через одну функцию задать несколько разных условий по разным полям набора данных\n\nstarwars %&gt;% \n  select(name, species, height, mass) %&gt;% \n  mutate(\n    type = case_when(\n      height &gt; 200 | mass &gt; 200 ~ \"large\",\n      species == \"Droid\" ~ \"robot\",\n      .default = \"other\"\n    )\n  )\n\n\n\n  \n\n\n\n\n\ncase_match\nФункция позволяет векторизовать несколько операторов switch(). Каждый случай оценивается последовательно, и первое совпадение для каждого элемента определяет соответствующее значение в выходном векторе. Если ни один из вариантов не совпадает, используется значение .default.\ncase_match(.x, ..., .default = NULL, .ptype = NULL)\nВ примере первым применением функции case_match обрабатываем NULL, во втором правим название типа персонажа\n\nstarwars %&gt;%\n  mutate(\n    hair_color = case_match(hair_color, NA ~ \"unknown\", .default = hair_color),\n    species = case_match(\n      species,\n      \"Human\" ~ \"Humanoid\",\n      \"Droid\" ~ \"Robot\",\n      c(\"Wookiee\", \"Ewok\") ~ \"Hairy\",\n      .default = species\n    ),\n    .keep = \"used\"\n  )\n\n\n\n  \n\n\n\n\n\ncoaleasce\nФункция находит первое не пропущенное значение и выводит его\ncoalesce(..., .ptype = NULL, .size = NULL)\nВ примере в новую колонку пишем первое не равное Null значение, сначала проверяем поле mass, если там Null проверяем поле height, если и в нем Null, то пишем нуль.\n\nstarwars %&gt;%\n  slice(70:77) %&gt;% select(name, mass, height) %&gt;% \n  mutate(new_col = coalesce(mass, height, 0))\n\n\n\n  \n\n\n\n\n\nna_if\nФункция заменяет заданное значение на Null\nna_if(x, y)\nВ примере заменяем значение 188 на Null\n\nstarwars %&gt;%\n  slice(10:17) %&gt;% \n  select(name, height) %&gt;% \n  mutate(new_height = na_if(height, 188) )"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#backends",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#backends",
    "title": "Dplyr",
    "section": "Backends",
    "text": "Backends\n\narrow\n\n\ndtplyr\n\n\ndbplyr\n\n\nduckdb\n\n\nsparklyr"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#внешние-таблицы",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#внешние-таблицы",
    "title": "Dplyr",
    "section": "Внешние таблицы",
    "text": "Внешние таблицы\n\nauto_copy\n\n\nЗапрос к базе данных\n\ncompute\n\n\ncollect\n\n\ncollapse\n\n\n\ncopy_to\n\n\nident\n\n\nexplain\n\n\nshow_query\n\n\ntbl | is.tbl\n\n\nsql"
  },
  {
    "objectID": "r_language/Tidyverse/dplyr_tidyverse.html#производительность",
    "href": "r_language/Tidyverse/dplyr_tidyverse.html#производительность",
    "title": "Dplyr",
    "section": "Производительность",
    "text": "Производительность\nhttps://arrow.apache.org/docs/format/Columnar.html\nhttps://www.tidyverse.org/blog/2023/04/performant-packages/\nhttps://adv-r.hadley.nz/introduction.html\nhttp://adv-r.had.co.nz/Performance.html"
  },
  {
    "objectID": "r_language/Tutorial/Quarto_cheatsheet.html#footnotes",
    "href": "r_language/Tutorial/Quarto_cheatsheet.html#footnotes",
    "title": "Quarto cheat sheet",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nFigures↩︎\nа чтобы описать сноску ставим ‘[^ + цифра или слово]:’ и далее пишем текст описания↩︎"
  }
]