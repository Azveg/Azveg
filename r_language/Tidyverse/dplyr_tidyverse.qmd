---
title: "Dplyr"  
date: 11-16-2022  
categories: 
  - R
  - dplyr
  - tidyverse
description: "Обзор основного функционала пакета dplyr"
toc-depth: 5 
smooth-scroll: true
author: 
  - "Best Practices IT"
  - url: https://t.me/best_practices_it
citation: true
---


```{r}
#| echo: true
#| include: false

library(dplyr)
library(tidyr)
starwars <- dplyr::starwars
```



Выполним установку пакета dplyr и загрузим набор данных starwars

```{{r}}
library(dplyr)
starwars <- dplyr::starwars
```



## tidy-select

Пакет tidyselect - это серверная часть таких функций, как `dplyr::select()` или `dplyr::pull()`, а также нескольких глаголов tidyr. Это позволяет создавать глаголы выбора, которые совместимы с другими пакетами tidyverse.

Конечно логичнее было разместить раздел tidyselect в части выборки данных -> Столбцы, но tidyselect имеет гораздо большее значение и может применяться не только в select.


tidyselect поддерживает базовые функции R по выборке:

-  `:`  для выбора диапазона последовательных переменных.
-  `!`  для получения дополнения к набору переменных.
-  `& и |` для выбора пересечения или объединения двух наборов переменных.
-  `c()` для объединения выделений.

Также можно использовать функции помощи в выборке, для конкретных столбцов

-   `everything()` - выбирает все столбцы, обычно применяется с другими операторами tidyselect
-   `last_col()` - выбирает последнюю переменную


Для выборки столбцов сопоставляя шаблоны в их именах:

-   `starts_with`*: название столбца начинается с точного префикса*
-   `ends_with`*: название столбца заканчивается на точный суффикс*
-   `contains`*: название столбца содержит символ*
-   `matches`*: название столбца соответствует регулярному выражению*
-   `num_range`*: поиск занумерованных столбцов, например, «V1, V2, V3...»*
-   `all_of()` *: точный поиск по значениям, проверяет наличие значений*
-   `any_of()` *: поиск без проверки наличия значений, используется, чтобы убедиться, что столбец удален*
-   `one_of`*: название столбца соответствует одному из вариантов*
-   `where()` *: условие функции должно быть True*



Сделать строки с блоками кода на подобии тех, что использую в соединениях и наглядно показать как работают и чем отличаются функции помощи


Рассмотрим подробнее функции помощи


### Функции выбора


#### everything


`everything(vars = NULL)` - выбирает все столбцы, обычно применяется с другими операторами tidyselect

`vars` - Символьный вектор имен переменных. Если не указано, переменные берутся из текущего контекста выбора (как установлено такими функциями, как `select()` или `pivot_longer()`).


```{r}
starwars %>% 
  select(everything())
```


#### last_col


`last_col(offset = 0L, vars = NULL)` - выбирает последнюю переменную


`offset` - устанавливает какое количество столбцов с конца нужно пропустить


::: {.column-screen-inset-left layout-ncol=2 layout-valign="center"}

```{r}
starwars %>% 
  select(1:last_col(9))
```

```{r}
starwars %>% 
  select(last_col(9))
```

:::

### Функции поиска по шаблону


Аргументы функций поиска по шаблону:

- `match` - Вектор символов. Если длина > 1, берется объединение совпадений. Для starts_with(), ends_with() и contains() это точное совпадение. Для matches() это регулярное выражение и может быть шаблоном stringr.
- `ignore.case` - Если значение по умолчанию равно TRUE, регистр игнорируется при сопоставлении имен
- `vars` - Символьный вектор имен переменных. Если не указано, переменные берутся из текущего контекста выбора (как установлено такими функциями, как select() или pivot_longer()).
- `prefix, suffix` - Префикс/суффикс, добавленный до/после числового диапазона
- `range` - Последовательность целых чисел, например 1:5
- `width` - Необязательный аргумент, "ширина" числового диапазона. Например, диапазон из 2 дает "01", диапазон из трех "001" и т.д



#### starts_with

`starts_with()` - отбирает те столбцы название которых начинается с точного префикса

`starts_with(match, ignore.case = TRUE, vars = NULL)`

В функции `starts_with()` есть возможность задать мульти префикс, в этом случае порядок столбцов будет зависеть от порядка указания префиксов.

::: {.column-screen-inset-left layout-ncol=2 layout-valign="center"}

```{r}
# отберем столбцы, название которых начинается на символ «h».
starwars %>% 
  select(starts_with("h"))
```

```{r}
# отберем столбцы, название которых начинается на символы "b" и «h».
starwars %>% 
  select(starts_with(c("b", "h")))
```

:::



#### ends_with


`ends_with(match, ignore.case = TRUE, vars = NULL)` - отбирает те столбцы название которых заканчивается на точный суффикс

В функции `ends_with()` есть возможность задать мульти суффикс, в этом случае порядок столбцов будет зависеть от порядка указания суффиксов.

::: {.column-screen-inset-left layout-ncol=2 layout-valign="center"}

```{r}
# отберем столбцы, название которых заканчивается на слово «color».
starwars %>% 
  select(ends_with("color"))
```

```{r}
# отберем столбцы, название которых заканчивается на слова "year" и «color».
starwars %>% 
  select(ends_with(c("year", "color")))
```

:::

#### contains


`contains(match, ignore.case = TRUE, vars = NULL)` - отбирает те столбцы название которых содержит в названии символ/ы

В функции `contains()` есть возможность задать несколько символьных шаблонов, в этом случае порядок столбцов будет зависеть от порядка указания символов.

::: {.column-screen-inset-left layout-ncol=2 layout-valign="center"}

```{r}
# отберем столбцы, название которых содержит букву «а».
starwars %>% 
  select(contains('a'))
```

```{r}
# отберем столбцы, название которых содержит буквы «m» и "f".
starwars %>% 
  select(contains(c('m', 'f')))
```
:::


#### matches

Функции starts_with(), ends_with() и contains() не используют регулярные выражения. Для выбора с помощью регулярного выражения нужно использовать matches()

`matches(match, ignore.case = TRUE, perl = FALSE, vars = NULL)` - отбирает те столбцы название которых соответствует регулярному выражению


```{r}
# отберем столбцы, название которых соответствует регулярному выражению
starwars %>% 
  select(matches('[rne]_color'))
```


#### num_range


`num_range(prefix, range, suffix = "", width = NULL, vars = NULL)` - отбирает те столбцы название которых соответствует префиксу и числовому диапозону

Функции starts_with() и num_range() похожи, только первая ищет по префиксу, то num_range() отбирает по числовому диапозону внутри этого префикса.


Сравним эти функции на фрейме данных billboard, который содержит столбцы одиннаковым префиксом + номер столбца

::: {.column-screen-inset-left layout-ncol=2 layout-valign="center"}

```{r}
# отбираем столбцы с префиксом "wk"
billboard %>% 
  select(starts_with("wk"))
```

```{r}
# отбираем столбцы с префиксом "wk" и числовым диапозоном от 2 до 5
billboard %>% 
  select(num_range("wk", 2:5))
```

:::

### Функции выбора по символьному вектору


#### all_of

`all_of(x)` - предназначен для строгого отбора. Если какая-либо из переменных в символьном векторе отсутствует, выдается сообщение об ошибке

::: {.column-screen-inset-left layout-ncol=2 layout-valign="top"}

```{r}
var <- c('name', 'mass')
starwars %>% 
  select(all_of(var))
```


```{{r}}
# Если какая-либо переменная отсутствует во фрейме данных, это ошибка
var <- c('name', 'mass', 'class')
starwars %>% 
  select(all_of(var))


# Error in `select()`:
# ! Problem while evaluating `all_of(var)`.
# Backtrace:
#  1. starwars %>% select(all_of(var))
#  3. dplyr:::select.data.frame(., all_of(var))
# Error in select(., all_of(var)) :
```

:::


#### any_of

`any_of(x, ..., vars = NULL)` - не проверяет наличие отсутствующих переменных. Это особенно полезно при отрицательном выборе, когда вы хотите убедиться, что переменная удалена

::: {.column-screen-inset-left layout-ncol=2 layout-valign="top"}

```{r}
# Проверяем, что столбец отсутствует во фрейме
var <- c('class')
starwars %>% 
  select(any_of(var))
```


```{r}
# Удаляем из фрейма столбцы
# Даже вызвав одну функцию несколько раз ошибки не будет
var <- c('name', 'mass')
starwars %>% 
  select(-any_of(var)) %>% 
  select(-any_of(var))
```

:::

### Выбор через функцию

#### where

`where(fn)` - Применяет функцию ко всем переменным и выбирает те, для которых функция возвращает значение TRUE

Внутри функции можно создавать анонимные функции подобно тем, что создаются в пакете purrr, рассмотрим разные варианты реализации одной и той же логики

::: {.column-screen-inset-left layout-ncol=2 layout-nrow=2 layout-valign="top"}

```{r}
# отбираем только числовые столбцы
iris %>% 
  select(where(is.numeric))
```

```{r}
# отбираем только числовые столбцы
iris %>% 
  select(where(function(x) is.numeric(x)))
```


```{r}
# отбираем только числовые столбцы
iris %>% 
  select(where(~ is.numeric(.x)))
```

```{r}
# отбираем только числовые столбцы # у которых стреднее больше 3.5
iris %>% 
  select(where(~ is.numeric(.x) &&  mean(.x) > 3.5))
```

:::

## Выборка данных

В R возможно делать выборку столбцов разными стособами. Просто перечислить названия столбцов или их номера, перечислить какие столбцы не нужно выводить или выводить столбцы с именем соответствующим определенному условию.Выбор с использованием tidyselect рассмотрели выше, теперь рассмотрим ещё пару стандартных способов отбора столбцов.


### Вернуть вектор


Если нужно вернуть столбец не как таблицу, а вектор, то делаем это через `pull`\


```{r}
starwars %>% 
  pull('name')
```


### Столбцы

#### Перечисление


```{r}
starwars %>% 
  select(name)
```


#### Отрицательное перечисление

Если нужно указать какой столбец не включать в выборку то ставится знак минус:


```{r}
starwars %>% 
  select(-c(name, mass))
```


#### По номерам


Или можно указать номера столбцов


```{r}
starwars %>% 
  select(1, 2)
```


#### Упорядочивание столбцов

relocate(.data, ..., .before = NULL, .after = NULL) - смена позиции столбца, использует иснтаксис select(включая tidy-select) чтобы легко перемещать один или несколько столбоц за один раз

- `.data` - указываем, что переместить
- `.before` - перемещение до и указваем столбец или выражение tidy-select
- `.after` - перемещение после и указваем столбец или выражение tidy-select


::: {.column-screen-inset-left layout-ncol=4 layout-valign="top"}

```{r}
df <- tibble(a = 1, d = "a", b = 1, f = "a")
df
```

```{r}
# ставим стоблец f в начало
df %>% relocate(f)
```

```{r}
# ставим стоблец a после d
df %>% relocate(a, .after = d)
```

```{r}
# ставим стоблец f перед b
df %>% relocate(f, .before = b)
```

:::

И ещё несколько вариантов используя tidy-select

::: {.column-screen-inset-left layout-ncol=3 layout-valign="top"}

```{r}
# числовые столбцы в конец
df %>% 
  relocate(where(is.numeric), 
           .after = last_col())
```
```{r}
# если есть столбцы с такими названиями
# то их ставим вначало
df %>% 
  relocate(any_of(c("a", "e", "i", "o", "u")))
```
```{r}
# числовые столбцы после символьных
df %>% 
  relocate(where(is.numeric), 
           .after = where(is.character))
```


:::


### Строки

#### Уникальные значения


```{r}
starwars %>% 
  distinct(sex)
```


#### Случайные строки


Возвращаем n - случайных строк
 
```{r}
starwars %>% 
  sample_n(5)

```


Если нужно указать долю строк из общего числа, которые должны быть в итоговой таблице, то используем sample_frac. Например, при параметре 0.5 вернется половина строк из таблицы, выбранные случайным образом.


```{r}
starwars %>% 
  sample_frac(0.1)
```


#### Срезы

Функции slice позволяют сделать срез из выборки данных по условию, рассмотрим аргументы функций:

- `n, prop` - задает количество (`n`) или пропорцию (`prop`) выбираемых строк, по умолчанию `n = 1`. Если указано отрицательное значение `n` или `prop`, указанное количество или пропорция строк будут удалены. Если `n` больше, чем количество строк в группе (или `prop > 1`), результат будет автоматически усечен до размера группы. Если доля размера группы не дает целого числа строк, абсолютное значение `prop * nrow(.data)` округляется в меньшую сторону.
- `with_ties` - указывает нужно ли включать в выборку дубликаты по выбранному столбцу
- `weight_by` - задает взвешенную случайную выборку фрейма данных т.е. задает вероятность включения каждой строки в результирующее подмножество, которая будет пропорциональна значениям в указанном столбце. Указав вес столбца, можно гарантировать, что более важные строки с большей вероятностью попадут в выборку. Используется когда нужно сделать репрезентативную выборку для исследования.
- `replace` - указывает нужно ли переписывать текущий фрейм, если значение TRUE, то текущий фрейм сразу заменяется результатом выборки, если FALSE, то выборка возвращается как новый фрейм данных, без изменения исходного фрейма.


Создадим набор данных для описания возможностей работы со срезами


```{r}
df <- tribble(
  ~key, ~val_y, ~val_x,
     1, "y1",   6,
     2, "y2",   1,
     3, "y3",   3,
     4, "y4",   9,
     5, "y5",   2,
     6, "y6",   7,
     7, "y7",   4,
     8, "y8",   10,
     9, "y9",   5,
     9, "y10",  8 
)
df
```


</br>


##### slice

`slice(.data, ..., .preserve = FALSE)`

Функция slice() позволяет выбирать строки из фрейма данных на основе их положения. Функция принимает два аргумента, первый из которых является фреймом данных, а второй - диапазоном строк для выбора. Диапазон задается с помощью оператора  `:` и может быть одним значением или диапазоном значений. 

::: {.column-screen-inset-left layout-ncol=3 layout-valign="top"}



```{r}
df %>% 
  slice(1:n()) 
```

```{r}
df %>% 
  slice(1:4) 
```


```{r}
df %>% 
  slice(1L)
```

:::


</br>

##### slice_head


`slice_head(.data, ..., n, prop)`

Функция slice_head() аналогична функции slice(), но выбирает первые n строк фрейма данных. Функция принимает два аргумента, первый из которых является фреймом данных, а второй - количеством строк для выбора.

::: {.column-screen-inset-left layout-ncol=2 layout-valign="top"}

```{r}
df %>% 
  slice_head(n = 5) 
```

```{r}
df %>% 
  slice_head(prop = 0.2) 
```

:::

</br>

##### slice_tail


`slice_tail(.data, ..., n, prop)`

Функция slice_tail() аналогична функции slice(), но выбирает последние n строк фрейма данных. Функция принимает два аргумента, первый из которых является фреймом данных, а второй - количеством строк для выбора. 

::: {.column-screen-inset-left layout-ncol=2 layout-valign="top"}

```{r}
df %>% 
  slice_tail(n = 5) 
```


```{r}
df %>% 
  slice_tail(prop = 0.1) 
```

:::

</br>

##### slice_min


`slice_min(.data, order_by, ..., n, prop, with_ties = TRUE)`

Функция slice_min() используется для выбора строк с минимальными значениями указанного столбца. 


```{r}
df %>% 
  slice_min(key, n = 2) 
```


</br>

##### slice_max


`slice_max(.data, order_by, ..., n, prop, with_ties = TRUE)`

Функция slice_max() используется для выбора строк с максимальными значениями указанного столбца. Функция принимает аргументы, первый из которых является фреймом данных, а второй - столбцом для выбора. 


::: {.column-screen-inset-left layout-ncol=3 layout-valign="top"}

```{r}
df %>% 
  slice_max(key, n = 3) 
```


```{r}
df %>% 
  slice_max(key, n = 1, with_ties = T) 
```
```{r}
df %>% 
  slice_max(key, n = 1, with_ties = F) 
```

:::

</br>


##### slice_sample


`slice_sample(.data, ..., n, prop, weight_by = NULL, replace = FALSE)`

Функция slice_sample() используется для выбора случайной выборки строк из фрейма данных. Функция принимает аргументы, первый из которых является фреймом данных, а второй - количеством строк для выбора.


::: {.column-screen-inset-left layout-ncol=2 layout-valign="top"}

```{r}
df %>% 
  slice_sample(n = 4) 
```

```{r}
df %>% 
  slice_sample(n = 4, weight_by = val_x) 
```


:::


</br>



## Фильтрация{.tabset .tabset-fade .tabset-pills}


### По логическому условию

```{r}
starwars %>% 
  filter(mass > 50)
#комбинировать несколько условий можно с помощью & и |:
starwars %>% 
  filter(mass > 50 & height > 170)
```

Конструировать логические условия можно и другими операторами

Как пользоваться каждым из этих операторов???

-   `>=`
-   `<=`
-   `is.na`
-   `!is.na`
-   `%in%`
-   `!`
-   `between`
-   `near`
-   `xor`



```{r}
starwars %>% 
  filter(skin_color %in% c('fair', 'green'))
```


## Сортировка


Для сортировки в языке есть достаточно широкие возможности. Вот самые основные виды сортировки:


### По возрастанию


```{r}
starwars %>% 
  arrange(mass)
```


### По убыванию


```{r}
# сортировка по убыванию
starwars %>% 
  arrange(desc(mass))
```


### По нескольким столбцам


```{r}
# сортировка по нескольким столбцам
starwars %>% 
  arrange(height, desc(mass))
```


### Расширенная сортировка


При сортировке можно использовать вспомогательные функции для `select`, только внутри функции `across`


```{r}
starwars %>% 
  arrange(across(ends_with('_color'), desc))
```


## Вычисляемые столбцы


### Новый столбец


#### mutate

```{r}
starwars %>% 
  select(name, height, mass) %>% 
  mutate('coef' = mass/height)
```


## Объединение таблиц

В процессе объединения таблиц можно выделить операции трех видов:

- Mutating joins, которые добавляют новые переменные в один фрейм данных из совпадающих наблюдений в другом.
- Filtering joins, которые фильтруют наблюдения из одного фрейма данных на основе того, соответствуют ли они наблюдению в другой таблице.
- Set operations, эти операции работают с пересечениями двух фреймов

Для разбора операций соединения, загрузим набор данных nycflights13 

```{r}
#| echo: true
#| include: false

library(nycflights13)
flights2 <- flights %>% slice(1:100)
```

```{{r}}
library(nycflights13)
```


### Ключи соединения


#### Сопоставление ключей

При соединении фреймов данных нужно указать ключи соединения иногда это может быть один ключ или набор ключей, они могут совпадать по наименованию или различаться. Давайте рассмотрим разные варианты.


#####  Соединить по всем совпадающим полям

Чтобы соединить по всем совпадающим по названию полям, нужно оставить by = NULL

```{r}
flights2 %>% 
  left_join(weather)
```

</br>

#####  Соединить по одному ключу

Соединение по одному ключу с общим для обоих фреймов названием:

```{r}
flights2 %>% 
  left_join(planes, by = "tailnum")
```

</br>

#####  Соединить по нескольким ключам

- by = c("a" = "b") -> `x$a == y$b` - соединить с помощью разных переменных на x и y, используется именованный вектор.
- by = c("a", "b") -> `x$a == y$a and x$b == y$b` - соединить по нескольким переменным
- by = c("a" = "b", "c" = "d" -> `x$a == y$b and x$c  == y$d` - соединить сопоставив раличные переменные из двух фреймов 


```{r}
flights2 %>% 
  left_join(airports, c("dest" = "faa"))
```


#### Проблемы с ключами

Не всегда бывает так, что значения в ключевом столбце уникальные. Когда соединяются дублированные ключи, получаются все возможные комбинации, декартово произведение. 
В функции Join нет никакой обработки таких случаев, поэтому нужно быть внимательным к своим данным и проверять результирующий набор данных. А также при необходимости удалять дублирующие строки.

Убедитесь, что ваши внешние ключи совпадают с первичными ключами в другой таблице. Лучший способ сделать это - с помощью anti_join(). Часто ключи не совпадают из-за ошибок ввода данных. Их устранение часто требует большой работы.


### Mutating joins

В принципе это самые обычные и привычные Join-ы, которые мы используем каждый день. Рассмотрим аргументы этих функций:

- x, y - пара фреймов данных, которые нужно соединить
- by - вектор переменных в котором задаются ключи
- suffix - добавляет суффиксы для одноименных не ключевых полей
- keep - указывает, нужно ли сохранять ключевые поля в результирующем фрейме данных
- na_matches - задает считать или нет равными значения NA и NaN, по умолчанию "na" считаются равными, "never" - исчтать не равными

Чтобы понять суть разных типов соединений, создадим два тестовых фрейма данных и проиллюстрируем на их примере каждый тип:

```{r}
#| layout-nrow: 1
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     3, "x3"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2",
     4, "y3"
)

x
y
```


#### Inner join

Внутреннее соединение сопоставляет пары наблюдений всякий раз, когда их ключи равны.Наиболее важным свойством внутреннего соединения является то, что несогласованные строки не включаются в результат. Это означает, что, как правило, внутренние соединения обычно не подходят для использования в анализе, потому что слишком легко потерять наблюдения.


```{{r}}
inner_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE,
  na_matches = c("na", "never")
)
```

::: {.column-screen-inset-left layout-ncol=4 layout-valign="center"}

```{r}
x
```

```{r}
y
```

![inner_join](images/dplyr_inner_join.png)

```{r}
inner_join(x, y, by = "key")
```
:::


#### Outer joins

Внешнее соединение сохраняет наблюдения, которые отображаются по крайней мере в одной из таблиц.


##### Left Join 


left_join - сохраняет все строки из первой таблицы и соединяет все совпавшие по ключу строки из второй таблицы.

Наиболее часто используемым соединением является левое соединение: его используют  всякий раз, когда просматривают дополнительные данные из другой таблицы, потому что оно сохраняет исходные наблюдения, даже если совпадения нет. Левое соединение должно быть соединением по умолчанию: используйте его, если у нет веских причин предпочесть одно из других.

```{{r}}
left_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE,
  na_matches = c("na", "never")
)
```


Разберем подробнее левое соединение:

::: {.column-screen-inset-left layout-ncol=4 layout-valign="center"}

```{r}
x
```

```{r}
y
```

![left_join](images/dplyr_left_join.png)

```{r}
left_join(x, y, by = "key")
```
:::


##### Right Join 

right_join - сохраняет все строки из второй таблицы и соединяет все совпавшие по ключу строки из первой таблицы

```{{r}}
right_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE,
  na_matches = c("na", "never")
)
```


::: {.column-screen-inset-left layout-ncol=4 layout-valign="center"}

```{r}
x
```

```{r}
y
```

![right_join](images/dplyr_right_join.png)

```{r}
right_join(x, y, by = "key")
```
:::


##### Full Join

full_join - сохраняет все строки из обоих таблиц

```{{r}}
full_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE,
  na_matches = c("na", "never")
)
```


::: {.column-screen-inset-left layout-ncol=4 layout-valign="center"}

```{r}
x
```

```{r}
y
```

![full_join](images/dplyr_full_join.png)

```{r}
full_join(x, y, by = "key")
```
:::

### Filtering joins

Фильтрующие соединения используются для фильтрации первого фрейма на основе данных из второго фрейма данных.


#### semi_join

semi_join соединяет две таблицы подобно мутирующему соединению, но вместо добавления новых столбцов сохраняет только те строки в x, которые совпадают в y.


::: {.column-screen-inset-left layout-ncol=4 layout-valign="center"}

```{r}
x
```

```{r}
y
```

![semi_join](images/dplyr_semi_join.png)

```{r}
semi_join(x, y, by = "key")
```
:::


Важно только наличие совпадения; не имеет значения, какому наблюдению соответствует. Это означает, что фильтрующие соединения никогда не дублируют строки, как это делают мутирующие соединения.


#### anti_join

Антисоединения полезны для диагностики несоответствий соединений. Например, так можно делать проверку полноты данных по эталонным справочникам:


::: {.column-screen-inset-left layout-ncol=4 layout-valign="center"}

```{r}
x
```

```{r}
y
```

![anti_join](images/dplyr_anti_join.png)

```{r}
anti_join(x, y, by = "key")
```
:::


#### nest_join

nest_join() возвращает все строки и столбцы в x с новым столбцом в каждой строке которого вложен фрейм, содержащий все совпадения из y. Если совпадений нет, то фрейм будет пустой.

::: {.column-screen-inset-left layout-ncol=4 layout-valign="center"}

```{r}
x
```

```{r}
y
```

```{r}
nest_join(x, y, by = "key")
```

```{r}
nest_join(x, y, by = "key") %>% 
  unnest(cols = c(y))
```
:::



### Set operations

Операции с наборами требуют чтобы соединяемые фреймы данных имели одинаковое количество столбцов, эти функции объединяют два фрейма данных как бы складывая их друг под друга.

Создадим два фрейма, чтобы показать работу этих функций:

```{r}
df1 <- tribble(
  ~x, ~y,
   1,  1,
   2,  1
)
df2 <- tribble(
  ~x, ~y,
   1,  1,
   1,  2
)
```


#### union

- union - оставляет только уникальные строки из обоих наборов
- union_all - оставляет все строки из обоих наборов


::: {.column-screen-inset-left layout-ncol=4 layout-valign="top"}

```{r}
df1
```

```{r}
df2
```

```{r}
union(df1, df2)
```

```{r}
union_all(df1, df2)
```
:::



#### intersect

оставляет только совпавшие строки из обоих наборов:


::: {.column-screen-inset-left layout-ncol=4 layout-valign="center"}

```{r}
df1
```

```{r}
df2
```

![intersect](images/dplyr_intersect.png)

```{r}
intersect(df1, df2)
```
:::


#### setdiff


оставляет строки из первого фрейма только не совпавшие со строками из второго фрейма


::: {.column-screen-inset-left layout-ncol=5 layout-valign="center"}

```{r}
df1
```

```{r}
df2
```

![intersect](images/dplyr_setdiff.png)

```{r}
setdiff(df1, df2)
```

```{r}
setdiff(df2, df1)
```

:::
