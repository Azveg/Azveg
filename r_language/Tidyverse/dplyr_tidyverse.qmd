---
title: "Dplyr"  
date: 11-16-2022  
categories: 
  - R
  - dplyr
  - tidyverse
description: "Обзор основного функционала пакета dplyr"
toc-depth: 5 
smooth-scroll: true
author: 
  - "Best Practices IT"
  - url: https://t.me/best_practices_it
citation: true
---


```{r}
#| echo: true
#| include: false

library(dplyr)
library(tidyr)
starwars <- dplyr::starwars
```



Выполним установку пакета dplyr и загрузим набор данных starwars

```{{r}}
library(dplyr)
starwars <- dplyr::starwars
```



## tidy-select

Пакет tidyselect - это серверная часть таких функций, как `dplyr::select()` или `dplyr::pull()`, а также нескольких глаголов tidyr. Это позволяет создавать глаголы выбора, которые совместимы с другими пакетами tidyverse.

Конечно логичнее было разместить раздел tidyselect в части выборки данных -> Столбцы, но tidyselect имеет гораздо большее значение и может применяться не только в select.


tidyselect поддерживает базовые функции R по выборке:

-  `:`  для выбора диапазона последовательных переменных.
-  `!`  для получения дополнения к набору переменных.
-  `& и |` для выбора пересечения или объединения двух наборов переменных.
-  `c()` для объединения выделений.

Также можно использовать функции помощи в выборке, для конкретных столбцов

-   `everything()` - выбирает все столбцы, обычно применяется с другими операторами tidyselect
-   `last_col()` - выбирает последнюю переменную


Для выборки столбцов сопоставляя шаблоны в их именах:

-   `starts_with`*: название столбца начинается с точного префикса*
-   `ends_with`*: название столбца заканчивается на точный суффикс*
-   `contains`*: название столбца содержит символ*
-   `matches`*: название столбца соответствует регулярному выражению*
-   `num_range`*: поиск занумерованных столбцов, например, «V1, V2, V3...»*
-   `all_of()` *: точный поиск по значениям, проверяет наличие значений*
-   `any_of()` *: поиск без проверки наличия значений, используется, чтобы убедиться, что столбец удален*
-   `one_of`*: название столбца соответствует одному из вариантов*
-   `where()` *: условие функции должно быть True*



Сделать строки с блоками кода на подобии тех, что использую в соединениях и наглядно показать как работают и чем отличаются функции помощи


Рассмотрим подробнее функции помощи


### Функции выбора


#### everything


`everything(vars = NULL)` - выбирает все столбцы, обычно применяется с другими операторами tidyselect

`vars` - Символьный вектор имен переменных. Если не указано, переменные берутся из текущего контекста выбора (как установлено такими функциями, как `select()` или `pivot_longer()`).


```{r}
starwars %>% 
  select(everything())
```


#### last_col


`last_col(offset = 0L, vars = NULL)` - выбирает последнюю переменную


`offset` - устанавливает какое количество столбцов с конца нужно пропустить


::: {.column-screen-inset-left layout-ncol=2 layout-valign="center"}

```{r}
starwars %>% 
  select(1:last_col(9))
```

```{r}
starwars %>% 
  select(last_col(9))
```

:::

### Функции поиска по шаблону


Аргументы функций поиска по шаблону:

- `match` - Вектор символов. Если длина > 1, берется объединение совпадений. Для starts_with(), ends_with() и contains() это точное совпадение. Для matches() это регулярное выражение и может быть шаблоном stringr.
- `ignore.case` - Если значение по умолчанию равно TRUE, регистр игнорируется при сопоставлении имен
- `vars` - Символьный вектор имен переменных. Если не указано, переменные берутся из текущего контекста выбора (как установлено такими функциями, как select() или pivot_longer()).
- `prefix, suffix` - Префикс/суффикс, добавленный до/после числового диапазона
- `range` - Последовательность целых чисел, например 1:5
- `width` - Необязательный аргумент, "ширина" числового диапазона. Например, диапазон из 2 дает "01", диапазон из трех "001" и т.д



#### starts_with

`starts_with()` - отбирает те столбцы название которых начинается с точного префикса

`starts_with(match, ignore.case = TRUE, vars = NULL)`

В функции `starts_with()` есть возможность задать мульти префикс, в этом случае порядок столбцов будет зависеть от порядка указания префиксов.

::: {.column-screen-inset-left layout-ncol=2 layout-valign="center"}

```{r}
# отберем столбцы, название которых начинается на символ «h».
starwars %>% 
  select(starts_with("h"))
```

```{r}
# отберем столбцы, название которых начинается на символы "b" и «h».
starwars %>% 
  select(starts_with(c("b", "h")))
```

:::



#### ends_with


`ends_with(match, ignore.case = TRUE, vars = NULL)` - отбирает те столбцы название которых заканчивается на точный суффикс

В функции `ends_with()` есть возможность задать мульти суффикс, в этом случае порядок столбцов будет зависеть от порядка указания суффиксов.

::: {.column-screen-inset-left layout-ncol=2 layout-valign="center"}

```{r}
# отберем столбцы, название которых заканчивается на слово «color».
starwars %>% 
  select(ends_with("color"))
```

```{r}
# отберем столбцы, название которых заканчивается на слова "year" и «color».
starwars %>% 
  select(ends_with(c("year", "color")))
```

:::

#### contains


`contains(match, ignore.case = TRUE, vars = NULL)` - отбирает те столбцы название которых содержит в названии символ/ы

В функции `contains()` есть возможность задать несколько символьных шаблонов, в этом случае порядок столбцов будет зависеть от порядка указания символов.

::: {.column-screen-inset-left layout-ncol=2 layout-valign="center"}

```{r}
# отберем столбцы, название которых содержит букву «а».
starwars %>% 
  select(contains('a'))
```

```{r}
# отберем столбцы, название которых содержит буквы «m» и "f".
starwars %>% 
  select(contains(c('m', 'f')))
```
:::


#### matches

Функции starts_with(), ends_with() и contains() не используют регулярные выражения. Для выбора с помощью регулярного выражения нужно использовать matches()

`matches(match, ignore.case = TRUE, perl = FALSE, vars = NULL)` - отбирает те столбцы название которых соответствует регулярному выражению


```{r}
# отберем столбцы, название которых соответствует регулярному выражению
starwars %>% 
  select(matches('[rne]_color'))
```


#### num_range


`num_range(prefix, range, suffix = "", width = NULL, vars = NULL)` - отбирает те столбцы название которых соответствует префиксу и числовому диапозону

Функции starts_with() и num_range() похожи, только первая ищет по префиксу, то num_range() отбирает по числовому диапозону внутри этого префикса.


Сравним эти функции на фрейме данных billboard, который содержит столбцы одиннаковым префиксом + номер столбца

::: {.column-screen-inset-left layout-ncol=2 layout-valign="center"}

```{r}
# отбираем столбцы с префиксом "wk"
billboard %>% 
  select(starts_with("wk"))
```

```{r}
# отбираем столбцы с префиксом "wk" и числовым диапозоном от 2 до 5
billboard %>% 
  select(num_range("wk", 2:5))
```

:::

### Функции выбора по символьному вектору


#### all_of

`all_of(x)` - предназначен для строгого отбора. Если какая-либо из переменных в символьном векторе отсутствует, выдается сообщение об ошибке

::: {.column-screen-inset-left layout-ncol=2 layout-valign="top"}

```{r}
var <- c('name', 'mass')
starwars %>% 
  select(all_of(var))
```


```{{r}}
# Если какая-либо переменная отсутствует во фрейме данных, это ошибка
var <- c('name', 'mass', 'class')
starwars %>% 
  select(all_of(var))


# Error in `select()`:
# ! Problem while evaluating `all_of(var)`.
# Backtrace:
#  1. starwars %>% select(all_of(var))
#  3. dplyr:::select.data.frame(., all_of(var))
# Error in select(., all_of(var)) :
```

:::


#### any_of

`any_of(x, ..., vars = NULL)` - не проверяет наличие отсутствующих переменных. Это особенно полезно при отрицательном выборе, когда вы хотите убедиться, что переменная удалена

::: {.column-screen-inset-left layout-ncol=2 layout-valign="top"}

```{r}
# Проверяем, что столбец отсутствует во фрейме
var <- c('class')
starwars %>% 
  select(any_of(var))
```


```{r}
# Удаляем из фрейма столбцы
# Даже вызвав одну функцию несколько раз ошибки не будет
var <- c('name', 'mass')
starwars %>% 
  select(-any_of(var)) %>% 
  select(-any_of(var))
```

:::

### Выбор через функцию

#### where

`where(fn)` - Применяет функцию ко всем переменным и выбирает те, для которых функция возвращает значение TRUE

Внутри функции можно создавать анонимные функции подобно тем, что создаются в пакете purrr, рассмотрим разные варианты реализации одной и той же логики

::: {.column-screen-inset-left layout-ncol=2 layout-nrow=2 layout-valign="top"}

```{r}
# отбираем только числовые столбцы
iris %>% 
  select(where(is.numeric))
```

```{r}
# отбираем только числовые столбцы
iris %>% 
  select(where(function(x) is.numeric(x)))
```


```{r}
# отбираем только числовые столбцы
iris %>% 
  select(where(~ is.numeric(.x)))
```

```{r}
# отбираем только числовые столбцы # у которых стреднее больше 3.5
iris %>% 
  select(where(~ is.numeric(.x) &&  mean(.x) > 3.5))
```

:::

## Выборка данных

В R возможно делать выборку столбцов разными стособами. Просто перечислить названия столбцов или их номера, перечислить какие столбцы не нужно выводить или выводить столбцы с именем соответствующим определенному условию.Выбор с использованием tidyselect рассмотрели выше, теперь рассмотрим ещё пару стандартных способов отбора столбцов.


### Вернуть вектор


Если нужно вернуть столбец не как таблицу, а вектор, то делаем это через `pull`\


```{r}
starwars %>% 
  pull('name')
```


### Столбцы

#### Перечисление


```{r}
starwars %>% 
  select(name)
```


#### Отрицательное перечисление

Если нужно указать какой столбец не включать в выборку то ставится знак минус:


```{r}
starwars %>% 
  select(-c(name, mass))
```


#### По номерам


Или можно указать номера столбцов


```{r}
starwars %>% 
  select(1, 2)
```


#### Упорядочивание столбцов

##### relocate


relocate(.data, ..., .before = NULL, .after = NULL) - смена позиции столбца, использует иснтаксис select(включая tidy-select) чтобы легко перемещать один или несколько столбоц за один раз

- `.data` - указываем, что переместить
- `.before` - перемещение до и указваем столбец или выражение tidy-select
- `.after` - перемещение после и указваем столбец или выражение tidy-select


::: {.column-screen-inset-left layout-ncol=4 layout-valign="top"}

```{r}
df <- tibble(a = 1, d = "a", b = 1, f = "a")
df
```

```{r}
# ставим стоблец f в начало
df %>% relocate(f)
```

```{r}
# ставим стоблец a после d
df %>% relocate(a, .after = d)
```

```{r}
# ставим стоблец f перед b
df %>% relocate(f, .before = b)
```

:::

И ещё несколько вариантов используя tidy-select

::: {.column-screen-inset-left layout-ncol=3 layout-valign="top"}

```{r}
# числовые столбцы в конец
df %>% 
  relocate(where(is.numeric), 
           .after = last_col())
```
```{r}
# если есть столбцы с такими названиями
# то их ставим вначало
df %>% 
  relocate(any_of(c("a", "e", "i", "o", "u")))
```
```{r}
# числовые столбцы после символьных
df %>% 
  relocate(where(is.numeric), 
           .after = where(is.character))
```


:::


### Строки

#### Уникальные значения


```{r}
starwars %>% 
  distinct(sex)
```


#### Случайные строки


##### sample_n


Возвращаем n - случайных строк
 
```{r}
starwars %>% 
  sample_n(5)

```

##### sample_frac


Если нужно указать долю строк из общего числа, которые должны быть в итоговой таблице, то используем sample_frac. Например, при параметре 0.5 вернется половина строк из таблицы, выбранные случайным образом.


```{r}
starwars %>% 
  sample_frac(0.1)
```


#### Срезы

Функции slice позволяют сделать срез из выборки данных по условию, рассмотрим аргументы функций:

- `n, prop` - задает количество (`n`) или пропорцию (`prop`) выбираемых строк, по умолчанию `n = 1`. Если указано отрицательное значение `n` или `prop`, указанное количество или пропорция строк будут удалены. Если `n` больше, чем количество строк в группе (или `prop > 1`), результат будет автоматически усечен до размера группы. Если доля размера группы не дает целого числа строк, абсолютное значение `prop * nrow(.data)` округляется в меньшую сторону.
- `with_ties` - указывает нужно ли включать в выборку дубликаты по выбранному столбцу
- `weight_by` - задает взвешенную случайную выборку фрейма данных т.е. задает вероятность включения каждой строки в результирующее подмножество, которая будет пропорциональна значениям в указанном столбце. Указав вес столбца, можно гарантировать, что более важные строки с большей вероятностью попадут в выборку. Используется когда нужно сделать репрезентативную выборку для исследования.
- `replace` - указывает нужно ли переписывать текущий фрейм, если значение TRUE, то текущий фрейм сразу заменяется результатом выборки, если FALSE, то выборка возвращается как новый фрейм данных, без изменения исходного фрейма.


Создадим набор данных для описания возможностей работы со срезами


```{r}
df <- tribble(
  ~key, ~val_y, ~val_x,
     1, "y1",   6,
     2, "y2",   1,
     3, "y3",   3,
     4, "y4",   9,
     5, "y5",   2,
     6, "y6",   7,
     7, "y7",   4,
     8, "y8",   10,
     9, "y9",   5,
     9, "y10",  8 
)
df
```


</br>


##### slice

`slice(.data, ..., .preserve = FALSE)`

Функция slice() позволяет выбирать строки из фрейма данных на основе их положения. Функция принимает два аргумента, первый из которых является фреймом данных, а второй - диапазоном строк для выбора. Диапазон задается с помощью оператора  `:` и может быть одним значением или диапазоном значений. 

::: {.column-screen-inset-left layout-ncol=3 layout-valign="top"}



```{r}
df %>% 
  slice(1:n()) 
```

```{r}
df %>% 
  slice(1:4) 
```


```{r}
df %>% 
  slice(1L)
```

:::


</br>

##### slice_head


`slice_head(.data, ..., n, prop)`

Функция slice_head() аналогична функции slice(), но выбирает первые n строк фрейма данных. Функция принимает два аргумента, первый из которых является фреймом данных, а второй - количеством строк для выбора.

::: {.column-screen-inset-left layout-ncol=2 layout-valign="top"}

```{r}
df %>% 
  slice_head(n = 5) 
```

```{r}
df %>% 
  slice_head(prop = 0.2) 
```

:::

</br>

##### slice_tail


`slice_tail(.data, ..., n, prop)`

Функция slice_tail() аналогична функции slice(), но выбирает последние n строк фрейма данных. Функция принимает два аргумента, первый из которых является фреймом данных, а второй - количеством строк для выбора. 

::: {.column-screen-inset-left layout-ncol=2 layout-valign="top"}

```{r}
df %>% 
  slice_tail(n = 5) 
```


```{r}
df %>% 
  slice_tail(prop = 0.1) 
```

:::

</br>

##### slice_min


`slice_min(.data, order_by, ..., n, prop, with_ties = TRUE)`

Функция slice_min() используется для выбора строк с минимальными значениями указанного столбца. 


```{r}
df %>% 
  slice_min(key, n = 2) 
```


</br>

##### slice_max


`slice_max(.data, order_by, ..., n, prop, with_ties = TRUE)`

Функция slice_max() используется для выбора строк с максимальными значениями указанного столбца. Функция принимает аргументы, первый из которых является фреймом данных, а второй - столбцом для выбора. 


::: {.column-screen-inset-left layout-ncol=3 layout-valign="top"}

```{r}
df %>% 
  slice_max(key, n = 3) 
```


```{r}
df %>% 
  slice_max(key, n = 1, with_ties = T) 
```
```{r}
df %>% 
  slice_max(key, n = 1, with_ties = F) 
```

:::

</br>


##### slice_sample


`slice_sample(.data, ..., n, prop, weight_by = NULL, replace = FALSE)`

Функция slice_sample() используется для выбора случайной выборки строк из фрейма данных. Функция принимает аргументы, первый из которых является фреймом данных, а второй - количеством строк для выбора.


::: {.column-screen-inset-left layout-ncol=2 layout-valign="top"}

```{r}
df %>% 
  slice_sample(n = 4) 
```

```{r}
df %>% 
  slice_sample(n = 4, weight_by = val_x) 
```


:::


</br>



## Фильтрация{.tabset .tabset-fade .tabset-pills}


### По логическому условию

```{r}
starwars %>% 
  filter(mass > 50)
#комбинировать несколько условий можно с помощью & и |:
starwars %>% 
  filter(mass > 50 & height > 170)
```

Конструировать логические условия можно и другими операторами:

-   `>=`
-   `<=`
-   `is.na`
-   `!is.na`
-   `%in%`
-   `!`
-   `between`
-   `near`
-   `xor`



```{r}
starwars %>% 
  filter(skin_color %in% c('fair', 'green'))
```


## Сортировка


Для сортировки в языке есть достаточно широкие возможности. Вот самые основные виды сортировки:


### По возрастанию


```{r}
starwars %>% 
  arrange(mass)
```


### По убыванию


```{r}
# сортировка по убыванию
starwars %>% 
  arrange(desc(mass))
```


### По нескольким столбцам


```{r}
# сортировка по нескольким столбцам
starwars %>% 
  arrange(height, desc(mass))
```


### Расширенная сортировка


При сортировке можно использовать вспомогательные функции для `select`, только внутри функции `across`


```{r}
starwars %>% 
  arrange(across(ends_with('_color'), desc))
```


## Вычисляемые столбцы


### Новый столбец


#### mutate

```{r}
starwars %>% 
  select(name, height, mass) %>% 
  mutate('coef' = mass/height)
```


## Условные функции и обработка Null


### if_else

if_else векторизованная условная функция с возможность задать правило обработки Null значений


`if_else(condition, true, false, missing = NULL, ..., ptype = NULL, size = NULL)`

Аргументы:

- condition - логическое условие
- true - значение если условие True
- false - значение если условие False
- missing - значение если элемент равен Null
- ptype - желаемый тип вывода
- size - желаемый размер\\длинна вывода


Рассмотрим пример когда относительно роста нужно распределить персонажей по ростовым категориям, а где значение роста равно Null присвоем другое значение

```{r}
starwars %>%
  slice(80:87) %>% 
  mutate(category = if_else(height < 100, "short", "tall", missing = "Неопределенный"), .keep = "used")
```


### case_when

Функция позволяет векторизовать несколько операторов if_else(). Каждый случай оценивается последовательно, и первое совпадение для каждого элемента определяет соответствующее значение в выходном векторе. Если ни один из вариантов не совпадает, используется значение .default.

`case_when(..., .default = NULL, .ptype = NULL, .size = NULL)`

В примере ниже показано как через одну функцию задать несколько разных условий по разным полям набора данных

```{r}
starwars %>% 
  select(name, species, height, mass) %>% 
  mutate(
    type = case_when(
      height > 200 | mass > 200 ~ "large",
      species == "Droid" ~ "robot",
      .default = "other"
    )
  )
```


### case_match

Функция позволяет векторизовать несколько операторов switch(). Каждый случай оценивается последовательно, и первое совпадение для каждого элемента определяет соответствующее значение в выходном векторе. Если ни один из вариантов не совпадает, используется значение .default.

`case_match(.x, ..., .default = NULL, .ptype = NULL)`

В примере первым применением функции case_match обрабатываем NULL, во втором правим название типа персонажа

```{r}
starwars %>%
  mutate(
    hair_color = case_match(hair_color, NA ~ "unknown", .default = hair_color),
    species = case_match(
      species,
      "Human" ~ "Humanoid",
      "Droid" ~ "Robot",
      c("Wookiee", "Ewok") ~ "Hairy",
      .default = species
    ),
    .keep = "used"
  )
```


### coaleasce

Функция находит первое не пропущенное значение и выводит его

`coalesce(..., .ptype = NULL, .size = NULL)`

В примере в новую колонку пишем первое не равное Null значение, сначала проверяем поле mass, если там Null проверяем поле height, если и в нем Null, то пишем нуль.

```{r}
starwars %>%
  slice(70:77) %>% select(name, mass, height) %>% 
  mutate(new_col = coalesce(mass, height, 0))
```


### na_if

Функция заменяет заданное значение на Null

`na_if(x, y)`

В примере заменяем значение 188 на Null

```{r}
starwars %>%
  slice(10:17) %>% 
  select(name, height) %>% 
  mutate(new_height = na_if(height, 188) )
```


## Обработка групп

### group_by

`group_by(.data, ..., .add = FALSE, .drop = group_by_drop_default(.data))`

Функция group_by() позволяет группировать данные по одному или нескольким столбцам, создавая объект "grouped_df". Она принимает в качестве аргументов имена столбцов или переменные, по которым нужно провести группировку.


Атрибуты:

- `.data` - набор данных
- `...` - поля по которым необходимо сгруппировать набор
- `.add = FALSE` - при значении FALSE функция group_by() по умолчанию переопределяет существующие группы. Чтобы добавить в существующие группы, используйте .add = TRUE.
- `.drop = group_by_drop_default(.data)` - удаляет группы, софрмированные по неотображаемым в наборе уровням фактора, по умолчанию TRUE


Пример использования:

::: {.column-screen-inset-left layout-ncol=3 layout-valign="top"}

```{r}
# Создаем таблицу данных
df <- tibble(
  group = rep(c("A", "B"), each = 3),
  x = rnorm(6), y = rnorm(6)
)
df
```


```{r}
# Группируем данные по столбцу "group"
df_grouped <- df %>%
  group_by(group)
df_grouped
```

```{r}
# Проверяем наличие группирующих переменных
df_grouped %>%
  group_vars()
```
:::

В этом примере мы создали таблицу данных df с тремя столбцами: group, x и y. Затем мы использовали функцию group_by() для группировки данных по столбцу "group", создав объект "grouped_df". Наконец, мы использовали функцию group_vars чтобы проверить наличие в наборе группирующих переменных. 



### Метаданные групп

Функции из этого раздела дают дополнительную информацию о сгруппированном наборе данных и каждой отдельной группе внутри него.

#### group_data

`group_data(.data)`

Функция возвращает фрейм данных, который определяет структуру группировки. В столбцах приведены значения группирующих переменных. Последний столбец, всегда называемый .rows, представляет собой список целочисленных векторов, который указывает расположение строк в каждой группе. По сути объединяет в себе результат работы функций group_keys и group_rows.


```{r}
starwars %>% 
  group_by(sex) %>% 
  group_data()
```

#### group_keys

`group_keys(.tbl, ...)`

Функция возвращает набор данных описывающий группы

```{r}
starwars %>% 
  group_by(sex) %>% 
  group_keys()
```

####  group_rows

`group_rows(.data)`

Функция возвращает список целочисленных векторов, содержащих строки, которые содержит каждая группа.

```{r}
starwars %>% 
  group_by(sex) %>% 
  group_rows()
```

#### group_indices

`group_indices(.data, ...)`

Функция возвращает целочисленный вектор той же длины, что и набор данных, который указывает группу, к которой принадлежит каждая строка.

```{r}
starwars %>% 
  group_by(sex) %>% 
  group_indices()
```

#### group_vars

`group_vars(x)` | `groups(x)`

Функция `group_vars(x)` возвращает вектор содержащий имена группирующих переменных, а функция `groups(x)` в виде списка

::: {.column-screen-inset-left layout-ncol=2 layout-valign="top"}

```{r}
starwars %>% 
  group_by(sex) %>% 
  group_vars()
```

```{r}
starwars %>% 
  group_by(sex) %>% 
  groups()
```
:::


#### group_size

`group_size(x)`

Функция возвращает количество элементов в каждой группе

```{r}
starwars %>% 
  group_by(sex) %>% 
  group_size()
```


#### n_groups

`n_groups(x)`

Функция возвращает количество групп в наборе данных

```{r}
starwars %>% 
  group_by(sex) %>% 
  n_groups()
```



### Описание группы

#### n

`n()`

Функция возвращает количество элементов в каждой группе в виде набора данных

```{r}
starwars %>% 
  group_by(sex) %>% 
  summarise(n = n())
```

#### cur_group

`cur_group()`

Функция возвращает ключи группы для каждой группирующей переменной в виде tibble с одной строкой и столбцами количество которых равно количеству группирующих переменных

```{r}
starwars %>% 
  group_by(sex, gender) %>% 
  mutate(data = list(cur_group())) 
```


#### cur_group_id

`cur_group_id()`

Функция задает уникальный идентификатор для текущей группы

```{r}
starwars %>% 
  group_by(sex, gender) %>% 
  mutate(id = cur_group_id())
```

#### cur_group_rows

`cur_group_rows()`

Функция задает индексы строк для текущей группы

```{r}
starwars %>% 
  group_by(sex, gender) %>% 
  reframe(row = cur_group_rows()) 
```

#### cur_column

`cur_column()`

Функция возвращает имя текущего столбца и может применяться только с функцией across()


```{r}
starwars %>% 
  select(8,2,3) %>% 
  group_by(sex) %>% 
  mutate(across(everything(), ~ paste(cur_column(), round(.x, 2))))
```


### Функции обработки групп


#### group_map 

`group_map(.data, .f, ..., .keep = FALSE)`

group_map() - это функция, которая позволяет применить к каждой группе данных заданную пользователем функцию. Результатом функции является список, каждый элемент которого содержит результат выполнения функции .f для соответствующей группы данных.
Эта функция может быть полезна, когда требуется выполнить некоторую операцию над каждой группой данных, например, построить график или вычислить статистику.

Аргументы:

- .tbl - группированный data frame;
- .f - функция, которую требуется применить к каждой группе данных;
- ... - дополнительные аргументы, которые будут переданы в функцию .f.


Пример использования:

```{r}
starwars %>% 
  group_by(sex) %>% 
  group_map(~ quantile(.x$height, probs = c(0.25, 0.5, 0.75), na.rm = T))  
  
```

К сгруппированному набору применяем функцию quantile и выводим список c результатами работы функции примененной к каждой группе.



#### group_modify

`group_modify(.data, .f, ..., .keep = FALSE)`

Эта функция используется для модификации каждой группы набора данных. В примере ниже сгруппируем набор по полю `sex` и в каждой группе оставим по одной верхней строке.

```{r}
starwars %>% 
  group_by(sex) %>% 
  group_modify(~ head(.x, 1L))
```



#### group_walk

`group_walk(.data, .f, ..., .keep = FALSE)`

Функция возвращает данные каждой группы и без изменений передает их дальше. Это можно использовать для выполнения действий с данными из каждой группы внутри процесса не нарушая логику алгоритма.
В примере ниже мы выводим на печать первые две строки из каждой группы в виде отдельного tibble, а дальше применяем функцию group_modify как в примере выше.


В примере документации показан вариант, где данные каждой группы сохраняются в отдельный файл:`

`group_walk(~ write.csv(.x, file = file.path(temp, paste0(.y$Species, ".csv"))))`

Мы же выведем на печать первую строку из каждой группы, а дальше применить функцию модификации групп, оставив в каждой по 2 первые строки

```{r}
starwars %>% 
  group_by(sex) %>% 
  group_walk(~ print(head(.x, 1L))) %>% 
  group_modify(~ head(.x, 2L))
```

#### group_cols

`group_cols(vars = NULL, data = NULL)`

Функция позволяет выбирать к поля по которым выполнялась группировка, обычно используется при выборке данных. Таким образом с помощью group_cols можно обратиться ко всем полям по которым выполнялась группировка.

```{r}
starwars %>% 
  group_by(sex, gender) %>% 
  select(group_cols())
```

#### group_split

`group_split(.tbl, ..., .keep = TRUE)`


Функция возвращает список отдельных групп данных, каждая из которых содержит только те строки, где значение переменных группировки соответствует данной группе.


В примере группируем набор по полю sex и разбиваем набор сформированным группам.

```{r}
starwars %>% 
  group_by(sex) %>% 
  group_split()
```

#### group_trim

`group_trim(.tbl, .drop = group_by_drop_default(.tbl))`

Задача функции заключается в удалении неиспользуемых уровней факторов, которые используются в качестве переменных для группировки, а затем пересчёта структуры группировки.

Эта функция особенно полезна после применения функции filter(), которая выбирает подмножество групп. В результате применения filter() могут появиться неиспользуемые уровни факторов, что может привести к ошибкам или непредсказуемым результатам.

```{r}
starwars %>% 
  group_by(sex) %>% 
  filter(sex == 'none') %>% 
  group_trim()
```

#### rowwise

`rowwise(data, ...)`

Функция rowwise() позволяет выполнять вычисления для каждой строки входных данных. Это особенно полезно, когда векторизованная функция не подходит для вычислений.
Вызов функции rowwise() создает так называемый "row-wise" data frame, в котором вычисления выполняются по каждой строке, сохраняя все переменные в строке.

В примере по строчно вычисляем наименьшее значение из трех числовых столбцов

```{r}
starwars %>% 
  select(c(1,2,3,7)) %>% 
  rowwise() %>% 
  mutate(m = min(c(height, mass, birth_year)))
```

#### ungroup

`ungroup(x, ...)`

Функция удаляет группировку из набора данных

::: {.column-screen-inset-left layout-ncol=2 layout-valign="top"}

```{r}
# группируем набор по двум полям
starwars %>% 
  group_by(sex, gender) %>% 
# проверяем наличие группирующих переменных
  group_vars()
```

```{r}
# группируем набор по двум полям
starwars %>% 
  group_by(sex, gender) %>% 
# удаляем группировку
  ungroup() %>% 
# проверяем наличие группирующих переменных
  group_vars()
```

:::


## Объединение таблиц

В процессе объединения таблиц можно выделить операции трех видов:

- Mutating joins, которые добавляют новые переменные в один фрейм данных из совпадающих наблюдений в другом.
- Filtering joins, которые фильтруют наблюдения из одного фрейма данных на основе того, соответствуют ли они наблюдению в другой таблице.
- Set operations, эти операции работают с пересечениями двух фреймов

Для разбора операций соединения, загрузим набор данных nycflights13 

```{r}
#| echo: true
#| include: false

library(nycflights13)
flights2 <- flights %>% slice(1:100)
```

```{{r}}
library(nycflights13)
```


### Ключи соединения


#### Сопоставление ключей

При соединении фреймов данных нужно указать ключи соединения иногда это может быть один ключ или набор ключей, они могут совпадать по наименованию или различаться. Давайте рассмотрим разные варианты.


#####  Соединить по всем совпадающим полям

Чтобы соединить по всем совпадающим по названию полям, нужно оставить by = NULL

```{r}
flights2 %>% 
  left_join(weather)
```

</br>

#####  Соединить по одному ключу

Соединение по одному ключу с общим для обоих фреймов названием:

```{r}
flights2 %>% 
  left_join(planes, by = "tailnum")
```

</br>

#####  Соединить по нескольким ключам

- by = c("a" = "b") -> `x$a == y$b` - соединить с помощью разных переменных на x и y, используется именованный вектор.
- by = c("a", "b") -> `x$a == y$a and x$b == y$b` - соединить по нескольким переменным
- by = c("a" = "b", "c" = "d" -> `x$a == y$b and x$c  == y$d` - соединить сопоставив раличные переменные из двух фреймов 


```{r}
flights2 %>% 
  left_join(airports, c("dest" = "faa"))
```


#### Проблемы с ключами

Не всегда бывает так, что значения в ключевом столбце уникальные. Когда соединяются дублированные ключи, получаются все возможные комбинации, декартово произведение. 
В функции Join нет никакой обработки таких случаев, поэтому нужно быть внимательным к своим данным и проверять результирующий набор данных. А также при необходимости удалять дублирующие строки.

Убедитесь, что ваши внешние ключи совпадают с первичными ключами в другой таблице. Лучший способ сделать это - с помощью anti_join(). Часто ключи не совпадают из-за ошибок ввода данных. Их устранение часто требует большой работы.


### Mutating joins

В принципе это самые обычные и привычные Join-ы, которые мы используем каждый день. Рассмотрим аргументы этих функций:

- x, y - пара фреймов данных, которые нужно соединить
- by - вектор переменных в котором задаются ключи
- suffix - добавляет суффиксы для одноименных не ключевых полей
- keep - указывает, нужно ли сохранять ключевые поля в результирующем фрейме данных
- na_matches - задает считать или нет равными значения NA и NaN, по умолчанию "na" считаются равными, "never" - исчтать не равными

Чтобы понять суть разных типов соединений, создадим два тестовых фрейма данных и проиллюстрируем на их примере каждый тип:

```{r}
#| layout-nrow: 1
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     3, "x3"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2",
     4, "y3"
)

x
y
```


#### Inner join

Внутреннее соединение сопоставляет пары наблюдений всякий раз, когда их ключи равны.Наиболее важным свойством внутреннего соединения является то, что несогласованные строки не включаются в результат. Это означает, что, как правило, внутренние соединения обычно не подходят для использования в анализе, потому что слишком легко потерять наблюдения.


```{{r}}
inner_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE,
  na_matches = c("na", "never")
)
```

::: {.column-screen-inset-left layout-ncol=4 layout-valign="center"}

```{r}
x
```

```{r}
y
```

![inner_join](images/dplyr_inner_join.png)

```{r}
inner_join(x, y, by = "key")
```
:::


#### Outer joins

Внешнее соединение сохраняет наблюдения, которые отображаются по крайней мере в одной из таблиц.


##### Left Join 


left_join - сохраняет все строки из первой таблицы и соединяет все совпавшие по ключу строки из второй таблицы.

Наиболее часто используемым соединением является левое соединение: его используют  всякий раз, когда просматривают дополнительные данные из другой таблицы, потому что оно сохраняет исходные наблюдения, даже если совпадения нет. Левое соединение должно быть соединением по умолчанию: используйте его, если у нет веских причин предпочесть одно из других.

```{{r}}
left_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE,
  na_matches = c("na", "never")
)
```


Разберем подробнее левое соединение:

::: {.column-screen-inset-left layout-ncol=4 layout-valign="center"}

```{r}
x
```

```{r}
y
```

![left_join](images/dplyr_left_join.png)

```{r}
left_join(x, y, by = "key")
```
:::


##### Right Join 

right_join - сохраняет все строки из второй таблицы и соединяет все совпавшие по ключу строки из первой таблицы

```{{r}}
right_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE,
  na_matches = c("na", "never")
)
```


::: {.column-screen-inset-left layout-ncol=4 layout-valign="center"}

```{r}
x
```

```{r}
y
```

![right_join](images/dplyr_right_join.png)

```{r}
right_join(x, y, by = "key")
```
:::


##### Full Join

full_join - сохраняет все строки из обоих таблиц

```{{r}}
full_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE,
  na_matches = c("na", "never")
)
```


::: {.column-screen-inset-left layout-ncol=4 layout-valign="center"}

```{r}
x
```

```{r}
y
```

![full_join](images/dplyr_full_join.png)

```{r}
full_join(x, y, by = "key")
```
:::

### Filtering joins

Фильтрующие соединения используются для фильтрации первого фрейма на основе данных из второго фрейма данных.


#### semi_join

semi_join соединяет две таблицы подобно мутирующему соединению, но вместо добавления новых столбцов сохраняет только те строки в x, которые совпадают в y.


::: {.column-screen-inset-left layout-ncol=4 layout-valign="center"}

```{r}
x
```

```{r}
y
```

![semi_join](images/dplyr_semi_join.png)

```{r}
semi_join(x, y, by = "key")
```
:::


Важно только наличие совпадения; не имеет значения, какому наблюдению соответствует. Это означает, что фильтрующие соединения никогда не дублируют строки, как это делают мутирующие соединения.


#### anti_join

Антисоединения полезны для диагностики несоответствий соединений. Например, так можно делать проверку полноты данных по эталонным справочникам:


::: {.column-screen-inset-left layout-ncol=4 layout-valign="center"}

```{r}
x
```

```{r}
y
```

![anti_join](images/dplyr_anti_join.png)

```{r}
anti_join(x, y, by = "key")
```
:::


#### nest_join

nest_join() возвращает все строки и столбцы в x с новым столбцом в каждой строке которого вложен фрейм, содержащий все совпадения из y. Если совпадений нет, то фрейм будет пустой.

::: {.column-screen-inset-left layout-ncol=4 layout-valign="center"}

```{r}
x
```

```{r}
y
```

```{r}
nest_join(x, y, by = "key")
```

```{r}
nest_join(x, y, by = "key") %>% 
  unnest(cols = c(y))
```
:::



### Set operations

Операции с наборами требуют чтобы соединяемые фреймы данных имели одинаковое количество столбцов, эти функции объединяют два фрейма данных как бы складывая их друг под друга.

Создадим два фрейма, чтобы показать работу этих функций:

```{r}
df1 <- tribble(
  ~x, ~y,
   1,  1,
   2,  1
)
df2 <- tribble(
  ~x, ~y,
   1,  1,
   1,  2
)
```


#### union

- union - оставляет только уникальные строки из обоих наборов
- union_all - оставляет все строки из обоих наборов


::: {.column-screen-inset-left layout-ncol=4 layout-valign="top"}

```{r}
df1
```

```{r}
df2
```

```{r}
union(df1, df2)
```

```{r}
union_all(df1, df2)
```
:::



#### intersect

оставляет только совпавшие строки из обоих наборов:


::: {.column-screen-inset-left layout-ncol=4 layout-valign="center"}

```{r}
df1
```

```{r}
df2
```

![intersect](images/dplyr_intersect.png)

```{r}
intersect(df1, df2)
```
:::


#### setdiff


оставляет строки из первого фрейма только не совпавшие со строками из второго фрейма


::: {.column-screen-inset-left layout-ncol=5 layout-valign="center"}

```{r}
df1
```

```{r}
df2
```

![intersect](images/dplyr_setdiff.png)

```{r}
setdiff(df1, df2)
```

```{r}
setdiff(df2, df1)
```

:::


